using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FluentHyperV.SourceGenerator;

[Generator]
public class PsObjectMapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes marked with PSObjectMapperAttribute
        var classDeclarations = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx)
            )
            .Where(static m => m is not null);

        // Combine with compilation to get semantic information
        var compilationAndClasses = context.CompilationProvider.Combine(
            classDeclarations.Collect()
        );

        // Generate the source
        context.RegisterSourceOutput(
            compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc)
        );
    }

    static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        // Check if the class has PSObjectMapperAttribute
        foreach (var attributeListSyntax in classDeclaration.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (
                    context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol
                    is IMethodSymbol attributeSymbol
                )
                {
                    var attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                    var fullName = attributeContainingTypeSymbol.ToDisplayString();

                    if (
                        fullName
                        == $"FluentHyperV.SourceGenerator.{nameof(PsObjectMapperAttribute)}"
                    )
                    {
                        return classDeclaration;
                    }
                }
            }
        }

        return null;
    }

    static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classes,
        SourceProductionContext context
    )
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        var distinctClasses = classes.Distinct();

        foreach (var classDeclaration in distinctClasses)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

            if (classSymbol is null)
                continue;

            var source = GenerateMapperMethods(classSymbol);
            var fileName = $"{classSymbol.Name}.PSObjectMapper.g.cs";

            context.AddSource(fileName, source);
        }
    }

    static string GenerateMapperMethods(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : classSymbol.ContainingNamespace.ToDisplayString();

        var className = classSymbol.Name;

        // Get attribute parameters
        var mapperAttribute = classSymbol
            .GetAttributes()
            .FirstOrDefault(a =>
                a.AttributeClass?.ToDisplayString()
                == "FluentHyperV.SourceGenerator.PSObjectMapperAttribute"
            );

        var propertyPrefix =
            GetAttributePropertyValue<string>(mapperAttribute, "PropertyPrefix") ?? "";
        var ignoreCase = GetAttributePropertyValue<bool?>(mapperAttribute, "IgnoreCase") ?? true;
        var stringComparison = ignoreCase
            ? "StringComparison.OrdinalIgnoreCase"
            : "StringComparison.Ordinal";

        // Get all public properties
        var properties = classSymbol
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && p.CanBeReferencedByName)
            .Where(p => !HasIgnoreAttribute(p))
            .ToList();

        var sourceBuilder = new StringBuilder();

        // File header
        sourceBuilder.AppendLine("// <auto-generated/>");
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Management.Automation;");
        sourceBuilder.AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(namespaceName))
        {
            sourceBuilder.AppendLine($"namespace {namespaceName}");
            sourceBuilder.AppendLine("{");
        }

        // Class declaration
        var indentLevel = string.IsNullOrEmpty(namespaceName) ? 0 : 1;
        var indent = new string(' ', indentLevel * 4);

        sourceBuilder.AppendLine($"{indent}public partial class {className}");
        sourceBuilder.AppendLine($"{indent}{{");

        // Generate FromPSObject static method
        sourceBuilder.AppendLine($"{indent}    /// <summary>");
        sourceBuilder.AppendLine(
            $"{indent}    /// Creates a new instance of {className} from a PSObject"
        );
        sourceBuilder.AppendLine($"{indent}    /// </summary>");
        sourceBuilder.AppendLine(
            $"{indent}    /// <param name=\"psObject\">The PSObject to map from</param>"
        );
        sourceBuilder.AppendLine(
            $"{indent}    /// <returns>A new instance of {className}</returns>"
        );
        sourceBuilder.AppendLine(
            $"{indent}    public static {className} FromPSObject(PSObject psObject)"
        );
        sourceBuilder.AppendLine($"{indent}    {{");
        sourceBuilder.AppendLine($"{indent}        if (psObject == null)");
        sourceBuilder.AppendLine(
            $"{indent}            throw new ArgumentNullException(nameof(psObject));"
        );
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine($"{indent}        var result = new {className}();");
        sourceBuilder.AppendLine($"{indent}        result.MapFromPSObject(psObject);");
        sourceBuilder.AppendLine($"{indent}        return result;");
        sourceBuilder.AppendLine($"{indent}    }}");
        sourceBuilder.AppendLine();

        // Generate MapFromPSObject instance method
        sourceBuilder.AppendLine($"{indent}    /// <summary>");
        sourceBuilder.AppendLine(
            $"{indent}    /// Maps properties from a PSObject to this instance"
        );
        sourceBuilder.AppendLine($"{indent}    /// </summary>");
        sourceBuilder.AppendLine(
            $"{indent}    /// <param name=\"psObject\">The PSObject to map from</param>"
        );
        sourceBuilder.AppendLine($"{indent}    public void MapFromPSObject(PSObject psObject)");
        sourceBuilder.AppendLine($"{indent}    {{");
        sourceBuilder.AppendLine($"{indent}        if (psObject == null)");
        sourceBuilder.AppendLine(
            $"{indent}            throw new ArgumentNullException(nameof(psObject));"
        );
        sourceBuilder.AppendLine();

        // Generate property mappings
        foreach (var property in properties)
        {
            var propertyName = GetMappedPropertyName(property, propertyPrefix);
            var targetPropertyName = property.Name;

            sourceBuilder.AppendLine(
                $"{indent}        // Map {propertyName} -> {targetPropertyName}"
            );
            sourceBuilder.AppendLine(
                $"{indent}        if (psObject.Properties[\"{propertyName}\"] != null)"
            );
            sourceBuilder.AppendLine($"{indent}        {{");
            sourceBuilder.AppendLine(
                $"{indent}            var value = psObject.Properties[\"{propertyName}\"].Value;"
            );
            sourceBuilder.AppendLine($"{indent}            if (value != null)");
            sourceBuilder.AppendLine($"{indent}            {{");

            GeneratePropertyMapping(sourceBuilder, property, indent + "                ");

            sourceBuilder.AppendLine($"{indent}            }}");
            sourceBuilder.AppendLine($"{indent}        }}");
            sourceBuilder.AppendLine();
        }

        sourceBuilder.AppendLine($"{indent}    }}");

        // Close class
        sourceBuilder.AppendLine($"{indent}}}");

        // Close namespace
        if (!string.IsNullOrEmpty(namespaceName))
        {
            sourceBuilder.AppendLine("}");
        }

        return sourceBuilder.ToString();
    }

    static void GeneratePropertyMapping(
        StringBuilder sourceBuilder,
        IPropertySymbol property,
        string indent
    )
    {
        var typeName = property.Type.ToDisplayString();
        var propertyName = property.Name;

        // Handle different types
        if (property.Type.SpecialType == SpecialType.System_String)
        {
            sourceBuilder.AppendLine($"{indent}this.{propertyName} = value.ToString();");
        }
        else if (property.Type.SpecialType == SpecialType.System_Int32)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (int.TryParse(value.ToString(), out var intValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = intValue;");
        }
        else if (property.Type.SpecialType == SpecialType.System_Int64)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (long.TryParse(value.ToString(), out var longValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = longValue;");
        }
        else if (property.Type.SpecialType == SpecialType.System_Boolean)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (bool.TryParse(value.ToString(), out var boolValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = boolValue;");
        }
        else if (property.Type.SpecialType == SpecialType.System_DateTime)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (DateTime.TryParse(value.ToString(), out var dateTimeValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = dateTimeValue;");
        }
        else if (property.Type.SpecialType == SpecialType.System_Double)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (double.TryParse(value.ToString(), out var doubleValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = doubleValue;");
        }
        else if (property.Type.SpecialType == SpecialType.System_Single)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (float.TryParse(value.ToString(), out var floatValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = floatValue;");
        }
        else if (IsNullableType(property.Type, out var underlyingType))
        {
            // Handle nullable types
            GenerateNullableMapping(sourceBuilder, underlyingType, propertyName, indent);
        }
        else
        {
            // For other types, try direct assignment with casting
            sourceBuilder.AppendLine($"{indent}try");
            sourceBuilder.AppendLine($"{indent}{{");
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = ({typeName})value;");
            sourceBuilder.AppendLine($"{indent}}}");
            sourceBuilder.AppendLine($"{indent}catch");
            sourceBuilder.AppendLine($"{indent}{{");
            sourceBuilder.AppendLine($"{indent}    // Type conversion failed, skip this property");
            sourceBuilder.AppendLine($"{indent}}}");
        }
    }

    static void GenerateNullableMapping(
        StringBuilder sourceBuilder,
        ITypeSymbol underlyingType,
        string propertyName,
        string indent
    )
    {
        if (underlyingType.SpecialType == SpecialType.System_Int32)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (int.TryParse(value.ToString(), out var intValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = intValue;");
        }
        else if (underlyingType.SpecialType == SpecialType.System_Int64)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (long.TryParse(value.ToString(), out var longValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = longValue;");
        }
        else if (underlyingType.SpecialType == SpecialType.System_Boolean)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (bool.TryParse(value.ToString(), out var boolValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = boolValue;");
        }
        else if (underlyingType.SpecialType == SpecialType.System_DateTime)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (DateTime.TryParse(value.ToString(), out var dateTimeValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = dateTimeValue;");
        }
        else if (underlyingType.SpecialType == SpecialType.System_Double)
        {
            sourceBuilder.AppendLine(
                $"{indent}if (double.TryParse(value.ToString(), out var doubleValue))"
            );
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = doubleValue;");
        }
        else
        {
            var typeName = underlyingType.ToDisplayString();
            sourceBuilder.AppendLine($"{indent}try");
            sourceBuilder.AppendLine($"{indent}{{");
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = ({typeName})value;");
            sourceBuilder.AppendLine($"{indent}}}");
            sourceBuilder.AppendLine($"{indent}catch");
            sourceBuilder.AppendLine($"{indent}{{");
            sourceBuilder.AppendLine($"{indent}    this.{propertyName} = null;");
            sourceBuilder.AppendLine($"{indent}}}");
        }
    }

    static bool IsNullableType(ITypeSymbol type, out ITypeSymbol underlyingType)
    {
        if (
            type is INamedTypeSymbol namedType
            && namedType.IsGenericType
            && namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T
        )
        {
            underlyingType = namedType.TypeArguments[0];
            return true;
        }

        underlyingType = type;
        return false;
    }

    static bool HasIgnoreAttribute(IPropertySymbol property)
    {
        return property
            .GetAttributes()
            .Any(a =>
                a.AttributeClass?.ToDisplayString()
                == "FluentHyperV.SourceGenerator.PSIgnoreAttribute"
            );
    }

    static string GetMappedPropertyName(IPropertySymbol property, string prefix)
    {
        // Check for PSPropertyAttribute
        var psPropertyAttribute = property
            .GetAttributes()
            .FirstOrDefault(a =>
                a.AttributeClass?.ToDisplayString()
                == "FluentHyperV.SourceGenerator.PSPropertyAttribute"
            );

        if (psPropertyAttribute?.ConstructorArguments.Length > 0)
        {
            var name = psPropertyAttribute.ConstructorArguments[0].Value?.ToString();
            if (!string.IsNullOrEmpty(name))
                return name;
        }

        return prefix + property.Name;
    }

    static T? GetAttributePropertyValue<T>(AttributeData? attribute, string propertyName)
    {
        if (attribute == null)
            return default;

        var namedArg = attribute.NamedArguments.FirstOrDefault(kvp => kvp.Key == propertyName);

        if (namedArg.Value.Value is T value)
            return value;

        return default;
    }
}
