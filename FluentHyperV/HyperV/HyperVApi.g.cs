using System.Collections;
using System.Diagnostics;
using System.Management.Automation;
using System.Text.Json;
using FluentHyperV.PowerShell;
using FluentHyperV.SourceGenerator;
using Microsoft.HyperV.PowerShell;
using Microsoft.HyperV.PowerShell.Commands;
using Microsoft.Management.Infrastructure;
using Microsoft.Vhd.PowerShell;

namespace FluentHyperV.HyperV;

public class HyperVApi
{
    public class Export_VMSnapshotArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine checkpoint is to be exported.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the checkpoint to be exported.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that a **VMSnapshot** object is to be passed through to the pipeline representing the checkpoint to be exported.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to the folder into which the checkpoint is to be exported.
         */
        public required string? Path { get; set; }

        /**
         * Specifies the virtual machine of which the checkpoint is to be exported.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine of which the checkpoint is to be exported.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the checkpoint to be exported.
         */
        public required VMSnapshot[]? VMSnapshot { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/export-vmsnapshot?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Exports a virtual machine checkpoint to disk.
     * </summary>
     * <remarks>
     * The **Export-VMSnapshot** cmdlet exports a virtual machine checkpoint to disk.
    
    Note: In Windows Server 2012 R2, virtual machine snapshots were renamed to virtual machine checkpoints. For clarity, this document will refer to virtual machine snapshots as checkpoints.
     * </remarks>
     */
    public void Export_VMSnapshot(Export_VMSnapshotArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Export-VMSnapshot", parameters);
    }

    public class Get_VMSnapshotArguments
    {
        /**
         * Specifies the checkpoint whose child checkpoints are to be retrieved.
        This retrieves immediate children only.
         */
        public required VMSnapshot? ChildOf { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which checkpoints are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the unique identifier of the virtual machine whose checkpoints are to be retrieved.
         */
        public required Guid? Id { get; set; }

        /**
         * Specifies the name of the checkpoint to be retrieved.
         */
        public string? Name { get; set; }

        /**
         * Specifies the checkpoint whose immediate parent checkpoint is to be retrieved.
         */
        public required VirtualMachineBase? ParentOf { get; set; }

        /**
         * Specifies the type of the checkpoints to be retrieved.
        Allowed values are **Standard**, **Recovery**, **Planned**, **Missing**, **Replica**, **AppConsistentReplica**, and **SyncedReplica**.
         */
        public SnapshotType? SnapshotType { get; set; }

        /**
         * Specifies the virtual machine whose checkpoints are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose checkpoints are to be retrieved.
         */
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmsnapshot?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the checkpoints associated with a virtual machine or checkpoint.
     * </summary>
     * <remarks>
     * The **Get-VMSnapshot** cmdlet gets the checkpoints associated with a virtual machine or checkpoint.
    
    Note: In Windows Server 2012 R2, virtual machine snapshots were renamed to virtual machine checkpoints. For clarity, this document will refer to virtual machine snapshots as checkpoints.
     * </remarks>
     */
    public VMSnapshot[] Get_VMSnapshot(Get_VMSnapshotArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.ChildOf is not null)
            parameters.Add("ChildOf", args.ChildOf);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.ParentOf is not null)
            parameters.Add("ParentOf", args.ParentOf);
        if (args.SnapshotType is not null)
            parameters.Add("SnapshotType", args.SnapshotType);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSnapshot>("Get-VMSnapshot", parameters);
        return result;
    }

    public class Remove_VMSnapshotArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which this cmdlet deletes a checkpoint.
        NetBIOS names, IP addresses, and fully-qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the checkpoint's children are to be deleted along with the checkpoint.
         */
        public SwitchParameter? IncludeAllChildSnapshots { get; set; }

        /**
         * Specifies the name of the checkpoint to be deleted.
         */
        public string[]? Name { get; set; }

        /**
         * Indicates that this cmdlet returns a **Microsoft.HyperV.PowerShell.VirtualMachine** object that represents the checkpoint that it deletes.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine of which the checkpoint is to be deleted.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine of which the checkpoint is to be deleted.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the checkpoint to be deleted.
         */
        public required VMSnapshot[]? VMSnapshot { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmsnapshot?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Export-VMSnapshot.md">Export-VMSnapshot</see>
     *
     * <see href="./Get-VMSnapshot.md">Get-VMSnapshot</see>
     *
     * <see href="./Rename-VMSnapshot.md">Rename-VMSnapshot</see>
     *
     * <see href="./Restore-VMSnapshot.md">Restore-VMSnapshot</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     * Deletes a virtual machine checkpoint.
     * </summary>
     * <remarks>
     * The **Remove-VMSnapshot** cmdlet deletes a virtual machine checkpoint.
    
    Note: In Windows Server 2012 R2, virtual machine snapshots were renamed to virtual machine checkpoints. For clarity, this document will refer to virtual machine snapshots as checkpoints.
     * </remarks>
     */
    public void Remove_VMSnapshot(Remove_VMSnapshotArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.IncludeAllChildSnapshots is not null)
            parameters.Add("IncludeAllChildSnapshots", args.IncludeAllChildSnapshots);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMSnapshot", parameters);
    }

    public class Rename_VMSnapshotArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine checkpoint is to be renamed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual machine checkpoint to be renamed.
         */
        public required string? Name { get; set; }

        /**
         * Specifies the name to which the virtual machine checkpoint is to be renamed.
         */
        public required string? NewName { get; set; }

        /**
         * Specifies that a **VMSnapshot** object is to be passed through to the pipeline representing the virtual machine checkpoint to be renamed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine of which the checkpoint is to be renamed.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Specifies the name of the virtual machine of which the checkpoint is to be renamed.
         */
        public required string? VMName { get; set; }

        /**
         * Specifies the virtual machine checkpoint to be renamed.
         */
        public required VMSnapshot? VMSnapshot { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/rename-vmsnapshot?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Renames a virtual machine checkpoint.
     * </summary>
     * <remarks>
     * The **Rename-VMSnapshot** cmdlet renames a virtual machine checkpoint.
    
    Note: In Windows Server 2012 R2, virtual machine snapshots were renamed to virtual machine checkpoints. For clarity, this document will refer to virtual machine snapshots as checkpoints.
     * </remarks>
     */
    public void Rename_VMSnapshot(Rename_VMSnapshotArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NewName is not null)
            parameters.Add("NewName", args.NewName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Rename-VMSnapshot", parameters);
    }

    public class Restore_VMSnapshotArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine checkpoint is to be restored.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the checkpoint to be restored.
         */
        public required string? Name { get; set; }

        /**
         * Specifies that a **VMSnapshot** is to be passed through to the pipeline representing the checkpoint to be restored.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine to be restored.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Specifies the name of the virtual machine to be restored.
         */
        public required string? VMName { get; set; }

        /**
         * Specifies an array of **VMSnapshot** objects.
        To obtain a **VMSnapshot** object, use the **Get-VMSnapshot** cmdlet.
        The cmdlet restores the virtual machine checkpoints that you specify.
         */
        public required VMSnapshot? VMSnapshot { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/restore-vmsnapshot?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMSnapshot.md">Get-VMSnapshot</see>
     * Restores a virtual machine checkpoint.
     * </summary>
     * <remarks>
     * The **Restore-VMSnapshot** cmdlet restores a virtual machine checkpoint.
    
    Note: In Windows Server 2012 R2, virtual machine snapshots were renamed to virtual machine checkpoints. For clarity, this document will refer to virtual machine snapshots as checkpoints.
     * </remarks>
     */
    public void Restore_VMSnapshot(Restore_VMSnapshotArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Restore-VMSnapshot", parameters);
    }

    public class Add_VMAssignableDeviceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the assignable devices are to be retrieved. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Represents the Device Instance path in the host machine.
         */
        public string? InstancePath { get; set; }

        /**
         * Specifies the location path to the assignable device
         */
        public string? LocationPath { get; set; }

        /**
         * Returns an object for each process that the cmdlet started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the resource pool to which the device is to be assigned.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Specifies the number of the virtual function (VF) of an SR-IOV-capable network adapter assigned to
        the virtual machine.
         */
        public UInt16? VirtualFunction { get; set; }

        /**
         * Specifies the virtual machine to which the device is to be assigned.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine to which the device is to be assigned.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmassignabledevice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="get-vmassignabledevice.md">Get-VMAssignableDevice</see>
     *
     * <see href="remove-vmassignabledevice.md">Remove-VMAssignableDevice</see>
     * Adds an assignable device to a specific virtual machine.
     * </summary>
     * <remarks>
     * The `Add-VMAssignableDevice` cmdlet assigns a physical device to a specified virtual machine (VM). This is commonly used for tasks such as attaching GPUs or network adapters directly to a VM to enhance performance for specific applications or workloads. The device can be specified through its instance path, location path, or assignable device object.
     * </remarks>
     */
    public VMAssignedDevice[] Add_VMAssignableDevice(Add_VMAssignableDeviceArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.InstancePath is not null)
            parameters.Add("InstancePath", args.InstancePath);
        if (args.LocationPath is not null)
            parameters.Add("LocationPath", args.LocationPath);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.VirtualFunction is not null)
            parameters.Add("VirtualFunction", args.VirtualFunction);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMAssignedDevice>(
            "Add-VMAssignableDevice",
            parameters
        );
        return result;
    }

    public class Add_VMDvdDriveArguments
    {
        /**
         * Specifies that no error is to be thrown if the specified path is not verified as accessible by the cluster.
        This parameter is applicable to clustered virtual machines.
         */
        public SwitchParameter? AllowUnverifiedPaths { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-v hosts on which the DVD drive is to be added.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies the number of the location on the controller at which the DVD drive is to be added.
        If not specified, the number of the first available location on the controller is used.
         */
        public int? ControllerLocation { get; set; }

        /**
         * Specifies the number of the controller to which the DVD drive is to be added.
        If not specified, the first IDE controller on which the specified **ControllerLocation** is available is used.
         */
        public int? ControllerNumber { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Passes the added **Microsoft.HyperV.PowerShell.DvdDrive** through to the pipeline.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the full path to the virtual hard disk file or physical hard disk volume for the added DVD drive.
         */
        public string? Path { get; set; }

        /**
         * Specifies the friendly name of the ISO resource pool to which this DVD drive is to be associated.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Specifies the virtual machine to which the DVD drive is to be added.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the drive controller to which the DVD drive is to be added.
         */
        public required VMDriveController[]? VMDriveController { get; set; }

        /**
         * Specifies the name of the virtual machine to which the DVD drive is to be added.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmdvddrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a DVD drive to a virtual machine.
     * </summary>
     * <remarks>
     * The **Add-VMDvdDrive** cmdlet adds a DVD drive to a virtual machine.
     * </remarks>
     */
    public DvdDrive[] Add_VMDvdDrive(Add_VMDvdDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowUnverifiedPaths is not null)
            parameters.Add("AllowUnverifiedPaths", args.AllowUnverifiedPaths);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMDriveController is not null)
            parameters.Add("VMDriveController", args.VMDriveController);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<DvdDrive>("Add-VMDvdDrive", parameters);
        return result;
    }

    public class Add_VMFibreChannelHbaArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual Fibre Channel host bus adapter is to be added.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the world wide names for the Fibre Channel host bus adapter are to be generated automatically.
        When specified, the **WorldWideNodeNameSetA**, **WorldWideNodeNameSetB**, **WorldWidePortNameSetA**, and **WorldWidePortNameSetB** parameters cannot be used.
         */
        public SwitchParameter? GenerateWwn { get; set; }

        /**
         * Specifies that an object representing the virtual machine to which the virtual Fibre Channel host bus adapter being added is to be passed through to the pipeline.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual storage area network (SAN) name to associate with this virtual Fibre Channel host bus adapter.
        Use the **Get-VMSan** cmdlet to get a list of all virtual SANs on the host.
         */
        public required string? SanName { get; set; }

        /**
         * Specifies the virtual machine to which the virtual Fibre Channel host bus adapter is to be added.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine to which the virtual Fibre Channel host bus adapter is to be added.
         */
        public required string? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }

        /**
         * Specifies the world wide node name of address A associated with the Fibre Channel host bus adapter to be added.
         */
        public required string? WorldWideNodeNameSetA { get; set; }

        /**
         * Specifies the world wide node name of address B associated with the Fibre Channel host bus adapter to be added.
         */
        public required string? WorldWideNodeNameSetB { get; set; }

        /**
         * Specifies the world wide port name of address A associated with the Fibre Channel host bus adapter to be added.
         */
        public required string? WorldWidePortNameSetA { get; set; }

        /**
         * Specifies the world wide port name of address B associated with the Fibre Channel host bus adapter to be added.
         */
        public required string? WorldWidePortNameSetB { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmfibrechannelhba?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a virtual Fibre Channel host bus adapter to a virtual machine.
     * </summary>
     * <remarks>
     * The **Add-VMFibreChannelHba** cmdlet adds a virtual Fibre Channel host bus adapter to a virtual machine.
     * </remarks>
     */
    public void Add_VMFibreChannelHba(Add_VMFibreChannelHbaArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.GenerateWwn is not null)
            parameters.Add("GenerateWwn", args.GenerateWwn);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SanName is not null)
            parameters.Add("SanName", args.SanName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        if (args.WorldWideNodeNameSetA is not null)
            parameters.Add("WorldWideNodeNameSetA", args.WorldWideNodeNameSetA);
        if (args.WorldWideNodeNameSetB is not null)
            parameters.Add("WorldWideNodeNameSetB", args.WorldWideNodeNameSetB);
        if (args.WorldWidePortNameSetA is not null)
            parameters.Add("WorldWidePortNameSetA", args.WorldWidePortNameSetA);
        if (args.WorldWidePortNameSetB is not null)
            parameters.Add("WorldWidePortNameSetB", args.WorldWidePortNameSetB);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMFibreChannelHba", parameters);
    }

    public class Add_VMGpuPartitionAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which virtual machines are to be retrieved. NetBIOS names,
        IP addresses, and fully qualified domain names are allowable. The default is the local computer.
        Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Represents the Device Instance path of a GPU in the host. This value can be obtained from the
        "Name" property of the command `Get-VMHostPartitionableGpu`.
         */
        public string? InstancePath { get; set; }

        /**
         * The maximum number of compute assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MaxPartitionCompute { get; set; }

        /**
         * The maximum number of decoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MaxPartitionDecode { get; set; }

        /**
         * The maximum number of encoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MaxPartitionEncode { get; set; }

        /**
         * The maximum VRAM in bytes supported by the host GPU. This is defined by the manufacturer's driver.
         */
        public UInt64? MaxPartitionVRAM { get; set; }

        /**
         * The minimum number of compute assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MinPartitionCompute { get; set; }

        /**
         * The minimum number of decoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MinPartitionDecode { get; set; }

        /**
         * The minimum number of encoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MinPartitionEncode { get; set; }

        /**
         * The minimum VRAM in bytes supported by the host GPU. This is defined by the manufacturer's driver.
         */
        public UInt64? MinPartitionVRAM { get; set; }

        /**
         * The optimal number of compute assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? OptimalPartitionCompute { get; set; }

        /**
         * The optimal number of decoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? OptimalPartitionDecode { get; set; }

        /**
         * The optimal number of encoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? OptimalPartitionEncode { get; set; }

        /**
         * The optimal VRAM in bytes supported by the host GPU. This is defined by the manufacturer's driver.
         */
        public UInt64? OptimalPartitionVRAM { get; set; }

        /**
         * Returns an object for each process that the cmdlet started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine on which the network adapter is to be added.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine on which the network adapter is to be added.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmgpupartitionadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="get-vmgpupartitionadapter.md">Get-VMGpuPartitionAdapter</see>
     *
     * <see href="remove-vmgpupartitionadapter.md">Remove-VMGpuPartitionAdapter</see>
     *
     * <see href="set-vmgpupartitionadapter.md">Set-VMGpuPartitionAdapter</see>
     * Adds a GPU partition adapter to a virtual machine.
     * </summary>
     * <remarks>
     * The `Add-VMGpuPartitionAdapter` cmdlet adds a GPU partition adapter to a virtual machine. With no parameter, it assigns a full partition from an assignable GPU to a VM.
     * </remarks>
     */
    public VMGpuPartitionAdapter[] Add_VMGpuPartitionAdapter(
        Add_VMGpuPartitionAdapterArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.InstancePath is not null)
            parameters.Add("InstancePath", args.InstancePath);
        if (args.MaxPartitionCompute is not null)
            parameters.Add("MaxPartitionCompute", args.MaxPartitionCompute);
        if (args.MaxPartitionDecode is not null)
            parameters.Add("MaxPartitionDecode", args.MaxPartitionDecode);
        if (args.MaxPartitionEncode is not null)
            parameters.Add("MaxPartitionEncode", args.MaxPartitionEncode);
        if (args.MaxPartitionVRAM is not null)
            parameters.Add("MaxPartitionVRAM", args.MaxPartitionVRAM);
        if (args.MinPartitionCompute is not null)
            parameters.Add("MinPartitionCompute", args.MinPartitionCompute);
        if (args.MinPartitionDecode is not null)
            parameters.Add("MinPartitionDecode", args.MinPartitionDecode);
        if (args.MinPartitionEncode is not null)
            parameters.Add("MinPartitionEncode", args.MinPartitionEncode);
        if (args.MinPartitionVRAM is not null)
            parameters.Add("MinPartitionVRAM", args.MinPartitionVRAM);
        if (args.OptimalPartitionCompute is not null)
            parameters.Add("OptimalPartitionCompute", args.OptimalPartitionCompute);
        if (args.OptimalPartitionDecode is not null)
            parameters.Add("OptimalPartitionDecode", args.OptimalPartitionDecode);
        if (args.OptimalPartitionEncode is not null)
            parameters.Add("OptimalPartitionEncode", args.OptimalPartitionEncode);
        if (args.OptimalPartitionVRAM is not null)
            parameters.Add("OptimalPartitionVRAM", args.OptimalPartitionVRAM);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMGpuPartitionAdapter>(
            "Add-VMGpuPartitionAdapter",
            parameters
        );
        return result;
    }

    public class Add_VMGroupMemberArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies on or more Hyper-V hosts where this cmdlet adds a group member.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the unique ID of the virtual machine group to which this cmdlet adds virtual machines or groups of virtual machines.
         */
        public required Guid? Id { get; set; }

        /**
         * Specifies the name of the virtual machine group to which this cmdlet adds virtual machines or groups of virtual machines.
         */
        public required string? Name { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VMGroup** object that it configures.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machines that this cmdlet adds to a virtual machine group.
        To obtain a **VirtualMachine** object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the virtual machine group to which this cmdlet adds virtual machines or groups of virtual machines.
        To obtain a **VMGroup** object, use the **Get-VMGroup** cmdlet.
         */
        public required VMGroup? VMGroup { get; set; }

        /**
         * Specifies an array of virtual machine groups that this cmdlet adds to a virtual machine group.
         */
        public required VMGroup[]? VMGroupMember { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmgroupmember?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Remove-VMGroupMember.md">Remove-VMGroupMember</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     *
     * <see href="./Get-VMGroup.md">Get-VMGroup</see>
     * Adds group members to a virtual machine group.
     * </summary>
     * <remarks>
     * The **Add-VMGroupMember** cmdlet adds members to a virtual machine group. Groups can contain either virtual machines or groups of virtual machines.
     * </remarks>
     * <returns>This cmdlet returns a **VMGroup** object, if you specify the **Passthru** parameter.</returns>
     */
    public VMGroup[] Add_VMGroupMember(Add_VMGroupMemberArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMGroup is not null)
            parameters.Add("VMGroup", args.VMGroup);
        if (args.VMGroupMember is not null)
            parameters.Add("VMGroupMember", args.VMGroupMember);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMGroup>("Add-VMGroupMember", parameters);
        return result;
    }

    public class Add_VMHardDiskDriveArguments
    {
        /**
         * Specifies that no error is to be thrown if the specified path is not verified as accessible by the cluster.
        This parameter is applicable to clustered virtual machines.
         */
        public SwitchParameter? AllowUnverifiedPaths { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies the number of the location on the controller at which the hard disk drive is to be added.
        If not specified, the first available location in the controller specified with the **ControllerNumber** parameter is used.
         */
        public int? ControllerLocation { get; set; }

        /**
         * Specifies the number of the controller to which the hard disk drive is to be added.
        If not specified, this parameter assumes the value of the first available controller at the location specified in the **ControllerLocation** parameter.
         */
        public int? ControllerNumber { get; set; }

        /**
         * Specifies the type of the controller to which the hard disk drive is to be added.
        If not specified, **IDE** is attempted first.
        If the IDE controller port at the specified number and location is already connected to a drive, then it will try to create one on the SCSI controller specified by **ControllerNumber**.
        Allowed values are **IDE** and **SCSI**.
         */
        public ControllerType? ControllerType { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the disk number of the offline physical hard drive to be connected as a passthrough disk.
         */
        public UInt32? DiskNumber { get; set; }

        /**
         * Specifies the maximum normalized I/O operations per second (IOPS) for the hard disk.
        Hyper-V calculates normalized IOPS as the total size of I/O per second divided by 8 KB.
         */
        public UInt64? MaximumIOPS { get; set; }

        /**
         * Specifies the minimum normalized I/O operations per second (IOPS) for the hard disk.
        Hyper-V calculates normalized IOPS as the total size of I/O per second divided by 8 KB.
         */
        public UInt64? MinimumIOPS { get; set; }

        /**
         *
         */
        public CacheAttributes? OverrideCacheAttributes { get; set; }

        /**
         * Passes the added **Microsoft.HyperV.PowerShell.HardDiskDrive** object through to the pipeline.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the full path of the hard disk drive file to be added.
         */
        public string? Path { get; set; }

        /**
         * Specifies the name of the storage Quality of Service (QoS) policy that this cmdlet associates with the hard disk drive.
         */
        public CimInstance? QoSPolicy { get; set; }

        /**
         * Specifies the unique ID for a storage QoS policy that this cmdlet associates with the hard disk drive.
         */
        public string? QoSPolicyID { get; set; }

        /**
         * Specifies the friendly name of the ISO resource pool to which this virtual hard disk is to be associated.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Indicates that the hard disk supports SCSI persistent reservation semantics.
        Specify this parameter when the hard disk is a shared disk that is used by multiple virtual machines.
         */
        public SwitchParameter? SupportPersistentReservations { get; set; }

        /**
         * Specifies the virtual machine to which the hard disk drive is to be added.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the controller to which the hard disk drive is to be added.
         */
        public required VMDriveController? VMDriveController { get; set; }

        /**
         * Specifies the name of the virtual machine to which the hard disk drive is to be added.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmharddiskdrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a hard disk drive to a virtual machine.
     * </summary>
     * <remarks>
     * The **Add-VMHardDiskDrive** cmdlet adds a hard disk drive to a virtual machine.
     * </remarks>
     */
    public void Add_VMHardDiskDrive(Add_VMHardDiskDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowUnverifiedPaths is not null)
            parameters.Add("AllowUnverifiedPaths", args.AllowUnverifiedPaths);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.ControllerType is not null)
            parameters.Add("ControllerType", args.ControllerType);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DiskNumber is not null)
            parameters.Add("DiskNumber", args.DiskNumber);
        if (args.MaximumIOPS is not null)
            parameters.Add("MaximumIOPS", args.MaximumIOPS);
        if (args.MinimumIOPS is not null)
            parameters.Add("MinimumIOPS", args.MinimumIOPS);
        if (args.OverrideCacheAttributes is not null)
            parameters.Add("OverrideCacheAttributes", args.OverrideCacheAttributes);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.QoSPolicy is not null)
            parameters.Add("QoSPolicy", args.QoSPolicy);
        if (args.QoSPolicyID is not null)
            parameters.Add("QoSPolicyID", args.QoSPolicyID);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.SupportPersistentReservations is not null)
            parameters.Add("SupportPersistentReservations", args.SupportPersistentReservations);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMDriveController is not null)
            parameters.Add("VMDriveController", args.VMDriveController);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMHardDiskDrive", parameters);
    }

    public class Add_VMHostAssignableDeviceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies the name of the Hyper-V host to which the device is to be added. NetBIOS names, IP
        addresses, and fully qualified domain names are allowed. The default is the local computer. Use
        localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies the device object to be assigned to the virtual machine.
         */
        public required VMHostAssignableDevice[]? HostAssignableDevice { get; set; }

        /**
         * Represents the Device Instance path in the host machine.
         */
        public string? InstancePath { get; set; }

        /**
         * Specifies the location path to the assignable device.
         */
        public string? LocationPath { get; set; }

        /**
         * Specifies the name of the resource pool to which the device is assigned.
         */
        public required string[]? ResourcePoolName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmhostassignabledevice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="get-vmhostassignabledevice.md">Get-VMHostAssignableDevice</see>
     *
     * <see href="dismount-vmhostassignabledevice.md">Dismount-VMHostAssignableDevice</see>
     *
     * <see href="mount-vmhostassignabledevice.md">Mount-VMHostAssignableDevice</see>
     *
     * <see href="remove-vmhostassignabledevice.md">Remove-VMHostAssignableDevice</see>
     * Adds an assignable device to a virtual machine (VM) host.
     * </summary>
     * <remarks>
     * The `Add-VMHostAssignableDevice` cmdlet assigns a hardware device to a virtual machine host. You can add devices to the VM host by providing either the instance or location path of the device, or by specifying an existing host-assignable device object.
     * </remarks>
     */
    public System.Object[] Add_VMHostAssignableDevice(Add_VMHostAssignableDeviceArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.HostAssignableDevice is not null)
            parameters.Add("HostAssignableDevice", args.HostAssignableDevice);
        if (args.InstancePath is not null)
            parameters.Add("InstancePath", args.InstancePath);
        if (args.LocationPath is not null)
            parameters.Add("LocationPath", args.LocationPath);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<System.Object>(
            "Add-VMHostAssignableDevice",
            parameters
        );
        return result;
    }

    public class Add_VMKeyStorageDriveArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public object? Confirm { get; set; }
        public int? ControllerLocation { get; set; }
        public int? ControllerNumber { get; set; }
        public PSCredential[]? Credential { get; set; }
        public object? Passthru { get; set; }
        public string? ResourcePoolName { get; set; }
        public required VirtualMachine[]? VM { get; set; }
        public required string[]? VMName { get; set; }
        public object? WhatIf { get; set; }
    }

    /** <summary>
     *
     * Add-VMKeyStorageDrive [-VMName] <string[]> [[-ControllerNumber] <int>] [[-ControllerLocation] <int>] [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-ResourcePoolName <string>] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * Add-VMKeyStorageDrive [-VM] <VirtualMachine[]> [[-ControllerNumber] <int>] [[-ControllerLocation] <int>] [-ResourcePoolName <string>] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public KeyStorageDrive[] Add_VMKeyStorageDrive(Add_VMKeyStorageDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<KeyStorageDrive>("Add-VMKeyStorageDrive", parameters);
        return result;
    }

    public class Add_VMMigrationNetworkArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the network is to be added for virtual machine migration.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an **Microsoft.HyperV.PowerShell.MigrationNetwork** object is to be passed through to the pipeline representing the network added for virtual machine migration.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the priority of the network to be added for virtual machine migration.
        Multiple networks can have the same priority.
         */
        public UInt32? Priority { get; set; }

        /**
         * Specifies a string representing an IPv4 or IPv6 subnet mask which identifies the network to be added for virtual machine migration.
         */
        public required string? Subnet { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmmigrationnetwork?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a network for virtual machine migration on one or more virtual machine hosts.
     * </summary>
     * <remarks>
     * The **Add-VMMigrationNetwork** cmdlet adds a network for virtual machine migration on one or more virtual machine hosts.
     * </remarks>
     */
    public void Add_VMMigrationNetwork(Add_VMMigrationNetworkArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Priority is not null)
            parameters.Add("Priority", args.Priority);
        if (args.Subnet is not null)
            parameters.Add("Subnet", args.Subnet);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMMigrationNetwork", parameters);
    }

    public class Add_VMNetworkAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual network adapter is to be added.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         *
         */
        public OnOffState? DeviceNaming { get; set; }

        /**
         * Assigns a dynamically generated MAC address to the new virtual network adapter.
         */
        public SwitchParameter? DynamicMacAddress { get; set; }

        /**
         * Specifies whether the virtual network adapter is the legacy type.
         */
        public Boolean? IsLegacy { get; set; }

        /**
         * Specifies the management operating system.
         */
        public SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies a name for the new virtual network adapter.
        The default value is "Network Adapter."
         */
        public string? Name { get; set; }

        /**
         * Specifies that an object is to be passed through to be pipeline representing the network adapter to be added.
        If you specify **-ManagementOS**, the object passed is a **Microsoft.HyperV.PowerShell.VMInternalNetworkAdapter**; otherwise the object passed is a **Microsoft.HyperV.PowerShell.VMNetworkAdapter**.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the friendly name of a resource pool.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Assigns a specific MAC address to the new virtual network adapter.
         */
        public string? StaticMacAddress { get; set; }

        /**
         * Specifies the name of the virtual switch to connect to the new network adapter.
        If the switch name is not unique, then the operation fails.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies the virtual machine on which the network adapter is to be added.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine on which the network adapter is to be added.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmnetworkadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a virtual network adapter to a virtual machine.
     * </summary>
     * <remarks>
     * The **Add-VMNetworkAdapter** cmdlet adds a virtual network adapter to a virtual machine.
     * </remarks>
     */
    public void Add_VMNetworkAdapter(Add_VMNetworkAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DeviceNaming is not null)
            parameters.Add("DeviceNaming", args.DeviceNaming);
        if (args.DynamicMacAddress is not null)
            parameters.Add("DynamicMacAddress", args.DynamicMacAddress);
        if (args.IsLegacy is not null)
            parameters.Add("IsLegacy", args.IsLegacy);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.StaticMacAddress is not null)
            parameters.Add("StaticMacAddress", args.StaticMacAddress);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMNetworkAdapter", parameters);
    }

    public class Add_VMNetworkAdapterAclArguments
    {
        /**
         * Specifies the action for the ACL.
        Allowed values are **Allow**, **Deny**, and **Meter**.
        A metering ACL must be IP-based, i.e.
        either -RemoteIPAddress or -LocalIPAddress must be specified.
         */
        public required VMNetworkAdapterAclAction? Action { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the ACL is to be created.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the direction of the network traffic to which the ACL is to apply.
        Allowed values are **Inbound**, **Outbound**, or **Both**.
        . If **Both** is specified, the new ACL entry is added to both the inbound direction and the outbound direction.
        In the output of Get-VMNetworkAdapterAcl, the ACL entry appears in both the inbound ACL list and the outbound ACL list.
         */
        public required VMNetworkAdapterAclDirection? Direction { get; set; }

        /**
         * Specifies the local IP address to which the ACL is to apply.
        For an inbound packet, this is the destination IP address in the packet header; for an outbound packet, this is the source IP address in the packet header.
        It can be either IPv4 or IPv6 address.
        It can be either a host address or a subnet address, e.g.
        1.2.3.4, 2001::2008, 192.168.1.0/24, or f001:f002:f003:f004::1/64.
        The IP address can also be a wildcard, 0.0.0.0/0 for all IPv4 addresses, ::/0 for all IPv6 addresses, or ANY for all IPv4 and IPv6 addresses.
         */
        public string[]? LocalIPAddress { get; set; }

        /**
         * Specifies the local MAC address to which the ACL is to apply.
        For an inbound packet, this is the destination MAC address in the packet header; for an outbound packet, this is the source MAC address in the packet header.
        It can be a host MAC address, e.g.
        00-ab-00-11-22-33, or a wildcard, ANY, for all MAC addresses.
         */
        public string[]? LocalMacAddress { get; set; }

        /**
         * Specifies that the ACL is to be applied in the management (i.e.
        the parent, or host) operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the ACL to be added.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the remote IP address to which this ACL is to apply.
        For an inbound packet, this is the source IP address in the packet header; for an outbound packet, this is the destination IP address in the packet header.
        It can be either IPv4 or IPv6 address.
        It can be either a host address or a subnet address, e.g.
        1.2.3.4, 2001::2008, 192.168.1.0/24, or f001:f002:f003:f004::1/64.the IP address can also be a wildcard, 0.0.0.0/0 for all IPv4 addresses, ::/0 for all IPv6 addresses, or ANY for all IPv4 and IPv6 addresses.
         */
        public string[]? RemoteIPAddress { get; set; }

        /**
         * Specifies the remote MAC address to which this ACL is to apply.
        For an inbound packet, this is the source MAC address in the packet header; for an outbound packet, this is the destination MAC address in the packet header.
        It can be a host MAC address, e.g.
        00-ab-00-11-22-33, or a wildcard, ANY, for all MAC addresses.
         */
        public string[]? RemoteMacAddress { get; set; }

        /**
         * Specifies the virtual machine on which the ACL is to apply.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine on which the ACL is to apply.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine network adapter to which the ACL is to apply.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual machine network adapter to which the ACL is to apply.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmnetworkadapteracl?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Creates an ACL to apply to the traffic through a virtual machine network adapter.
     * </summary>
     * <remarks>
     * The **Add-VMNetworkAdapterAcl** cmdlet creates an ACL to apply to the traffic through a virtual machine network adapter. When a virtual network adapter is created there is no ACL on it. Given a list of IP-based ACL entries to be applied to traffic in the same direction, the longest match rule decides which one of the entries is most appropriate to apply to a specific packet.
     * </remarks>
     */
    public void Add_VMNetworkAdapterAcl(Add_VMNetworkAdapterAclArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.Action is not null)
            parameters.Add("Action", args.Action);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Direction is not null)
            parameters.Add("Direction", args.Direction);
        if (args.LocalIPAddress is not null)
            parameters.Add("LocalIPAddress", args.LocalIPAddress);
        if (args.LocalMacAddress is not null)
            parameters.Add("LocalMacAddress", args.LocalMacAddress);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RemoteIPAddress is not null)
            parameters.Add("RemoteIPAddress", args.RemoteIPAddress);
        if (args.RemoteMacAddress is not null)
            parameters.Add("RemoteMacAddress", args.RemoteMacAddress);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMNetworkAdapterAcl", parameters);
    }

    public class Add_VMNetworkAdapterExtendedAclArguments
    {
        /**
         * Specifies the action for the ACL.
        The acceptable values for this parameter are:
        
         * - Allow
        - Deny
         */
        public required VMNetworkAdapterExtendedAclAction? Action { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet adds the ACL to the network adapters on the Hyper-V hosts that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the direction of network traffic, from the perspective of the virtual machine, to which the ACL applies.
        The cmdlet adds an ACL that has the value that you specify.
        The acceptable values for this parameter are:
        
         * - Inbound
        - Outbound
        
         * If you run the **Get-VMNetworkAdapterExtendedAcl** cmdlet, the entry that you create appears in both the inbound ACL and the outbound ACL.
         */
        public required VMNetworkAdapterExtendedAclDirection? Direction { get; set; }

        /**
         * Specifies a time-out period, in seconds, for idle sessions.
         */
        public int? IdleSessionTimeout { get; set; }

        /**
         * Specifies an ID of a virtual subnet.
        The cmdlet adds an ACL that applies to traffic on the isolated network that you specify.
        The subnet uses virtual local area network (VLAN) or Hyper-V Network Virtualization.
        For more information about isolation IDs, see the **Set-VmNetworkAdapterIsolation** cmdlet.
         */
        public int? IsolationID { get; set; }

        /**
         * Specifies the local IP address for the ACL.
        For an inbound packet, the local address is the destination IP address.
        For an outbound packet, the local address is the source IP address.
        You can specify a host address or a subnet address, or specify a wildcard, such as 0.0.0.0/0 for all IPv4 addresses, ::/0 for all IPv6 addresses, or ANY for all IPv4 and IPv6 addresses.
         */
        public string? LocalIPAddress { get; set; }

        /**
         * Specifies the local port for the ACL. A port range format can also be used (i.e. "49152-49182", for example).
        For an inbound TCP or UDP packet, the local port is the destination port.
        For an outbound packet, the local port is the source port.
         */
        public string? LocalPort { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent or host operating system.
        If you specify this parameter, this cmdlet creates an ACL that applies to the parent or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the protocol that the ACL applies to.
        The acceptable values for this parameter are:
        
         * - TCP
        - UDP
        - an integer IP protocol ID (**use 1 for ICMP**)
         */
        public string? Protocol { get; set; }

        /**
         * Specifies the local IP address for the ACL.
        For an inbound packet, the remote address is the source IP address.
        For an outbound packet, the remote address is the destination IP address.
        You can specify a host address or a subnet address, or specify a wildcard, such as 0.0.0.0/0 for all IPv4 addresses, ::/0 for all IPv6 addresses, or ANY for all IPv4 and IPv6 addresses.
         */
        public string? RemoteIPAddress { get; set; }

        /**
         * Specifies the remote port for the ACL. A port range format can also be used (i.e. "49152-49182", for example).
        For an inbound TCP or UDP packet, the remote port is the source port.
        For an outbound packet, the remote port is the destination port.
         */
        public string? RemotePort { get; set; }

        /**
         * Indicates whether the ACL applies to packets in both directions of the same session.
        If you specify a value of $True, the ACL applies to a return packet even though that packet has the opposite direction with respect to the ACL.
         */
        public Boolean? Stateful { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        The cmdlet adds an ACL for the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines.
        The cmdlet adds an ACL for the virtual machines that you specify.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies an array VM network adapters as **VMNetworkAdapterBase** objects.
        The cmdlet adds an ACL to the adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
        The cmdlet adds an ACL to the adapter that you specify.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies the weight of an ACL entry.
        Larger weight values apply first, and once an ACL entry applies to a packet, other entries are no longer relevant for that packet.
         */
        public required int? Weight { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmnetworkadapterextendedacl?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMNetworkAdapterExtendedAcl.md">Get-VMNetworkAdapterExtendedAcl</see>
     *
     * <see href="./Remove-VMNetworkAdapterExtendedAcl.md">Remove-VMNetworkAdapterExtendedAcl</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     *
     * <see href="./Set-VmNetworkAdapterIsolation.md">Set-VmNetworkAdapterIsolation</see>
     * Creates an extended ACL for a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Add-VMNetworkAdapterExtendedAcl** cmdlet creates an extended access control list (ACL) for a virtual network adapter. The ACL allows or denies access to a virtual machine network adapter for network packets based on source IP address, destination IP address, protocol, source port, and destination port.
     * </remarks>
     */
    public VMNetworkAdapterExtendedAclSetting[] Add_VMNetworkAdapterExtendedAcl(
        Add_VMNetworkAdapterExtendedAclArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.Action is not null)
            parameters.Add("Action", args.Action);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Direction is not null)
            parameters.Add("Direction", args.Direction);
        if (args.IdleSessionTimeout is not null)
            parameters.Add("IdleSessionTimeout", args.IdleSessionTimeout);
        if (args.IsolationID is not null)
            parameters.Add("IsolationID", args.IsolationID);
        if (args.LocalIPAddress is not null)
            parameters.Add("LocalIPAddress", args.LocalIPAddress);
        if (args.LocalPort is not null)
            parameters.Add("LocalPort", args.LocalPort);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Protocol is not null)
            parameters.Add("Protocol", args.Protocol);
        if (args.RemoteIPAddress is not null)
            parameters.Add("RemoteIPAddress", args.RemoteIPAddress);
        if (args.RemotePort is not null)
            parameters.Add("RemotePort", args.RemotePort);
        if (args.Stateful is not null)
            parameters.Add("Stateful", args.Stateful);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.Weight is not null)
            parameters.Add("Weight", args.Weight);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterExtendedAclSetting>(
            "Add-VMNetworkAdapterExtendedAcl",
            parameters
        );
        return result;
    }

    public class Add_VMNetworkAdapterRoutingDomainMappingArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet adds the routing domain and virtual subnet to a virtual network adapter on the Hyper-V hosts that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies an array of IDs of virtual subnets.
        The cmdlet adds the virtual subnets that you specify to the virtual network adapter.
        You can isolate a virtual machine adapter by using virtual local area network (VLAN), Hyper-V Network Virtualization, or a third party virtualization solution.
        For more information about isolation IDs, see the **Set-VMNetworkAdapterIsolation** cmdlet.
         */
        public required Int32[]? IsolationID { get; set; }

        /**
         * Specifies an array of names of virtual subnets.
        The cmdlet adds the virtual subnets that you specify to the virtual network adapter.
        The subnet uses VLAN or Hyper-V Network Virtualization.
         */
        public string[]? IsolationName { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the ID of a routing domain.
        The ID of a routing domain is a system-assigned GUID.
        The cmdlet adds the routing domain that you specify to the virtual network adapter.
         */
        public required Guid? RoutingDomainID { get; set; }

        /**
         * Specifies the name of a routing domain.
        The cmdlet adds the routing domain that you specify to the virtual network adapter.
         */
        public required string? RoutingDomainName { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        The cmdlet adds the routing domain to the network interfaces that belong to the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of friendly names of virtual machines.
        The cmdlet adds the routing domain to the network interfaces that belong to the virtual machines that you specify.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies an array of virtual network adapter as **VMNetworkAdapterBase** objects.
        The cmdlet adds the routing domain on the adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
        The cmdlet adds the routing domain on adapter that you specify.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmnetworkadapterroutingdomainmapping?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMNetworkAdapterRoutingDomainMapping.md">Get-VMNetworkAdapterRoutingDomainMapping</see>
     *
     * <see href="./Set-VMNetworkAdapterRoutingDomainMapping.md">Set-VMNetworkAdapterRoutingDomainMapping</see>
     *
     * <see href="./Remove-VMNetworkAdapterRoutingDomainMapping.md">Remove-VMNetworkAdapterRoutingDomainMapping</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     * Adds a routing domain and virtual subnets to a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Add-VMNetworkAdapterRoutingDomainMapping** cmdlet adds a routing domain and virtual subnets to a virtual network adapter. The cmdlet adds the information about the routing domain and virtual subnets to connected multitenant virtual machines.
     * </remarks>
     */
    public VMNetworkAdapterRoutingDomainSetting[] Add_VMNetworkAdapterRoutingDomainMapping(
        Add_VMNetworkAdapterRoutingDomainMappingArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.IsolationID is not null)
            parameters.Add("IsolationID", args.IsolationID);
        if (args.IsolationName is not null)
            parameters.Add("IsolationName", args.IsolationName);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RoutingDomainID is not null)
            parameters.Add("RoutingDomainID", args.RoutingDomainID);
        if (args.RoutingDomainName is not null)
            parameters.Add("RoutingDomainName", args.RoutingDomainName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterRoutingDomainSetting>(
            "Add-VMNetworkAdapterRoutingDomainMapping",
            parameters
        );
        return result;
    }

    public class Add_VMPmemControllerArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public object? Confirm { get; set; }
        public PSCredential[]? Credential { get; set; }
        public object? Passthru { get; set; }
        public required VirtualMachine[]? VM { get; set; }
        public required string[]? VMName { get; set; }
        public object? WhatIf { get; set; }
    }

    /** <summary>
     *
     * Add-VMPmemController [-VMName] <string[]> [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * Add-VMPmemController [-VM] <VirtualMachine[]> [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VMPmemController[] Add_VMPmemController(Add_VMPmemControllerArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMPmemController>("Add-VMPmemController", parameters);
        return result;
    }

    public class Add_VMRemoteFx3dVideoAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the RemoteFX video adapter is to be added.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a VMRemoteFxVideoAdapter object is to be passed through to the pipeline representing the RemoteFX video adapter to be added.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine on which the RemoteFX video adapter is to be added.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of virtual machine on which the RemoteFX video adapter is to be added.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmremotefx3dvideoadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a RemoteFX video adapter in a virtual machine.
     * </summary>
     * <remarks>
     * The **Add-VMRemoteFx3dVideoAdapter** cmdlet adds a RemoteFX video adapter in a virtual machine.
     * </remarks>
     */
    public void Add_VMRemoteFx3dVideoAdapter(Add_VMRemoteFx3dVideoAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMRemoteFx3dVideoAdapter", parameters);
    }

    public class Add_VMScsiControllerArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a SCSI controller is to be added.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **VMScsiController** object is to be passed through to the pipeline representing the SCSI controller to be added.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine in which the SCSI controller is to be added.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine in which the SCSI controller is to be added.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmscsicontroller?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a SCSI controller in a virtual machine.
     * </summary>
     * <remarks>
     * The **Add-VMScsiController** cmdlet adds a SCSI controller in a virtual machine.
     * </remarks>
     */
    public void Add_VMScsiController(Add_VMScsiControllerArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMScsiController", parameters);
    }

    public class Add_VMStoragePathArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the path to the storage resource pool is to be added.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns a **String**.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to be added to the storage resource pool.
         */
        public required string[]? Path { get; set; }

        /**
         * Specifies the name of the resource pool to which the path is to be added.
         */
        public required string[]? ResourcePoolName { get; set; }

        /**
         * Specifies the type of the resource pool for which storage paths are to be added.
        Allowed values are **VFD**, **VHD**, and **ISO**.
         */
        public required VMResourcePoolType? ResourcePoolType { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmstoragepath?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a path to a storage resource pool.
     * </summary>
     * <remarks>
     * The **Add-VMStoragePath** cmdlet adds a path to a storage resource pool.
     * </remarks>
     */
    public void Add_VMStoragePath(Add_VMStoragePathArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMStoragePath", parameters);
    }

    public class Add_VMSwitchArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet adds the virtual switch on the Hyper-V hosts that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual switch to be added.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the name of the resource pool to which the virtual switch is to be added.
         */
        public required string[]? ResourcePoolName { get; set; }

        /**
         * Specifies the virtual switch to be added to the Ethernet resource pool.
         */
        public required VMSwitch[]? VMSwitch { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmswitch?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a virtual switch to an Ethernet resource pool.
     * </summary>
     * <remarks>
     * The **Add-VMSwitch** cmdlet adds a virtual switch to an Ethernet resource pool.
     * </remarks>
     */
    public void Add_VMSwitch(Add_VMSwitchArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMSwitch", parameters);
    }

    public class Add_VMSwitchExtensionPortFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a feature is to be added to a virtual network adapter.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual switch port connected to the external network adapter.
         */
        public required SwitchParameter? ExternalPort { get; set; }

        /**
         * Specifies that the feature is to be added in the management (i.e.
        the parent, or host) operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the feature to be added.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual switch.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies the virtual machine in which the feature is to be added.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine in which the feature is to be added.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine network adapter for which the feature is to be added.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual machine network adapter for which the feature is to be added.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies the feature to be added to the virtual switch.
        You can get such a feature object from Get-VMSystemSwitchExtensionPortFeature to add a new configuration to a virtual network adapter, or from the **Get-VMSwitchExtensionPortFeature** cmdlet to update an existing configuration.
         */
        public required VMSwitchExtensionPortFeature[]? VMSwitchExtensionFeature { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmswitchextensionportfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a feature to a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Add-VMSwitchExtensionPortFeature** cmdlet adds a feature supported by a virtual switch extension to a virtual machine network adapter. This cmdlet also configures built-in virtual switch features.
     * </remarks>
     */
    public void Add_VMSwitchExtensionPortFeature(Add_VMSwitchExtensionPortFeatureArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ExternalPort is not null)
            parameters.Add("ExternalPort", args.ExternalPort);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.VMSwitchExtensionFeature is not null)
            parameters.Add("VMSwitchExtensionFeature", args.VMSwitchExtensionFeature);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMSwitchExtensionPortFeature", parameters);
    }

    public class Add_VMSwitchExtensionSwitchFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a feature is to be added to a virtual switch.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the feature to be added.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual switch to which the feature is to be added.
         */
        public required string[]? SwitchName { get; set; }

        /**
         * Specifies the virtual switch to which the feature is to be added.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Specifies the feature to be added to the virtual switch.
         */
        public required VMSwitchExtensionSwitchFeature[]? VMSwitchExtensionFeature { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmswitchextensionswitchfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Adds a feature to a virtual switch.
     * </summary>
     * <remarks>
     * The **Add-VMSwitchExtensionSwitchFeature** cmdlet adds a feature supported by a virtual switch extension to a virtual switch.
     * </remarks>
     */
    public void Add_VMSwitchExtensionSwitchFeature(Add_VMSwitchExtensionSwitchFeatureArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.VMSwitchExtensionFeature is not null)
            parameters.Add("VMSwitchExtensionFeature", args.VMSwitchExtensionFeature);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Add-VMSwitchExtensionSwitchFeature", parameters);
    }

    public class Add_VMSwitchTeamMemberArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that runs this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies an array of interface descriptions of the virtual network adapters that this cmdlet adds to the switch team.
         */
        public string[]? NetAdapterInterfaceDescription { get; set; }

        /**
         * Specifies an array of names of virtual network adapters that this cmdlet adds to the switch team.
         */
        public string[]? NetAdapterName { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VMSwitch** object that it modifies.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual switches that this cmdlet configures.
        To obtain a **VMSwitch** object, use the **Get-VMSwitch** cmdlet.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Specifies an array of names of virtual switches that this cmdlet configures.
         */
        public required string[]? VMSwitchName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/add-vmswitchteammember?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Remove-VMSwitchTeamMember.md">Remove-VMSwitchTeamMember</see>
     *
     * <see href="./Get-VMSwitch.md">Get-VMSwitch</see>
     * Adds members to a virtual switch team.
     * </summary>
     * <remarks>
     * The **Add-VMSwitchTeamMember** cmdlet adds adapters as members to a virtual switch team.
     * </remarks>
     * <returns>This cmdlet returns a **VMSwitch** object, if you specify the **Passthru** parameter.</returns>
     */
    public VMSwitch[] Add_VMSwitchTeamMember(Add_VMSwitchTeamMemberArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.NetAdapterInterfaceDescription is not null)
            parameters.Add("NetAdapterInterfaceDescription", args.NetAdapterInterfaceDescription);
        if (args.NetAdapterName is not null)
            parameters.Add("NetAdapterName", args.NetAdapterName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.VMSwitchName is not null)
            parameters.Add("VMSwitchName", args.VMSwitchName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitch>("Add-VMSwitchTeamMember", parameters);
        return result;
    }

    public class Checkpoint_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more virtual machine hosts on which the virtual machine checkpoint is to be created.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual machine of which a checkpoint is to be taken.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual machine of which a checkpoint is to be taken.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the checkpoint to be taken.
        If not provided, a combination of the virtual machine's name and a current timestamp is used.
         */
        public string? SnapshotName { get; set; }

        /**
         * Specifies the virtual machine of which a checkpoint is to be taken.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/checkpoint-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Creates a checkpoint of a virtual machine.
     * </summary>
     * <remarks>
     * The **Checkpoint-VM** cmdlet creates a checkpoint of a virtual machine.
    
    Note: In Windows Server 2012 R2, virtual machine snapshots were renamed to virtual machine checkpoints. For clarity, this document will refer to virtual machine snapshots as checkpoints.
     * </remarks>
     */
    public void Checkpoint_VM(Checkpoint_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SnapshotName is not null)
            parameters.Add("SnapshotName", args.SnapshotName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Checkpoint-VM", parameters);
    }

    public class Compare_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies a compatibility report which resolves any incompatibilities between the virtual machine and the virtual machine host.
         */
        public required VMCompatibilityReport? CompatibilityReport { get; set; }

        /**
         * Specifies one or more Hyper-v hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies that the comparison should be made for a copy import operation.
         */
        public required SwitchParameter? Copy { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the **CIMSession** on the Hyper-V host to which this cmdlet compares the virtual machine for compatibility.
         */
        public required CimSession? DestinationCimSession { get; set; }

        /**
         * Specifies a user account that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential? DestinationCredential { get; set; }

        /**
         * Specifies the Hyper-V host to which the virtual machine is to be compared for compatibility.
         */
        public required string? DestinationHost { get; set; }

        /**
         * Specifies a destination storage path to which all virtual machine storage is to be moved.
         */
        public string? DestinationStoragePath { get; set; }

        /**
         * Specifies that the virtual machine should be copied and given a new unique identifier.
         */
        public SwitchParameter? GenerateNewId { get; set; }

        /**
         * Specifies that the compatibility comparison should include both the virtual machine and its storage.
         */
        public SwitchParameter? IncludeStorage { get; set; }

        /**
         * Specifies the name of the virtual machine to be compared.
         */
        public required string? Name { get; set; }

        /**
         * Specifies the path to the configuration file of the virtual machine to be compared.
         */
        public required string? Path { get; set; }

        /**
         * Specifies that the comparison should be made for an in-place import operation.
         */
        public SwitchParameter? Register { get; set; }

        /**
         * Specifies the friendly name of the resource pool.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Indicates that this cmdlet retains parent virtual hard disks on the source computer.
         */
        public SwitchParameter? RetainVhdCopiesOnSource { get; set; }

        /**
         * Specifies the new path to use for a smart paging file, if one is needed.
         */
        public string? SmartPagingFilePath { get; set; }

        /**
         * Specifies the path for any snapshot files associated with the virtual machine.
         */
        public string? SnapshotFilePath { get; set; }

        /**
         * Specifies the folder to which the virtual machine's VHD is to be copied.
         */
        public string? VhdDestinationPath { get; set; }

        /**
         * Specifies an array of hash tables that specifies a location for each individual virtual hard disk that needs to be compared.
        Each hash table has two entries.
        The first entry specifies the current location of the virtual hard disk to move, and has a key of **SourceFilePath**.
        The second entry specifies the new location for the virtual hard disk, and has a key of **DestinationFilePath**.
        The virtual hard disk names must be identical in both entries.
         */
        public Hashtable[]? Vhds { get; set; }

        /**
         * Specifies the folder from which the virtual machine's VHD files are to be copied.
         */
        public string? VhdSourcePath { get; set; }

        /**
         * Specifies the path where the resulting virtual machine configuration files are to be stored.
         */
        public required string? VirtualMachinePath { get; set; }

        /**
         * Specifies a virtual machine.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/compare-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Compares a virtual machine and a virtual machine host for compatibility, returning a compatibility report.
     * </summary>
     * <remarks>
     * The **Compare-VM** cmdlet compares a virtual machine and a virtual machine host for compatibility, returning a compatibility report. This is useful when trying to import or migrate a virtual machine that is incompatible with the target server that runs Hyper-V.
     * </remarks>
     */
    public VMCompatibilityReport[] Compare_VM(Compare_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.CompatibilityReport is not null)
            parameters.Add("CompatibilityReport", args.CompatibilityReport);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Copy is not null)
            parameters.Add("Copy", args.Copy);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DestinationCimSession is not null)
            parameters.Add("DestinationCimSession", args.DestinationCimSession);
        if (args.DestinationCredential is not null)
            parameters.Add("DestinationCredential", args.DestinationCredential);
        if (args.DestinationHost is not null)
            parameters.Add("DestinationHost", args.DestinationHost);
        if (args.DestinationStoragePath is not null)
            parameters.Add("DestinationStoragePath", args.DestinationStoragePath);
        if (args.GenerateNewId is not null)
            parameters.Add("GenerateNewId", args.GenerateNewId);
        if (args.IncludeStorage is not null)
            parameters.Add("IncludeStorage", args.IncludeStorage);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.Register is not null)
            parameters.Add("Register", args.Register);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.RetainVhdCopiesOnSource is not null)
            parameters.Add("RetainVhdCopiesOnSource", args.RetainVhdCopiesOnSource);
        if (args.SmartPagingFilePath is not null)
            parameters.Add("SmartPagingFilePath", args.SmartPagingFilePath);
        if (args.SnapshotFilePath is not null)
            parameters.Add("SnapshotFilePath", args.SnapshotFilePath);
        if (args.VhdDestinationPath is not null)
            parameters.Add("VhdDestinationPath", args.VhdDestinationPath);
        if (args.Vhds is not null)
            parameters.Add("Vhds", args.Vhds);
        if (args.VhdSourcePath is not null)
            parameters.Add("VhdSourcePath", args.VhdSourcePath);
        if (args.VirtualMachinePath is not null)
            parameters.Add("VirtualMachinePath", args.VirtualMachinePath);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMCompatibilityReport>("Compare-VM", parameters);
        return result;
    }

    public class Complete_VMFailoverArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the failover process is to be completed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VirtualMachine** on which it operates.
        By default, this cmdlet does not return a value.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine whose failover process is to be completed.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose failover process is to be completed.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/complete-vmfailover?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Completes a virtual machine's failover process on the Replica server.
     * Removes all recovery points on a failed over virtual machine.
     * </summary>
     * <remarks>
     * The **Complete-VMFailover** cmdlet completes a virtual machine's failover process on the Replica server. The recovery point, on which the virtual machine is failed over, is committed and all other recovery points are removed. Failover cannot be canceled after the recovery points are removed.
     * </remarks>
     */
    public void Complete_VMFailover(Complete_VMFailoverArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Complete-VMFailover", parameters);
    }

    public class Connect_VMNetworkAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more virtual machine hosts on which the virtual network adapter is to be connected.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual network adapter to be connected.
         */
        public string[]? Name { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VMNetworkAdapter** object is to be passed through to the pipeline representing the virtual network adapter to be connected.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual switch to which the virtual network adapter is to be connected.
         */
        public required string? SwitchName { get; set; }

        /**
         * Specifies that the network adapter is to be connected to any virtual switch in the resource pool, rather than to a specific virtual switch.
         */
        public required SwitchParameter? UseAutomaticConnection { get; set; }

        /**
         * Specifies the name of the virtual machine in which the network adapter is to be connected.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual network adapter to be connected.
         */
        public required VMNetworkAdapter[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the virtual switch to which the virtual network adapter is to be connected.
         */
        public required VMSwitch? VMSwitch { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/connect-vmnetworkadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Connects a virtual network adapter to a virtual switch.
     * </summary>
     * <remarks>
     * The **Connect-VMNetworkAdapter** cmdlet connects a virtual network adapter to a virtual switch.
     * </remarks>
     */
    public void Connect_VMNetworkAdapter(Connect_VMNetworkAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.UseAutomaticConnection is not null)
            parameters.Add("UseAutomaticConnection", args.UseAutomaticConnection);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Connect-VMNetworkAdapter", parameters);
    }

    public class Connect_VMSanArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts where the host bus adapter is to be associated with the virtual storage area network (SAN).
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the host bus adapter to be associated with the virtual storage area network (SAN).
         */
        public required CimInstance[]? HostBusAdapter { get; set; }

        /**
         * Specifies the name of the virtual storage area network (SAN) with which the host bus adapter is to be associated.
         */
        public required string? Name { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.Powershell.VMSan** object is to be passed through to the pipeline representing the virtual storage area network (SAN) to be associated with the host bus adapter.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }

        /**
         * Specifies the world wide node name of the host bus adapter to be associated with the virtual storage area network (SAN).
         */
        public required string[]? WorldWideNodeName { get; set; }

        /**
         * The port world wide name of the host bus adapter to be associated with the virtual storage area network (SAN).
         */
        public required string[]? WorldWidePortName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/connect-vmsan?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Associates a host bus adapter with a virtual storage area network (SAN).
     * </summary>
     * <remarks>
     * The **Connect-VMSan** cmdlet associates a host bus adapter with a virtual storage area network (SAN).
     * </remarks>
     */
    public void Connect_VMSan(Connect_VMSanArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.HostBusAdapter is not null)
            parameters.Add("HostBusAdapter", args.HostBusAdapter);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        if (args.WorldWideNodeName is not null)
            parameters.Add("WorldWideNodeName", args.WorldWideNodeName);
        if (args.WorldWidePortName is not null)
            parameters.Add("WorldWidePortName", args.WorldWidePortName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Connect-VMSan", parameters);
    }

    public class Convert_VHDArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Specifies the block size, in bytes, of the virtual hard disk after conversion.
         */
        public UInt32? BlockSizeBytes { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual hard disk is to be converted.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the source virtual hard disk is to be deleted after the conversion.
         */
        public SwitchParameter? DeleteSource { get; set; }

        /**
         * Specifies the path to the converted virtual hard disk file.
         */
        public required string? DestinationPath { get; set; }

        /**
         * Specifies the parent path for the destination-differencing virtual hard disk file.
         */
        public string? ParentPath { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the converted virtual hard disk.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to the virtual hard disk file to be converted.
        If a file name or relative path is specified, the path of the converted hard disk path is calculated relative to the current working directory
         */
        public required string? Path { get; set; }

        /**
         * Specifies the type of the converted virtual hard disk.
        Allowed values are **Fixed**, **Dynamic**, and **Differencing**.
        The default is determined by the type of source virtual hard disk.
         */
        public VhdType? VHDType { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/convert-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Converts the format, version type, and block size of a virtual hard disk file.
     * </summary>
     * <remarks>
     * The **Convert-VHD** cmdlet converts a virtual hard disk file by copying the data from a source virtual hard disk file to a new virtual hard disk file of a specified format and version type. The format is determined by the file name extension of the specified files, either .vhdx or .vhd. Conversion is an offline operation; the virtual hard disk must not be attached when the operation is started.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Convert_VHD(Convert_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.BlockSizeBytes is not null)
            parameters.Add("BlockSizeBytes", args.BlockSizeBytes);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DeleteSource is not null)
            parameters.Add("DeleteSource", args.DeleteSource);
        if (args.DestinationPath is not null)
            parameters.Add("DestinationPath", args.DestinationPath);
        if (args.ParentPath is not null)
            parameters.Add("ParentPath", args.ParentPath);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.VHDType is not null)
            parameters.Add("VHDType", args.VHDType);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Convert-VHD",
            parameters
        );
        return result;
    }

    public class Copy_VMFileArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet copies the file to the hosts you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Indicates that when the cmdlet copies a file, it creates folders if the folder does not already exist.
         */
        public SwitchParameter? CreateFullPath { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies a path.
        The cmdlet copies the file to the destination path.
         */
        public required string? DestinationPath { get; set; }

        /**
         * Specifies the type of a file source.
         */
        public required CopyFileSourceType? FileSource { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies an array of virtual machine objects by name.
        The cmdlet copies files to the virtual machines you specify.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies a path.
        The cmdlet copies the file from the source path.
         */
        public required string? SourcePath { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        The cmdlet copies files to the virtual machines you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/copy-vmfile?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Copies a file to a virtual machine.
     * </summary>
     * <remarks>
     * The **Copy-VMFile** cmdlet copies a file to a virtual machine.
     * </remarks>
     */
    public void Copy_VMFile(Copy_VMFileArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.CreateFullPath is not null)
            parameters.Add("CreateFullPath", args.CreateFullPath);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DestinationPath is not null)
            parameters.Add("DestinationPath", args.DestinationPath);
        if (args.FileSource is not null)
            parameters.Add("FileSource", args.FileSource);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.SourcePath is not null)
            parameters.Add("SourcePath", args.SourcePath);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Copy-VMFile", parameters);
    }

    public class Debug_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet debugs the virtual machines on the hosts you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Indicates that the cmdlet sends a nonmaskable interrupt (NMI) to the virtual machine.
        An interrupt handler must process a nonmaskable interrupt.
         */
        public SwitchParameter? InjectNonMaskableInterrupt { get; set; }

        /**
         * Specifies an array of names of virtual machines to be debugged.
         */
        public required string[]? Name { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machine objects that are to be debugged.
        To obtain virtual machine objects, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/debug-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="/windows/win32/debug/configuring-automatic-debugging">Configuring Automatic Debugging</see>
     * Debugs a virtual machine.
     * </summary>
     * <remarks>
     * The **Debug-VM** cmdlet debugs a virtual machine.
     * </remarks>
     */
    public VirtualMachine[] Debug_VM(Debug_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.InjectNonMaskableInterrupt is not null)
            parameters.Add("InjectNonMaskableInterrupt", args.InjectNonMaskableInterrupt);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Debug-VM", parameters);
        return result;
    }

    public class Disable_VMConsoleSupportArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.VirtualMachine** object that it modifies.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machines on which this cmdlet disables support for keyboard, video, and mouse.
        To obtain a **VirtualMachine** object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines on which this cmdlet disables support for keyboard, video, and mouse.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disable-vmconsolesupport?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Enable-VMConsoleSupport.md">Enable-VMConsoleSupport</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     * Disables keyboard, video, and mouse for a generation 2 virtual machine.
     * </summary>
     * <remarks>
     * The **Disable-VMConsoleSupport** cmdlet disables keyboard, video, and mouse for virtual machines.
     * </remarks>
     * <returns>This cmdlet returns a **VirtualMachine** object, if you specify the **Passthru** parameter.</returns>
     */
    public VirtualMachine[] Disable_VMConsoleSupport(Disable_VMConsoleSupportArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>(
            "Disable-VMConsoleSupport",
            parameters
        );
        return result;
    }

    public class Disable_VMEventingArguments
    {
        /**
         *
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which virtual machine eventing is to be disabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         *
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the confirmation prompt is to be suppressed.
        (This is useful in scripting the cmdlet.)
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disable-vmeventing?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Disables virtual machine eventing.
     * </summary>
     * <remarks>
     * The **Disable-VMEventing** cmdlet disables virtual machine eventing on a Hyper-V host or hosts. Virtual machine eventing keeps Hyper-V PowerShell objects updated without polling the virtual machine host. Virtual machine eventing is enabled by default.
     * </remarks>
     */
    public void Disable_VMEventing(Disable_VMEventingArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Disable-VMEventing", parameters);
    }

    public class Disable_VMIntegrationServiceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the integration service on a virtual machine is to be disabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the integration service to be disabled.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.IntegrationService** object is to be passed through to the pipeline representing the integration service to be disabled.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine on which the integration service is to be disabled.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the integration service to be disabled.
         */
        public required VMIntegrationComponent[]? VMIntegrationService { get; set; }

        /**
         * Specifies the name of the virtual machine on which the integration service is to be disabled.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disable-vmintegrationservice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Disables an integration service on a virtual machine.
     * </summary>
     * <remarks>
     * The **Disable-VMIntegrationService** cmdlet disables an integration service on a virtual machine.
     * </remarks>
     */
    public void Disable_VMIntegrationService(Disable_VMIntegrationServiceArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMIntegrationService is not null)
            parameters.Add("VMIntegrationService", args.VMIntegrationService);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Disable-VMIntegrationService", parameters);
    }

    public class Disable_VMMigrationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns a **Microsoft.HyperV.PowerShell.Host** object.
        By default, this cmdlet does not return a value.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disable-vmmigration?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Disables migration on one or more virtual machine hosts.
     * </summary>
     * <remarks>
     * The **Disable-VMMigration** cmdlet disables migration on one or more virtual machine hosts.
     * </remarks>
     */
    public void Disable_VMMigration(Disable_VMMigrationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Disable-VMMigration", parameters);
    }

    public class Disable_VMRemoteFXPhysicalVideoAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the RemoteFX physical video adapters are to be disabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies one or more RemoteFX physical video adapters to disable.
         */
        public required VMRemoteFXPhysicalVideoAdapter[]? GPU { get; set; }

        /**
         * Specifies an array of names of adapters.
        The cmdlet disables the RemoteFX physical video adapters that you specify.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that **Microsoft.HyperV.PowerShell.VMRemoteFXPhysicalVideoAdapter** objects are to be passed to the pipeline representing the RemoteFX physical video adapters to be disabled.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disable-vmremotefxphysicalvideoadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Disables one or more RemoteFX physical video adapters from use with RemoteFX-enabled virtual machines.
     * </summary>
     * <remarks>
     * The **Disable-VMRemoteFXPhysicalVideoAdapter** cmdlet disables one or more RemoteFX physical video adapter from use with RemoteFX-enabled virtual machines.
     * </remarks>
     */
    public void Disable_VMRemoteFXPhysicalVideoAdapter(
        Disable_VMRemoteFXPhysicalVideoAdapterArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.GPU is not null)
            parameters.Add("GPU", args.GPU);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Disable-VMRemoteFXPhysicalVideoAdapter", parameters);
    }

    public class Disable_VMResourceMeteringArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which resource utilization data collection is to be disabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the friendly name of the resource pool on which resource utilization data collection is to be disabled.
         */
        public required string? ResourcePoolName { get; set; }

        /**
         * Specifies the resource type of the resource pool on which resource utilization data collection is to be disabled.
         */
        public VMResourcePoolType? ResourcePoolType { get; set; }

        /**
         * Specifies the virtual machine on which resource utilization data collection is to be disabled.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the friendly name of the virtual machine on which resource utilization data collection is to be disabled.
         */
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disable-vmresourcemetering?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Measure-VM.md">Measure-VM</see>
     *
     * <see href="./Measure-VMResourcePool.md">Measure-VMResourcePool</see>
     *
     * <see href="./Enable-VMResourceMetering.md">Enable-VMResourceMetering</see>
     * Disables collection of resource utilization data for a virtual machine or resource pool.
     * </summary>
     * <remarks>
     * The **Disable-VMResourceMetering** cmdlet disables collection of resource utilization data for a virtual machine or resource pool.
    
    Calling this cmdlet stops collection of data and deletes data collected up to the point of the call.
    
    After the call, Measure-VM and Measure-VMResourcePool are not usable.
     * </remarks>
     */
    public void Disable_VMResourceMetering(Disable_VMResourceMeteringArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Disable-VMResourceMetering", parameters);
    }

    public class Disable_VMSwitchExtensionArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the extension is to be disabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the extension to be disabled.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the virtual switch on which the extension is to be disabled.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Specifies the extension to be disabled.
         */
        public required VMSwitchExtension[]? VMSwitchExtension { get; set; }

        /**
         * Specifies the name of the switch on which the extension is to be disabled.
         */
        public required string[]? VMSwitchName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disable-vmswitchextension?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Disables one or more extensions on one or more virtual switches.
     * </summary>
     * <remarks>
     * The **Disable-VMSwitchExtension** cmdlet disables one or more extensions on one or more virtual switches. You can run Get-VMSystemSwitchExtension to enumerate the virtual switch extensions installed on the system.
     * </remarks>
     */
    public VMSwitchExtension[] Disable_VMSwitchExtension(Disable_VMSwitchExtensionArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.VMSwitchExtension is not null)
            parameters.Add("VMSwitchExtension", args.VMSwitchExtension);
        if (args.VMSwitchName is not null)
            parameters.Add("VMSwitchName", args.VMSwitchName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitchExtension>(
            "Disable-VMSwitchExtension",
            parameters
        );
        return result;
    }

    public class Disable_VMTPMArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts to run the cmdlet.
        NetBIOS names, IP addresses, and fully-qualified domain names are allowable.
        The default is the local computer.
        Use "localhost" or a dot (".") to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies a user account that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine for which you want to disable TPM.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine for which you want to disable TPM.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disable-vmtpm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Enable-VMTPM.md">Enable-VMTPM</see>
     * Disables TPM functionality on a virtual machine.
     * </summary>
     * <remarks>
     * The **Disable-VMTPM** cmdlet disables Trusted Platform Module (TPM) functionality on a virtual machine.
     * </remarks>
     */
    public VirtualMachine[] Disable_VMTPM(Disable_VMTPMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Disable-VMTPM", parameters);
        return result;
    }

    public class Disconnect_VMNetworkAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual network adapter is to be disconnected.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual network adapter to be disconnected.
         */
        public string[]? Name { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VMNetworkAdapter** object is to be passed through to the pipeline representing the virtual network adapter to be disconnected.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual machine in which the virtual network adapter is to be disconnected.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual network adapter to be disconnected.
         */
        public required VMNetworkAdapter[]? VMNetworkAdapter { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disconnect-vmnetworkadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Disconnects a virtual network adapter from a virtual switch or Ethernet resource pool.
     * </summary>
     * <remarks>
     * The **Disconnect-VMNetworkAdapter** cmdlet disconnects a virtual network adapter from a virtual switch or Ethernet resource pool.
     * </remarks>
     */
    public void Disconnect_VMNetworkAdapter(Disconnect_VMNetworkAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Disconnect-VMNetworkAdapter", parameters);
    }

    public class Disconnect_VMSanArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a host bus adapter is to be removed from a virtual storage area network (SAN).
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the host bus adapter to be removed from the virtual storage area network (SAN).
         */
        public required CimInstance[]? HostBusAdapter { get; set; }

        /**
         * Specifies the name of the virtual storage area network (SAN) from which the host bus adapter is to be removed.
         */
        public required string? Name { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual storage area network (SAN) from which the host bus adapter is to be removed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }

        /**
         * The world wide node name of the host bus adapter to be removed from the virtual storage area network (SAN).
         */
        public required string[]? WorldWideNodeName { get; set; }

        /**
         * The world wide port name of the host bus adapter to be removed from the virtual storage area network (SAN).
         */
        public required string[]? WorldWidePortName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/disconnect-vmsan?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes a host bus adapter from a virtual storage area network (SAN).
     * </summary>
     * <remarks>
     * The **Disconnect-VMSan** cmdlet removes a host bus adapter from a virtual storage area network (SAN).
     * </remarks>
     */
    public void Disconnect_VMSan(Disconnect_VMSanArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.HostBusAdapter is not null)
            parameters.Add("HostBusAdapter", args.HostBusAdapter);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        if (args.WorldWideNodeName is not null)
            parameters.Add("WorldWideNodeName", args.WorldWideNodeName);
        if (args.WorldWidePortName is not null)
            parameters.Add("WorldWidePortName", args.WorldWidePortName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Disconnect-VMSan", parameters);
    }

    public class Dismount_VHDArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual hard disk is to be dismounted.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the disk number of the virtual hard disk to be dismounted.
         */
        public required UInt32? DiskNumber { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual hard disk to be dismounted.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies one or more virtual hard disk files for which the corresponding virtual hard disks are to be dismounted.
         */
        public required string[]? Path { get; set; }

        /**
         * Specifies the unique ID of a VHD set snapshot.
         */
        public Guid? SnapshotId { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/dismount-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Dismounts a virtual hard disk.
     * </summary>
     * <remarks>
     * The **Dismount-VHD** cmdlet dismounts a virtual hard disk.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Dismount_VHD(Dismount_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DiskNumber is not null)
            parameters.Add("DiskNumber", args.DiskNumber);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.SnapshotId is not null)
            parameters.Add("SnapshotId", args.SnapshotId);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Dismount-VHD",
            parameters
        );
        return result;
    }

    public class Dismount_VMHostAssignableDeviceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the assignable devices are to be dismounted. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
        
         * Using the **Force** parameter also overrides some security checks in the platform. To learn more,
        see [Dismount the device from the host partition
        ](/windows-server/virtualization/hyper-v/deploy/deploying-graphics-devices-using-dda#dismount-the-device-from-the-host-partition).
        
         * If no partitioning driver is provided, during dismount, you must use `-Force` to bypass the
        security warning. For more information about the security implications, see [Plan for deploying devices by using Discrete Device Assignment](/windows-server/virtualization/hyper-v/plan/plan-for-deploying-devices-using-discrete-device-assignment).
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Represents the Device Instance path in the host machine.
         */
        public string? InstancePath { get; set; }

        /**
         * Specifies the location path to the assignable device.
         */
        public string? LocationPath { get; set; }

        /**
         * Returns an object for each process that the cmdlet started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/dismount-vmhostassignabledevice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="add-vmhostassignabledevice.md">Add-VMHostAssignableDevice</see>
     *
     * <see href="get-vmhostassignabledevice.md">Get-VMHostAssignableDevice</see>
     *
     * <see href="mount-vmhostassignabledevice.md">Mount-VMHostAssignableDevice</see>
     *
     * <see href="remove-vmhostassignabledevice.md">Remove-VMHostAssignableDevice</see>
     * Dismounts a device from a virtual machine (VM) host.
     * </summary>
     * <remarks>
     * The `Dismount-VMHostAssignableDevice` cmdlet is used to dismount an assignable device from the virtual machine host. Use this cmdlet when you need to reassign a device or resolve conflicts between devices and virtual machines.
     * </remarks>
     */
    public VMHostAssignableDevice[] Dismount_VMHostAssignableDevice(
        Dismount_VMHostAssignableDeviceArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.InstancePath is not null)
            parameters.Add("InstancePath", args.InstancePath);
        if (args.LocationPath is not null)
            parameters.Add("LocationPath", args.LocationPath);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHostAssignableDevice>(
            "Dismount-VMHostAssignableDevice",
            parameters
        );
        return result;
    }

    public class Enable_VMConsoleSupportArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.VirtualMachine** object that it modifies.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machines on which this cmdlet enables support for keyboard, video, and mouse.
        To obtain a **VirtualMachine** object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines on which this cmdlet enables support keyboard, video, and mouse.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/enable-vmconsolesupport?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Disable-VMConsoleSupport.md">Disable-VMConsoleSupport</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     * Enables keyboard, video, and mouse for virtual machines.
     * </summary>
     * <remarks>
     * The **Enable-VMConsoleSupport** cmdlet enables keyboard, video, and mouse for virtual machines.
     * </remarks>
     * <returns>This cmdlet returns a **VirtualMachine** object, if you specify the **Passthru**.</returns>
     */
    public VirtualMachine[] Enable_VMConsoleSupport(Enable_VMConsoleSupportArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Enable-VMConsoleSupport", parameters);
        return result;
    }

    public class Enable_VMEventingArguments
    {
        /**
         *
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which virtual machine eventing is to be enabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         *
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the confirmation prompt is to be suppressed.
        (This is useful in scripting the cmdlet.)
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/enable-vmeventing?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Enables virtual machine eventing.
     * </summary>
     * <remarks>
     * The **Enable-VMEventing** cmdlet enables virtual machine eventing. Virtual machine eventing keeps Hyper-V PowerShell objects updated without polling the virtual machine host. Virtual machine eventing is enabled by default.
     * </remarks>
     */
    public void Enable_VMEventing(Enable_VMEventingArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Enable-VMEventing", parameters);
    }

    public class Enable_VMIntegrationServiceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which an integration service is to be enabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the integration service to be enabled.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.IntegrationService** object is to be passed through to the pipeline representing the integration service to be enabled.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine on which the integration service is to be enabled.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the integration service to be enabled.
         */
        public required VMIntegrationComponent[]? VMIntegrationService { get; set; }

        /**
         * Specifies the name of the virtual machine on which the integration service is to be enabled.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/enable-vmintegrationservice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Enables an integration service on a virtual machine.
     * </summary>
     * <remarks>
     * The **Enable-VMIntegrationService** cmdlet enables an integration service on a virtual machine.
     * </remarks>
     */
    public void Enable_VMIntegrationService(Enable_VMIntegrationServiceArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMIntegrationService is not null)
            parameters.Add("VMIntegrationService", args.VMIntegrationService);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Enable-VMIntegrationService", parameters);
    }

    public class Enable_VMMigrationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns a **Microsoft.HyperV.PowerShell.Host** object.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/enable-vmmigration?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Enables migration on one or more virtual machine hosts.
     * </summary>
     * <remarks>
     * The **Enable-VMMigration** cmdlet enables migration on one or more virtual machine hosts.
     * </remarks>
     */
    public void Enable_VMMigration(Enable_VMMigrationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Enable-VMMigration", parameters);
    }

    public class Enable_VMRemoteFXPhysicalVideoAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967)
        or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the RemoteFX physical video adapters are to be enabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable. The default is the
        local computer. Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the RemoteFX physical video adapters to be enabled.
         */
        public required VMRemoteFXPhysicalVideoAdapter[]? GPU { get; set; }

        /**
         * Specifies an array of names of adapters. The cmdlet enables the RemoteFX physical video adapters
        that you specify.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that one or more **Microsoft.HyperV.PowerShell.VMRemoteFXPhysicalVideoAdapter** objects
        are to be passed through to the pipeline representing the RemoteFX physical video adapters to be
        enabled.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/enable-vmremotefxphysicalvideoadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Enables one or more RemoteFX physical video adapters for use with RemoteFX-enabled virtual machines.
     * </summary>
     * <remarks>
     * The **Enable-VMRemoteFXPhysicalVideoAdapter** cmdlet enables one or more RemoteFX physical video adapters to be used with RemoteFX-enabled virtual machines.
     * </remarks>
     */
    public void Enable_VMRemoteFXPhysicalVideoAdapter(
        Enable_VMRemoteFXPhysicalVideoAdapterArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.GPU is not null)
            parameters.Add("GPU", args.GPU);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Enable-VMRemoteFXPhysicalVideoAdapter", parameters);
    }

    public class Enable_VMReplicationArguments
    {
        /**
         * When you use the AsReplica parameter to specify a virtual machine as a replica virtual machine, this parameter determines which primary servers can send replication to the replica virtual machine.
        Replication is accepted only from the server specified in the chosen authentication entry, or any other authentication entry that has the same trust group.
         */
        public string? AllowedPrimaryServer { get; set; }

        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Specifies that the virtual machine is a replica virtual machine, enabling it to be used as the source for the initial replication of the primary virtual machine.
         */
        public SwitchParameter? AsReplica { get; set; }

        /**
         * Specifies the authentication type to use for virtual machine replication, either Kerberos or Certificate.
        The specified Replica server must support the chosen authentication type.
        Run the **Get-VMReplicationServer** cmdlet to verify the authentication configured for the specified Replica server, or contact the administrator of the specified Replica server.
         */
        public required ReplicationAuthenticationType? AuthenticationType { get; set; }

        /**
         * Enables replicating virtual machines that require resynchronization to be resynchronized automatically.
        (For example, a virtual machine requires resynchronization if the primary server shuts down abruptly).
        Resynchronization requires significant storage and processing resources.
        We recommended scheduling resynchronization during off-peak hours to reduce the impact to the host and other virtual machines running on the host.
        Use the AutoResynchronizeIntervalStart and AutoResynchronizeIntervalEnd parameters to specify an off-peak time to start the automatic resynchronization.
         */
        public Boolean? AutoResynchronizeEnabled { get; set; }

        /**
         * Specifies the end of the time period in which you want resynchronization to start automatically.
         */
        public TimeSpan? AutoResynchronizeIntervalEnd { get; set; }

        /**
         * Specifies the start of the time period in which you want resynchronization to start automatically.
         */
        public TimeSpan? AutoResynchronizeIntervalStart { get; set; }

        /**
         * Specifies whether to bypass a proxy server while replicating data to the Replica server.
         */
        public Boolean? BypassProxyServer { get; set; }

        /**
         * Specifies the certificate to use for mutual authentication of the replication data.
        This parameter is required only when "Certificate" is specified as the type of authentication.
        Specify the thumbprint of a valid computer certificate from the Personal store.
        
         * The certificate must have all of the following properties to be valid:
        - It must not be expired.
        - It must include both client and server authentication extensions for extended key usage (EKU), and an associated private key.
        - It must terminate at a valid root certificate.
        
         * The requirement for the subject common name (CN) differs depending on whether the virtual machine belongs to a cluster. For virtual machines that do not belong to a cluster, the subject common name (CN) must be equal to, or subject alternative name (DNS Name) should contain, the FQDN of the host. For virtual machines that belong to a cluster, the subject common name (CN) must be equal to, or subject alternative name (DNS Name) must contain, the and fully qualified domain name (FQDN) of the Hyper-V Replica Broker.
        
         * To display a list of certificates in the computer's My store and the thumbprint of each certificate, type the following:
        
         * `PS C:\\\> cd cert:\LocalMachine\My`
        
         * `PS C:\\\> dir | format-list`
        
         * For more information about certificate stores, see [http://technet.microsoft.com//library/cc757138.aspx](https://technet.microsoft.com//library/cc757138.aspx).
         */
        public string? CertificateThumbprint { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies whether to compress replication data for this virtual machine when it is sent over the network.
         */
        public Boolean? CompressionEnabled { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that have the virtual machines for which you want to enable replication.
        NetBIOS names, IP addresses, and fully qualified domain names (FQDN) are allowed.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Determines whether all virtual hard disks selected for replication are replicated to the same point in time.
        This is useful if the virtual machine runs an application that saves data across virtual hard disks (for example, one virtual hard disk dedicated for application data, and another virtual hard disk dedicated for application log files).
         */
        public Boolean? EnableWriteOrderPreservationAcrossDisks { get; set; }

        /**
         * Specifies one or more virtual hard disks to exclude from replication (for example, a virtual hard disk dedicated for the paging file).
        Be careful not to exclude virtual hard disks that are critical to the virtual machine's ability to start up, such as the virtual hard disk that stores the guest operating system.
        Excluding a critical disk could prevent the replica virtual machine from starting up properly.
         */
        public HardDiskDrive[]? ExcludedVhd { get; set; }

        /**
         * Specifies the fully qualified path names to the virtual hard disks to exclude from replication.
         */
        public string[]? ExcludedVhdPath { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies whether to store additional recovery points on the replica virtual machine.
        Storing more than the most recent recovery point of the primary virtual machine allows you to recover to an earlier point in time.
        However, storing additional recovery points requires more storage and processing resources.
        You can configure as many as 24 recovery points to be stored.
         */
        public int? RecoveryHistory { get; set; }

        /**
         * Specifies the name of the Replica server to which this virtual machine will be replicated.
         */
        public required string? ReplicaServerName { get; set; }

        /**
         * Specifies the port on the Replica server to use for replication traffic.
        Make sure you specify a port that is configured on the Replica server to support the same authentication type you specify using the AuthenticationType parameter in this cmdlet.
        Run the **Get-VMReplicationServer** cmdlet on the Replica server to check the configuration of the port, or contact the administrator of the specified Replica server.
         */
        public required int? ReplicaServerPort { get; set; }

        /**
         * Specifies whether to replicate host-only key value pairs (KVP) for this virtual machine.
         */
        public Boolean? ReplicateHostKvpItems { get; set; }

        /**
         * Specifies the frequency, in seconds, at which Hyper-V replicates changes to the Replica server.
         */
        public int? ReplicationFrequencySec { get; set; }

        /**
         * Specifies the virtual machine you want to configure for replication.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine you want to configure for replication.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the frequency, in hours, at which Volume Shadow Copy Service (VSS) performs a snapshot backup of the virtual machines.
        Specify this parameter only if application-consistent replication is enabled for the virtual machines and the value you set for the **RecoveryHistory** parameter is not zero.
        The cmdlet sets a value of zero for this parameter if application-consistent replication is disabled.
        Do not specify this parameter if you are extending replication from the Replica virtual machine.
         */
        public int? VSSSnapshotFrequencyHour { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/enable-vmreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Enables replication of a virtual machine.
     * </summary>
     * <remarks>
     * The **Enable-VMReplication** cmdlet enables replication of a virtual machine to a specified Replica server.
     * </remarks>
     */
    public void Enable_VMReplication(Enable_VMReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowedPrimaryServer is not null)
            parameters.Add("AllowedPrimaryServer", args.AllowedPrimaryServer);
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.AsReplica is not null)
            parameters.Add("AsReplica", args.AsReplica);
        if (args.AuthenticationType is not null)
            parameters.Add("AuthenticationType", args.AuthenticationType);
        if (args.AutoResynchronizeEnabled is not null)
            parameters.Add("AutoResynchronizeEnabled", args.AutoResynchronizeEnabled);
        if (args.AutoResynchronizeIntervalEnd is not null)
            parameters.Add("AutoResynchronizeIntervalEnd", args.AutoResynchronizeIntervalEnd);
        if (args.AutoResynchronizeIntervalStart is not null)
            parameters.Add("AutoResynchronizeIntervalStart", args.AutoResynchronizeIntervalStart);
        if (args.BypassProxyServer is not null)
            parameters.Add("BypassProxyServer", args.BypassProxyServer);
        if (args.CertificateThumbprint is not null)
            parameters.Add("CertificateThumbprint", args.CertificateThumbprint);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.CompressionEnabled is not null)
            parameters.Add("CompressionEnabled", args.CompressionEnabled);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.EnableWriteOrderPreservationAcrossDisks is not null)
            parameters.Add(
                "EnableWriteOrderPreservationAcrossDisks",
                args.EnableWriteOrderPreservationAcrossDisks
            );
        if (args.ExcludedVhd is not null)
            parameters.Add("ExcludedVhd", args.ExcludedVhd);
        if (args.ExcludedVhdPath is not null)
            parameters.Add("ExcludedVhdPath", args.ExcludedVhdPath);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RecoveryHistory is not null)
            parameters.Add("RecoveryHistory", args.RecoveryHistory);
        if (args.ReplicaServerName is not null)
            parameters.Add("ReplicaServerName", args.ReplicaServerName);
        if (args.ReplicaServerPort is not null)
            parameters.Add("ReplicaServerPort", args.ReplicaServerPort);
        if (args.ReplicateHostKvpItems is not null)
            parameters.Add("ReplicateHostKvpItems", args.ReplicateHostKvpItems);
        if (args.ReplicationFrequencySec is not null)
            parameters.Add("ReplicationFrequencySec", args.ReplicationFrequencySec);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VSSSnapshotFrequencyHour is not null)
            parameters.Add("VSSSnapshotFrequencyHour", args.VSSSnapshotFrequencyHour);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Enable-VMReplication", parameters);
    }

    public class Enable_VMResourceMeteringArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies the virtual machine host or hosts on which resource utilization data collection is to be enabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the friendly name of the resource pool for which you want to collect resource utilization data.
         */
        public required string? ResourcePoolName { get; set; }

        /**
         * Specifies the resource type of the resource pool for which you want to collect resource utilization data.
         */
        public VMResourcePoolType? ResourcePoolType { get; set; }

        /**
         * Specifies the virtual machine for which you want to collect resource utilization data.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the friendly name of the virtual machine for which you want to collect resource utilization data.
         */
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/enable-vmresourcemetering?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Measure-VM.md">Measure-VM</see>
     *
     * <see href="./Measure-VMResourcePool.md">Measure-VMResourcePool</see>
     *
     * <see href="./Disable-VMResourceMetering.md">Disable-VMResourceMetering</see>
     * Collects resource utilization data for a virtual machine or resource pool.
     * </summary>
     * <remarks>
     * The **Enable-VMResourceMetering** cmdlet starts collecting resource utilization data for a virtual machine or resource pool.
    
    You can use the Measure-VM or Measure-VMResourcePool cmdlet to obtain this data.
    
    If resource metering is enabled but no **NetworkAdapterAcls** are configured, Hyper-V configures them to measure total network traffic. To measure network traffic through an IP range, configure the **NetworkAdapterAcls** for the IP range before calling this cmdlet. (See Add-VMNetworkAdapterAcl for more information.)
     * </remarks>
     */
    public void Enable_VMResourceMetering(Enable_VMResourceMeteringArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Enable-VMResourceMetering", parameters);
    }

    public class Enable_VMSwitchExtensionArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which an extension is to be enabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the network extension to be enabled.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the virtual switch on which the extension is to be enabled.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Specifies the extension to be enabled.
         */
        public required VMSwitchExtension[]? VMSwitchExtension { get; set; }

        /**
         * Specifies the name of the switch on which the extension is to be enabled.
         */
        public required string[]? VMSwitchName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/enable-vmswitchextension?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Enables one or more extensions on one or more switches.
     * </summary>
     * <remarks>
     * The **Enable-VMSwitchExtension** cmdlet enables one or more extensions on one or more switches. You can use the **Get-VMSystemSwitchExtension** cmdlet to enumerate the virtual switch extensions installed on the system.
     * </remarks>
     */
    public VMSwitchExtension[] Enable_VMSwitchExtension(Enable_VMSwitchExtensionArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.VMSwitchExtension is not null)
            parameters.Add("VMSwitchExtension", args.VMSwitchExtension);
        if (args.VMSwitchName is not null)
            parameters.Add("VMSwitchName", args.VMSwitchName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitchExtension>(
            "Enable-VMSwitchExtension",
            parameters
        );
        return result;
    }

    public class Enable_VMTPMArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a New-CimSession or Get-CimSession cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts to run the cmdlet.
        NetBIOS names, IP addresses, and fully-qualified domain names are allowable.
        The default is the local computer.
        Use "localhost" or a dot (".") to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies a user account that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine for which to enable TPM.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine for which to enable TPM.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/enable-vmtpm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Disable-VMTPM.md">Disable-VMTPM</see>
     * Enables TPM functionality on a virtual machine.
     * </summary>
     * <remarks>
     * The **Enable-VMTPM** cmdlet enables Trusted Platform Module (TPM) functionality on a virtual machine.
     * </remarks>
     */
    public VirtualMachine[] Enable_VMTPM(Enable_VMTPMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Enable-VMTPM", parameters);
        return result;
    }

    public class Export_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Specifies how Hyper-V captures the running virtual machine memory state.
        The acceptable values for this parameter are:
        
         * - CaptureSavedState.
        Include memory state.
        - CaptureDataConsistentState.
        Use Production Checkpoint technology.
        - CaptureCrashConsistentState.
        Do nothing to handle virtual machine state.
         */
        public CaptureLiveState? CaptureLiveState { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine is to be exported.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual machine to be exported.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VirtualMachine** object is to be passed through to the pipeline representing the virtual machine to be exported.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to the folder into which the virtual machine is to be exported.
         */
        public required string? Path { get; set; }

        /**
         * Specifies the virtual machine to be exported.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/export-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Exports a virtual machine to disk.
     * </summary>
     * <remarks>
     * The **Export-VM** cmdlet exports a virtual machine to disk. This cmdlet creates a folder at a specified location having three subfolders: Snapshots, Virtual Hard Disks, and Virtual Machines. Each of these folders contains the associated files. The Snapshots folder contains the associated Snapshots, and the Virtual Hard Disk folder contains the specified virtual machine's virtual disks. The Virtual Machines folder contains the configuration XML of the specified virtual machine.
     * </remarks>
     */
    public void Export_VM(Export_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CaptureLiveState is not null)
            parameters.Add("CaptureLiveState", args.CaptureLiveState);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Export-VM", parameters);
    }

    public class Get_VHDArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual hard disk is to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the disk number associated with the virtual hard disk to be retrieved.
         */
        public required UInt32? DiskNumber { get; set; }

        /**
         * Specifies the path to the virtual hard disk file of the virtual hard disk to be retrieved.
        If a filename or relative path is specified, the path is calculated relative to the current working directory.
         */
        public required string[]? Path { get; set; }

        /**
         * Specifies the virtual machine identifier of the virtual machine whose virtual hard disks are to be retrieved.
         */
        public required Guid[]? VMId { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the virtual hard disk object associated with a virtual hard disk.
     * </summary>
     * <remarks>
     * The **Get-VHD** cmdlet gets the virtual hard disk object associated with a virtual hard disk.
    
    > [!Note] > When the VHD is in use (for example by a VM or mounted in the OS) and it is on shared storage, the **Get-VHD** cmdlet can only access it from the host that is using it. Any other server trying to run the **Get-VHD** cmdlet will get an error that it is in use.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Get_VHD(Get_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DiskNumber is not null)
            parameters.Add("DiskNumber", args.DiskNumber);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.VMId is not null)
            parameters.Add("VMId", args.VMId);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Get-VHD",
            parameters
        );
        return result;
    }

    public class Get_VHDSetArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet gets the paths of all files on which this VHD set file depends.
         */
        public SwitchParameter? GetAllPaths { get; set; }

        /**
         * Specifies an array of paths of VHD set files that this cmdlet gets.
        If you specify a file name or a relative path, the cmdlet determines the full path relative to the current working folder.
         */
        public required string[]? Path { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vhdset?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Optimize-VHDSet.md">Optimize-VHDSet</see>
     * Gets information about a VHD set.
     * </summary>
     * <remarks>
     * The **Get-VHDSet** cmdlet gets information about a virtual hard disk (VHD) set file. This information includes a list of all checkpoints that the set contains.
    
    Checkpoint replaces the previous term, snapshot.
     * </remarks>
     * <returns>This cmdlet returns **VHDSetInfo** objects.</returns>
     */
    public Microsoft.Vhd.PowerShell.VHDSetInfo[] Get_VHDSet(Get_VHDSetArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.GetAllPaths is not null)
            parameters.Add("GetAllPaths", args.GetAllPaths);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VHDSetInfo>(
            "Get-VHDSet",
            parameters
        );
        return result;
    }

    public class Get_VHDSnapshotArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967)
        or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this command. NetBIOS names, IP addresses, and fully
        qualified domain names are allowable. The default is the local computer. Use `localhost` or a dot
        (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Gets the paths of all files on which this VHD checkpoint depends.
         */
        public SwitchParameter? GetParentPaths { get; set; }

        /**
         * Specifies an array of paths of VHD set files from which this cmdlet gets checkpoints. If you specify
        a file name or relative path, the cmdlet determines the full path relative to the current working
        folder.
         */
        public required string[]? Path { get; set; }

        /**
         * Specifies an array of unique IDs of VHD checkpoints that this cmdlet gets from a VHD set file.
         */
        public Guid[]? SnapshotId { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vhdsnapshot?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="remove-vhdsnapshot.md">Remove-VHDSnapshot</see>
     * Gets information about a checkpoint in a VHD set.
     * </summary>
     * <remarks>
     * The `Get-VHDSnapshot` cmdlet gets information about a checkpoint in a virtual hard disk (VHD) set file.
    
    Checkpoint replaces the previous term, snapshot.
     * </remarks>
     * <returns>This cmdlet returns a **VHDSnapshotInfo** object.</returns>
     */
    public Microsoft.Vhd.PowerShell.VHDSnapshotInfo[] Get_VHDSnapshot(Get_VHDSnapshotArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.GetParentPaths is not null)
            parameters.Add("GetParentPaths", args.GetParentPaths);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.SnapshotId is not null)
            parameters.Add("SnapshotId", args.SnapshotId);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VHDSnapshotInfo>(
            "Get-VHDSnapshot",
            parameters
        );
        return result;
    }

    public class Get_VMArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies the cluster resource or cluster group of the virtual machine to be retrieved.
         */
        public PSObject? ClusterObject { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which virtual machines are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the identifier of the virtual machine to be retrieved.
         */
        public Guid? Id { get; set; }

        /**
         * Specifies the name of the virtual machine to be retrieved.
         */
        public string[]? Name { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the virtual machines from one or more Hyper-V hosts.
     * </summary>
     * <remarks>
     * The **Get-VM** cmdlet gets the virtual machines from one or more Hyper-V hosts.
     * </remarks>
     */
    public VirtualMachine[] Get_VM(Get_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ClusterObject is not null)
            parameters.Add("ClusterObject", args.ClusterObject);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Get-VM", parameters);
        return result;
    }

    public class Get_VMAssignableDeviceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the assignable devices are to be retrieved. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Retrieves one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Represents the Device Instance path in the host machine.
         */
        public string? InstancePath { get; set; }

        /**
         * Specifies the location path to the assignable device
         */
        public string? LocationPath { get; set; }

        /**
         * Retrieves the virtual machine which a device is assigned.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Retrieves the names of the assignable devices assigned to the specified virtual machine.
         */
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmassignabledevice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="add-vmassignabledevice.md">Add-VMAssignableDevice</see>
     *
     * <see href="remove-vmassignabledevice.md">Remove-VMAssignableDevice</see>
     * Retrieves information about the assignable device from a specific virtual machine.
     * </summary>
     * <remarks>
     * The `Get-VMAssignableDevice` cmdlet retrieves information about the assignable devices that are associated with a specific virtual machine (VM). This cmdlet can be used to list all assignable devices that can be attached to a VM or to retrieve details about specific devices that are already assigned. The retrieved information can include the device's instance path, location path, and other relevant properties.
     * </remarks>
     */
    public VMAssignedDevice[] Get_VMAssignableDevice(Get_VMAssignableDeviceArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.InstancePath is not null)
            parameters.Add("InstancePath", args.InstancePath);
        if (args.LocationPath is not null)
            parameters.Add("LocationPath", args.LocationPath);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMAssignedDevice>(
            "Get-VMAssignableDevice",
            parameters
        );
        return result;
    }

    public class Get_VMBiosArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the BIOS of a virtual machine or snapshot is to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine whose BIOS is to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose BIOS is to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine snapshot whose BIOS is to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmbios?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the BIOS of a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMBios** cmdlet gets the BIOS of a virtual machine or snapshot. Note: This cmdlet does not operate with Generation 2 virtual machine. If attempted, the cmdlet throws an error.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Get_VMBios(Get_VMBiosArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Get-VMBios",
            parameters
        );
        return result;
    }

    public class Get_VMComPortArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the COM ports of a virtual machine or snapshot are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the Id (1 or 2) of the COM ports to be retrieved.
         */
        public int? Number { get; set; }

        /**
         * Specifies the virtual machine whose COM ports are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose COM ports are to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot whose COM ports are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmcomport?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the COM ports of a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMComPort** cmdlet gets the COM ports of a virtual machine or snapshot.
     * </remarks>
     */
    public VMComPort[] Get_VMComPort(Get_VMComPortArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Number is not null)
            parameters.Add("Number", args.Number);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMComPort>("Get-VMComPort", parameters);
        return result;
    }

    public class Get_VMConnectAccessArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the user or users for whom connect access entries are being sought.
         */
        public string[]? UserName { get; set; }

        /**
         * Specifies the unique identifier of a virtual machine for which connect access entries are being sought.
         */
        public required Guid[]? VMId { get; set; }

        /**
         * Specifies the name of the virtual machine for which connect access entries are being sought.
         */
        public string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmconnectaccess?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets entries showing users and the virtual machines to which they can connect on one or more Hyper-V hosts.
     * </summary>
     * <remarks>
     * The **Get-VMConnectAccess** cmdlet gets entries showing users and the virtual machines to which they can connect on one or more Hyper-V hosts. This cmdlet is intended for use in providing other applications with the appropriate permissions required to initiate a session with the Virtual Machine Connection protocol. Examples of such applications are Virtual Machine Manager.
     * </remarks>
     */
    public VMConnectAce[] Get_VMConnectAccess(Get_VMConnectAccessArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.UserName is not null)
            parameters.Add("UserName", args.UserName);
        if (args.VMId is not null)
            parameters.Add("VMId", args.VMId);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMConnectAce>("Get-VMConnectAccess", parameters);
        return result;
    }

    public class Get_VMDvdDriveArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the DVD drives are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies the number of the location on the controller from which the DVD drives are to be retrieved.
         */
        public int? ControllerLocation { get; set; }

        /**
         * Specifies the number of the controller from which the DVD drives are to be retrieved.
         */
        public int? ControllerNumber { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine from which the DVD drives are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the controller from which the DVD drives are to be retrieved.
         */
        public required VMDriveController[]? VMDriveController { get; set; }

        /**
         * Specifies the name of the virtual machine from which the DVD drives are to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine snapshot from which the DVD drives are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmdvddrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the DVD drives attached to a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMDvdDrive** cmdlet gets the DVD drives attached to a virtual machine or snapshot. This cmdlet has no ControllerType parameter, as the **Get-VMHardDiskDrive** cmdlet does, because virtual DVD drives can be attached only to the IDE controller.
     * </remarks>
     */
    public DvdDrive[] Get_VMDvdDrive(Get_VMDvdDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMDriveController is not null)
            parameters.Add("VMDriveController", args.VMDriveController);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<DvdDrive>("Get-VMDvdDrive", parameters);
        return result;
    }

    public class Get_VMFibreChannelHbaArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the Fibre Channel host bus adapters are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies a virtual machine or machines for which the Fibre Channel host bus adapters are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the friendly name or names of the virtual machines for which the Fibre Channel host bus adapters are to be retrieved.
         */
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmfibrechannelhba?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the Fibre Channel host bus adapters associated with one or more virtual machines.
     * </summary>
     * <remarks>
     * The **Get-VMFibreChannelHba** cmdlet lists all of the fibre channel objects for each virtual fibre channel controller that is connected to the specified virtual machine.
     * </remarks>
     */
    public VMFibreChannelHba[] Get_VMFibreChannelHba(Get_VMFibreChannelHbaArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMFibreChannelHba>(
            "Get-VMFibreChannelHba",
            parameters
        );
        return result;
    }

    public class Get_VMFirmwareArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet gets the virtual machine firmware from the hosts you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        The cmdlet gets the firmware configuration for the virtual machines you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines.
        The cmdlet gets the firmware configuration for the virtual machines you specify.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine snapshot to be used with the VM when retrieving the firmware configuration.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmfirmware?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Set-VMFirmware.md">Set-VMFirmware</see>
     * Gets the firmware configuration of a virtual machine.
     * </summary>
     * <remarks>
     * The **Get-VMFirmware** cmdlet gets the firmware configuration of a virtual machine. Note: This cmdlet is supported only on Generation 2 virtual machines.
     * </remarks>
     */
    public VMFirmware[] Get_VMFirmware(Get_VMFirmwareArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMFirmware>("Get-VMFirmware", parameters);
        return result;
    }

    public class Get_VMFloppyDiskDriveArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which floppy disk drives are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine whose floppy disk drives are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose floppy disk drives are to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot whose floppy disk drives are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmfloppydiskdrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the floppy disk drives of a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMFloppyDiskDrive** cmdlet gets the floppy disk drives of a virtual machine or snapshot.
     * </remarks>
     */
    public VMFloppyDiskDrive[] Get_VMFloppyDiskDrive(Get_VMFloppyDiskDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMFloppyDiskDrive>(
            "Get-VMFloppyDiskDrive",
            parameters
        );
        return result;
    }

    public class Get_VMGpuPartitionAdapterArguments
    {
        /**
         * This is a VM's GPU partition identification number used to display the GPU information assigned to a
        VM.
         */
        public string? AdapterId { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on the virtual network adapters are to be retrieved. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine whose virtual network adapters are to be retrieved. The asterisk (`*`)
        is the wildcard. If it is specified the cmdlet returns virtual network adapters from every virtual
        machine in the system.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose network adapters are to be retrieved.
         */
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmgpupartitionadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="add-vmgpupartitionadapter.md">Add-VMGpuPartitionAdapter</see>
     *
     * <see href="remove-vmgpupartitionadapter.md">Remove-VMGpuPartitionAdapter</see>
     *
     * <see href="set-vmgpupartitionadapter.md">Set-VMGpuPartitionAdapter</see>
     * Gets the information of assigned GPU partitions to a virtual machine.
     * </summary>
     * <remarks>
     * The `Get-VMGpuPartitionAdapter` cmdlet gets the information of assigned graphic processing unit partitions to a virtual machine.
     * </remarks>
     */
    public VMGpuPartitionAdapter[] Get_VMGpuPartitionAdapter(
        Get_VMGpuPartitionAdapterArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.AdapterId is not null)
            parameters.Add("AdapterId", args.AdapterId);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMGpuPartitionAdapter>(
            "Get-VMGpuPartitionAdapter",
            parameters
        );
        return result;
    }

    public class Get_VMGroupArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the unique ID of the virtual machine group that this cmdlet gets.
         */
        public Guid? Id { get; set; }

        /**
         * Specifies an array of names of virtual machine groups that this cmdlet gets.
         */
        public string[]? Name { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmgroup?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./New-VMGroup.md">New-VMGroup</see>
     *
     * <see href="./Remove-VMGroup.md">Remove-VMGroup</see>
     *
     * <see href="./Rename-VMGroup.md">Rename-VMGroup</see>
     * Gets virtual machine groups.
     * </summary>
     * <remarks>
     * The **Get-VMGroup** cmdlet gets virtual machine groups.
     * </remarks>
     */
    public VMGroup[] Get_VMGroup(Get_VMGroupArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMGroup>("Get-VMGroup", parameters);
        return result;
    }

    public class Get_VMHardDiskDriveArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the virtual hard disk drives are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies the number of the location on the controller at which the virtual hard disk drives are to be retrieved.
        If not specified, the number of the first available location on the controller is used.
         */
        public int? ControllerLocation { get; set; }

        /**
         * Specifies the number of the controller at which the virtual hard disk drives are to be retrieved.
        If not specified, the first controller on which the specified **ControllerLocation** is available is used.
         */
        public int? ControllerNumber { get; set; }

        /**
         * Specifies the type of the controller from which the virtual hard disk drives are to be retrieved.
        Allowed values are **Floppy**, **IDE**, and **SCSI**.
         */
        public ControllerType? ControllerType { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine from which the virtual hard disk drives are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the drive controller from which the virtual hard disk drives are to be retrieved.
         */
        public required VMDriveController[]? VMDriveController { get; set; }

        /**
         * Specifies the name of the virtual machine from which the virtual hard disks drives are to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot from which the virtual hard disk drives are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmharddiskdrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the virtual hard disk drives attached to one or more virtual machines.
     * </summary>
     * <remarks>
     * The **Get-VMHardDiskDrive** cmdlet gets the virtual hard disk drives attached to one or more virtual machines.
     * </remarks>
     */
    public HardDiskDrive[] Get_VMHardDiskDrive(Get_VMHardDiskDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.ControllerType is not null)
            parameters.Add("ControllerType", args.ControllerType);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMDriveController is not null)
            parameters.Add("VMDriveController", args.VMDriveController);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<HardDiskDrive>("Get-VMHardDiskDrive", parameters);
        return result;
    }

    public class Get_VMHostArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmhost?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets a Hyper-V host.
     * </summary>
     * <remarks>
     * The **Get-VMHost** cmdlet gets a Hyper-V host.
     * </remarks>
     */
    public VMHost[] Get_VMHost(Get_VMHostArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHost>("Get-VMHost", parameters);
        return result;
    }

    public class Get_VMHostAssignableDeviceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the assignable devices are to be retrieved. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Represents the Device Instance path in the host machine.
         */
        public string? InstancePath { get; set; }

        /**
         * Specifies the location path to the assignable device.
         */
        public string? LocationPath { get; set; }

        /**
         * Retrieves the name of the resource pool to which the device is assigned.
         */
        public string[]? ResourcePoolName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmhostassignabledevice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="add-vmhostassignabledevice.md">Add-VMHostAssignableDevice</see>
     *
     * <see href="dismount-vmhostassignabledevice.md">Dismount-VMHostAssignableDevice</see>
     *
     * <see href="mount-vmhostassignabledevice.md">Mount-VMHostAssignableDevice</see>
     *
     * <see href="remove-vmhostassignabledevice.md">Remove-VMHostAssignableDevice</see>
     * Retrieves device information assigned to a virtual machine (VM) host.
     * </summary>
     * <remarks>
     * The `Get-VMHostAssignableDevice` cmdlet retrieves information about devices that can be assigned to a virtual machine host. This can include devices such as GPUs, network adapters, or storage controllers that are physically present on the host system. The cmdlet can filter devices by their instance path or location path.
     * </remarks>
     */
    public VMHostAssignableDevice[] Get_VMHostAssignableDevice(
        Get_VMHostAssignableDeviceArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.InstancePath is not null)
            parameters.Add("InstancePath", args.InstancePath);
        if (args.LocationPath is not null)
            parameters.Add("LocationPath", args.LocationPath);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHostAssignableDevice>(
            "Get-VMHostAssignableDevice",
            parameters
        );
        return result;
    }

    public class Get_VMHostClusterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of names of the virtual machine host clusters that this cmdlet gets.
         */
        public required string[]? ClusterName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmhostcluster?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Set-VMHostCluster.md">Set-VMHostCluster</see>
     * Gets virtual machine host clusters.
     * </summary>
     * <remarks>
     * The **Get-VMHostCluster** cmdlet gets **VMHostCluster** objects.
     * </remarks>
     * <returns>This cmdlet returns a **VMHostCluster** object.</returns>
     */
    public VMHostCluster[] Get_VMHostCluster(Get_VMHostClusterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ClusterName is not null)
            parameters.Add("ClusterName", args.ClusterName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHostCluster>("Get-VMHostCluster", parameters);
        return result;
    }

    public class Get_VMHostNumaNodeArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Identifies a NUMA node for which a **VMHostNumaNode** is to be retrieved.
         */
        public int? Id { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmhostnumanode?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the NUMA topology of a virtual machine host.
     * </summary>
     * <remarks>
     * The **Get-VMHostNumaNode** cmdlet gets the NUMA topology of a Hyper-V host, returning a **VMHostNumaNode** object for each of the host's NUMA nodes.
     * </remarks>
     */
    public VMHostNumaNode[] Get_VMHostNumaNode(Get_VMHostNumaNodeArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHostNumaNode>("Get-VMHostNumaNode", parameters);
        return result;
    }

    public class Get_VMHostNumaNodeStatusArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Identifies a NUMA node for which virtual machine status is to be retrieved.
         */
        public int? Id { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmhostnumanodestatus?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the status of the virtual machines on the non-uniform memory access (NUMA) nodes of a virtual machine host or hosts.
     * </summary>
     * <remarks>
     * The **Get-VMHostNumaNodeStatus** cmdlet gets the status of the virtual machines on the non-uniform memory access (NUMA) nodes of a virtual machine host or hosts. If the virtual machine host enables NUMA spanning, this cmdlet returns an error.
     * </remarks>
     */
    public GetVMHostNumaNodeStatus[] Get_VMHostNumaNodeStatus(
        Get_VMHostNumaNodeStatusArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<GetVMHostNumaNodeStatus>(
            "Get-VMHostNumaNodeStatus",
            parameters
        );
        return result;
    }

    public class Get_VMHostPartitionableGpuArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet. NetBIOS names, IP addresses, and fully
        qualified domain names are allowed. The default is the local computer. Use localhost or a dot (`.`)
        to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the graphic processing unit to be retrieved.
         */
        public string? Name { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmhostpartitionablegpu?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="set-vmhostpartitionablegpu.md">Set-VMHostPartitionableGpu</see>
     * Gets the host machines partitionable GPU.
     * </summary>
     * <remarks>
     * The `Get-VMHostPartitionableGpu` cmdlet gets the host machines partitionable graphic processing unit. This displays the information of the GPU as provided by the manufacturer's driver.
     * </remarks>
     */
    public VMHostPartitionableGpu[] Get_VMHostPartitionableGpu(
        Get_VMHostPartitionableGpuArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHostPartitionableGpu>(
            "Get-VMHostPartitionableGpu",
            parameters
        );
        return result;
    }

    public class Get_VMHostSupportedVersionArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts to run the cmdlet.
        NetBIOS names, IP addresses, and fully-qualified domain names are allowable.
        The default is the local computer.
        Use "localhost" or a dot (".") to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies a user account that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the cmdlet is to return the default virtual machine configuration version for this host.
         */
        public SwitchParameter? Default { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmhostsupportedversion?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMHost.md">Get-VMHost</see>
     * Returns a list of virtual machine configuration versions that are supported on a host.
     * </summary>
     * <remarks>
     * The **Get-VMHostSupportedVersion** cmdlet returns a list of virtual machine configuration versions that are supported on a host.
     * </remarks>
     */
    public VMHostSupportedVersion[] Get_VMHostSupportedVersion(
        Get_VMHostSupportedVersionArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Default is not null)
            parameters.Add("Default", args.Default);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHostSupportedVersion>(
            "Get-VMHostSupportedVersion",
            parameters
        );
        return result;
    }

    public class Get_VMIdeControllerArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the IDE controllers of a virtual machine or snapshot are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies the number of the IDE controller to be retrieved.
        Allowed values are 0 and 1.
         */
        public int? ControllerNumber { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine whose IDE controllers are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose IDE controllers are to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot whose IDE controllers are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmidecontroller?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the IDE controllers of a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMIdeController** cmdlet gets the IDE controllers of a virtual machine or snapshot.
     * </remarks>
     */
    public VMIdeController[] Get_VMIdeController(Get_VMIdeControllerArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMIdeController>("Get-VMIdeController", parameters);
        return result;
    }

    public class Get_VMIntegrationServiceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the integration services are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the integration service to be retrieved.
         */
        public string[]? Name { get; set; }

        /**
         * Specifies the virtual machine from which the integration services are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine from which the integration services are to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot from which the integration services are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmintegrationservice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the integration services of a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMIntegrationService** cmdlet gets the integration services of a virtual machine or snapshot.
     * </remarks>
     */
    public VMIntegrationComponent[] Get_VMIntegrationService(Get_VMIntegrationServiceArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMIntegrationComponent>(
            "Get-VMIntegrationService",
            parameters
        );
        return result;
    }

    public class Get_VMKeyProtectorArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts to run the cmdlet.
        NetBIOS names, IP addresses, and fully-qualified domain names are allowable.
        The default is the local computer.
        Use "localhost" or a dot (".") to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies a user account that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine for which the cmdlet gets a key protector.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine for which the cmdlet gets a key protector.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmkeyprotector?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Set-VMKeyProtector.md">Set-VMKeyProtector</see>
     * Retrieves a key protector for a virtual machine.
     * </summary>
     * <remarks>
     * The **Get-VMKeyProtector** cmdlet retrieves a key protector for a virtual machine.
     * </remarks>
     */
    public void Get_VMKeyProtector(Get_VMKeyProtectorArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Get-VMKeyProtector", parameters);
    }

    public class Get_VMKeyStorageDriveArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public int? ControllerLocation { get; set; }
        public int? ControllerNumber { get; set; }
        public PSCredential[]? Credential { get; set; }
        public required VirtualMachine[]? VM { get; set; }
        public required VMDriveController[]? VMDriveController { get; set; }
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     *
     * Get-VMKeyStorageDrive [-VMName] <string[]> [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-ControllerLocation <int>] [-ControllerNumber <int>] [<CommonParameters>]
     *
     * Get-VMKeyStorageDrive [-VM] <VirtualMachine[]> [-ControllerLocation <int>] [-ControllerNumber <int>] [<CommonParameters>]
     *
     * Get-VMKeyStorageDrive [-VMDriveController] <VMDriveController[]> [-ControllerLocation <int>] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public KeyStorageDrive[] Get_VMKeyStorageDrive(Get_VMKeyStorageDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMDriveController is not null)
            parameters.Add("VMDriveController", args.VMDriveController);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<KeyStorageDrive>("Get-VMKeyStorageDrive", parameters);
        return result;
    }

    public class Get_VMMemoryArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the memory of a virtual machine or snapshot is to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine whose memory is to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose memory is to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot whose memory is to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmmemory?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the memory of a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMMemory** cmdlet gets the memory of a virtual machine or snapshot.
     * </remarks>
     */
    public VMMemory[] Get_VMMemory(Get_VMMemoryArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMMemory>("Get-VMMemory", parameters);
        return result;
    }

    public class Get_VMMigrationNetworkArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the networks added for migration are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the priority of the networks to be retrieved.
         */
        public UInt32[]? Priority { get; set; }

        /**
         * Specifies a string representing an IPv4 or IPv6 subnet mask which identifies the networks to be retrieved.
         */
        public string[]? Subnet { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmmigrationnetwork?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the networks added for migration to one or more virtual machine hosts.
     * </summary>
     * <remarks>
     * The **Get-VMMigrationNetwork** cmdlet gets the networks added for migration to one or more virtual machine hosts.
     * </remarks>
     */
    public VMMigrationNetwork[] Get_VMMigrationNetwork(Get_VMMigrationNetworkArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Priority is not null)
            parameters.Add("Priority", args.Priority);
        if (args.Subnet is not null)
            parameters.Add("Subnet", args.Subnet);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMMigrationNetwork>(
            "Get-VMMigrationNetwork",
            parameters
        );
        return result;
    }

    public class Get_VMNetworkAdapterArguments
    {
        /**
         * Specifies all virtual network adapters in the system, regardless of whether the virtual network adapter is in the management operating system or in a virtual machine.
         */
        public required SwitchParameter? All { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on the virtual network adapters are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specify as **$TRUE** to retrieve only legacy network adapters, or as **$FALSE** to retrieve only Hyper-V-specific network adapters.
        If not specified, virtual network adapters of both types are retrieved.
         */
        public Boolean? IsLegacy { get; set; }

        /**
         * Specifies the management operating system, i.e.
        the virtual machine host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the name of the network adapter to be retrieved.
         */
        public string? Name { get; set; }

        /**
         * Specifies the name of the virtual switch whose network adapters are to be retrieved.
        (This parameter is available only for virtual network adapters in the management operating system.)
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies the virtual machine whose virtual network adapters are to be retrieved.
        The asterisk, "*", is the wildcard.
        If it is specified the cmdlet returns virtual network adapters from every virtual machine in the system.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose network adapters are to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot whose network adapters are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmnetworkadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the virtual network adapters of a virtual machine, snapshot, management operating system, or of a virtual machine and management operating system.
     * </summary>
     * <remarks>
     * The **Get-VMNetworkAdapter** cmdlet gets the virtual network adapters of the specified virtual machine, snapshot, or management operating system.
     * </remarks>
     * <returns>By default, **Microsoft.HyperV.PowerShell.VMNetworkAdapter** is output.</returns>
     */
    public VMNetworkAdapter[] Get_VMNetworkAdapter(Get_VMNetworkAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.All is not null)
            parameters.Add("All", args.All);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.IsLegacy is not null)
            parameters.Add("IsLegacy", args.IsLegacy);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapter>("Get-VMNetworkAdapter", parameters);
        return result;
    }

    public class Get_VMNetworkAdapterAclArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the ACLs configured for a virtual machine network adapter are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the ACLs are to be configured in the management (i.e.
        the parent, or host) operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the virtual machine in which the ACLs configured for a virtual machine network adapter are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine in which the ACLs configured for a virtual machine network adapter are to be retrieved.
         */
        public string[]? VMName { get; set; }

        /**
         * Specifies the virtual network adapter for which the configured ACLs are to be retrieved.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the virtual network adapter name for which the configured ACLs are to be retrieved.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies the snapshot in which the ACLs configured for a virtual machine network adapter are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmnetworkadapteracl?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the ACLs configured for a virtual machine network adapter.
     * </summary>
     * <remarks>
     * The **Get-VMNetworkAdapterAcl** cmdlet gets the ACLs configured for a virtual machine network adapter. If an ACL entry is created to be applied to both directions, it will appear under the list of entries for the inbound direction and under the list of entries for the outbound direction in the output from Get-VMNetworkAdapterAcl.
     * </remarks>
     */
    public VMNetworkAdapterAclSetting[] Get_VMNetworkAdapterAcl(
        Get_VMNetworkAdapterAclArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterAclSetting>(
            "Get-VMNetworkAdapterAcl",
            parameters
        );
        return result;
    }

    public class Get_VMNetworkAdapterExtendedAclArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet gets the ACLs associated with the virtual network adapters on the Hyper-V hosts that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent or host operating system.
        If you specify this parameter, this cmdlet gets ACLs associated with network adapters in the parent or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies an array of virtual machines as **VirtualMachine** objects.
        The cmdlet gets ACLs for network adapters that belong to the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of VMs.
        The cmdlet gets ACLs associated with network adapters that belong to the VMs that you specify.
         */
        public string[]? VMName { get; set; }

        /**
         * Specifies an array of virtual network adapter objects.
        The cmdlet gets ACLs associated with the adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
        The cmdlet gets extended ACLs associated with the adapter that you specify.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies a snapshot as a **VMSnapshot** object.
        The cmdlet gets ACLs for network adapters that belong to the snapshot that you specify.
        To obtain a snapshot, use the **Get-VMSnapshot** cmdlet.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmnetworkadapterextendedacl?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Add-VMNetworkAdapterExtendedAcl.md">Add-VMNetworkAdapterExtendedAcl</see>
     *
     * <see href="./Remove-VMNetworkAdapterExtendedAcl.md">Remove-VMNetworkAdapterExtendedAcl</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     *
     * <see href="./Get-VMNetworkAdapter.md">Get-VMNetworkAdapter</see>
     *
     * <see href="./Get-VMSnapshot.md">Get-VMSnapshot</see>
     * Gets extended ACLs configured for a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Get-VMNetworkAdapterExtendedAcl** cmdlet gets the extended access control lists (ACLs) configured for a virtual network adapter. If an ACL applies to both inbound and outbound packets, it appears in both inbound and outbound lists.
     * </remarks>
     */
    public VMNetworkAdapterExtendedAclSetting[] Get_VMNetworkAdapterExtendedAcl(
        Get_VMNetworkAdapterExtendedAclArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterExtendedAclSetting>(
            "Get-VMNetworkAdapterExtendedAcl",
            parameters
        );
        return result;
    }

    public class Get_VMNetworkAdapterFailoverConfigurationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the IP address configuration of a virtual network adapter is to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine for which you want to get the IP address configuration of a virtual network adapter.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine for which you want to get the IP address configuration of a virtual network adapter.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual network adapter whose IP address configuration you want to get.
         */
        public required VMNetworkAdapter[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual network adapter whose IP address configuration you want to get.
         */
        public string? VMNetworkAdapterName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmnetworkadapterfailoverconfiguration?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the IP address of a virtual network adapter configured to be used when a virtual machine fails over.
     * </summary>
     * <remarks>
     * The **Get-VMNetworkAdapterFailoverConfiguration** cmdlet gets the IP address configuration of a virtual network adapter configured to be used when a virtual machine fails over.
     * </remarks>
     */
    public PSObject[] Get_VMNetworkAdapterFailoverConfiguration(
        Get_VMNetworkAdapterFailoverConfigurationArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<PSObject>(
            "Get-VMNetworkAdapterFailoverConfiguration",
            parameters
        );
        return result;
    }

    public class Get_VMNetworkAdapterIsolationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet gets isolation settings for virtual machines hosted by the computers that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent or host operating system.
        If you specify this parameter, this cmdlet gets isolation settings for the parent or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies an array of virtual machines.
        The cmdlet gets isolation settings for adapters that belong to the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines.
        The cmdlet gets isolation settings for adapters that belong to the virtual machines that you specify.
         */
        public string[]? VMName { get; set; }

        /**
         * Specifies an array virtual machine network adapters as **VMNetworkAdapterBase** objects.
        The cmdlet gets isolation settings for the adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
        The cmdlet gets isolation settings for the adapters that you specify.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies a snapshot as a **VMSnapshot** object.
        The cmdlet gets isolation settings for network adapters that belong to the snapshot that you specify.
        To obtain a snapshot, use the **Get-VMSnapshot** cmdlet.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmnetworkadapterisolation?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Set-VMNetworkAdapterIsolation.md">Set-VMNetworkAdapterIsolation</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     *
     * <see href="./Get-VMSnapshot.md">Get-VMSnapshot</see>
     *
     * <see href="./Get-VMNetworkAdapter.md">Get-VMNetworkAdapter</see>
     * Gets isolation settings for a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Get-VMNetworkAdapterIsolation** cmdlet gets isolation settings for a virtual network adapter. The cmdlet displays the isolation method, and other information, such as the multitenancy mode and the subnet ID for traffic bound for to the default compartment if multitenancy is enabled.
     * </remarks>
     */
    public VMNetworkAdapterIsolationSetting[] Get_VMNetworkAdapterIsolation(
        Get_VMNetworkAdapterIsolationArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterIsolationSetting>(
            "Get-VMNetworkAdapterIsolation",
            parameters
        );
        return result;
    }

    public class Get_VMNetworkAdapterRdmaArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public PSCredential[]? Credential { get; set; }
        public required object? ManagementOS { get; set; }
        public string? Name { get; set; }
        public object? Passthru { get; set; }
        public string? SwitchName { get; set; }
        public required VirtualMachine? VM { get; set; }
        public required string? VMName { get; set; }
        public required VMNetworkAdapterBase? VMNetworkAdapter { get; set; }
    }

    /** <summary>
     *
     * Get-VMNetworkAdapterRdma [-VMName] <string> [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-Name <string>] [-Passthru] [<CommonParameters>]
     *
     * Get-VMNetworkAdapterRdma -ManagementOS [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-Name <string>] [-SwitchName <string>] [-Passthru] [<CommonParameters>]
     *
     * Get-VMNetworkAdapterRdma [-VMNetworkAdapter] <VMNetworkAdapterBase> [-Passthru] [<CommonParameters>]
     *
     * Get-VMNetworkAdapterRdma [-VM] <VirtualMachine> [-Name <string>] [-Passthru] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VMNetworkAdapterRdmaSetting[] Get_VMNetworkAdapterRdma(
        Get_VMNetworkAdapterRdmaArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterRdmaSetting>(
            "Get-VMNetworkAdapterRdma",
            parameters
        );
        return result;
    }

    public class Get_VMNetworkAdapterRoutingDomainMappingArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet gets the members of a routing domain on the Hyper-V hosts that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent partition or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the ID of a routing domain.
        The ID of a routing domain is a system-assigned GUID.
        The cmdlet gets the members of the routing domain that you specify.
         */
        public Guid? RoutingDomainID { get; set; }

        /**
         * Specifies the name of a routing domain.
        The cmdlet gets the members of the routing domain that you specify.
         */
        public string? RoutingDomainName { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        The cmdlet gets the members of the routing domain from the network interfaces that belong to the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of friendly names of virtual machines.
        The cmdlet gets the members of the routing domain from the network interfaces that belong to the virtual machines that you specify.
         */
        public string[]? VMName { get; set; }

        /**
         * Specifies an array of virtual network adapters as a **VMNetworkAdapterBase** object.
        The cmdlet gets the members of the routing domain on the adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
        The cmdlet gets the members of the routing domain on the adapter that you specify.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies a snapshot as a **VMSnapshot** object.
        The cmdlet gets the members of the routing domain for network adapters that belong to the snapshot that you specify.
        To obtain a snapshot object, use the **Get-VMSnapshot** cmdlet.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmnetworkadapterroutingdomainmapping?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Add-VmNetworkAdapterRoutingDomainMapping.md">Add-VmNetworkAdapterRoutingDomainMapping</see>
     *
     * <see href="./Set-VmNetworkAdapterRoutingDomainMapping.md">Set-VmNetworkAdapterRoutingDomainMapping</see>
     *
     * <see href="./Remove-VMNetworkAdapterRoutingDomainMapping.md">Remove-VMNetworkAdapterRoutingDomainMapping</see>
     * Gets members of a routing domain.
     * </summary>
     * <remarks>
     * The **Get-VmNetworkAdapterRoutingDomainMapping** cmdlet gets members of a routing domain.
     * </remarks>
     */
    public VMNetworkAdapterRoutingDomainSetting[] Get_VMNetworkAdapterRoutingDomainMapping(
        Get_VMNetworkAdapterRoutingDomainMappingArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.RoutingDomainID is not null)
            parameters.Add("RoutingDomainID", args.RoutingDomainID);
        if (args.RoutingDomainName is not null)
            parameters.Add("RoutingDomainName", args.RoutingDomainName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterRoutingDomainSetting>(
            "Get-VMNetworkAdapterRoutingDomainMapping",
            parameters
        );
        return result;
    }

    public class Get_VMNetworkAdapterTeamMappingArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the name of a network adapter.
         */
        public string? Name { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of a switch.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies a virtual machine object.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Specifies the name of a virtual machine.
         */
        public required string? VMName { get; set; }

        /**
         * Specifies a virtual machine network adapter.
         */
        public required VMNetworkAdapterBase? VMNetworkAdapter { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmnetworkadapterteammapping?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Remove-VMNetworkAdapterTeamMapping.md">Remove-VMNetworkAdapterTeamMapping</see>
     *
     * <see href="./Set-VMNetworkAdapterTeamMapping.md">Set-VMNetworkAdapterTeamMapping</see>
     *
     * </summary>
     * <remarks>
     * The **Get-VMNetworkAdapterTeamMapping** cmdlet
     * </remarks>
     */
    public void Get_VMNetworkAdapterTeamMapping(Get_VMNetworkAdapterTeamMappingArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Get-VMNetworkAdapterTeamMapping", parameters);
    }

    public class Get_VMNetworkAdapterVlanArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual LAN settings configured on a virtual network adapter are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the virtual LAN settings are to be retrieved from the management (i.e.
        parent, or host) operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the virtual machine in which the virtual LAN settings configured on a virtual network adapter are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine in which the virtual LAN settings configured on a virtual network adapter are to be retrieved.
        
         * Friendly name of the virtual machine
         */
        public string[]? VMName { get; set; }

        /**
         * Specifies the virtual network adapter for which the virtual LAN settings are to be retrieved.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual network adapter for which the virtual LAN settings are to be retrieved.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies the snapshot in which the virtual LAN settings are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmnetworkadaptervlan?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the virtual LAN settings configured on a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Get-VMNetworkAdapterVlan** cmdlet gets the virtual LAN settings configured on a virtual network adapter.
     * </remarks>
     */
    public VMNetworkAdapterVlanSetting[] Get_VMNetworkAdapterVlan(
        Get_VMNetworkAdapterVlanArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterVlanSetting>(
            "Get-VMNetworkAdapterVlan",
            parameters
        );
        return result;
    }

    public class Get_VMPartitionableGpuArguments
    {
        public required CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public PSCredential[]? Credential { get; set; }
        public string? Name { get; set; }
    }

    /** <summary>
     *
     * Get-VMPartitionableGpu [[-ComputerName] <string[]>] [[-Credential] <pscredential[]>] [-Name <string>] [<CommonParameters>]
     *
     * Get-VMPartitionableGpu [-CimSession] <CimSession[]> [-Name <string>] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VMPartitionableGpu[] Get_VMPartitionableGpu(Get_VMPartitionableGpuArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMPartitionableGpu>(
            "Get-VMPartitionableGpu",
            parameters
        );
        return result;
    }

    public class Get_VMPmemControllerArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public int? ControllerNumber { get; set; }
        public PSCredential[]? Credential { get; set; }
        public required VirtualMachine[]? VM { get; set; }
        public required string[]? VMName { get; set; }
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     *
     * Get-VMPmemController [-VMName] <string[]> [[-ControllerNumber] <int>] [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [<CommonParameters>]
     *
     * Get-VMPmemController [-VMSnapshot] <VMSnapshot> [[-ControllerNumber] <int>] [<CommonParameters>]
     *
     * Get-VMPmemController [-VM] <VirtualMachine[]> [[-ControllerNumber] <int>] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VMPmemController[] Get_VMPmemController(Get_VMPmemControllerArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMPmemController>("Get-VMPmemController", parameters);
        return result;
    }

    public class Get_VMProcessorArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the processor of a virtual machine or snapshot is to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine whose processor is to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose processor is to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot whose processor is to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmprocessor?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the processor of a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMProcessor** cmdlet gets the processor of a virtual machine or snapshot.
     * </remarks>
     */
    public VMProcessor[] Get_VMProcessor(Get_VMProcessorArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMProcessor>("Get-VMProcessor", parameters);
        return result;
    }

    public class Get_VMRemoteFx3dVideoAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the RemoteFX video adapter is to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine whose RemoteFX video adapter is to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose RemoteFX video adapter is to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot whose RemoteFX video adapter is to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmremotefx3dvideoadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the RemoteFX video adapter of a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMRemoteFx3dVideoAdapter** cmdlet gets the RemoteFX video adapter of a virtual machine or snapshot.
     * </remarks>
     */
    public VMRemoteFx3DVideoAdapter[] Get_VMRemoteFx3dVideoAdapter(
        Get_VMRemoteFx3dVideoAdapterArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMRemoteFx3DVideoAdapter>(
            "Get-VMRemoteFx3dVideoAdapter",
            parameters
        );
        return result;
    }

    public class Get_VMRemoteFXPhysicalVideoAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the names of one or more RemoteFX physical graphics adapters to be retrieved.
         */
        public string[]? Name { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmremotefxphysicalvideoadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the RemoteFX physical graphics adapters on one or more Hyper-V hosts.
     * </summary>
     * <remarks>
     * The **Get-VMRemoteFXPhysicalVideoAdapter** cmdlet gets the RemoteFX physical graphics adapters on one or more Hyper-V hosts.
     * </remarks>
     */
    public VMRemoteFXPhysicalVideoAdapter[] Get_VMRemoteFXPhysicalVideoAdapter(
        Get_VMRemoteFXPhysicalVideoAdapterArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMRemoteFXPhysicalVideoAdapter>(
            "Get-VMRemoteFXPhysicalVideoAdapter",
            parameters
        );
        return result;
    }

    public class Get_VMReplicationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which virtual machine replication settings are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the primary server of the virtual machines whose replication settings are to be retrieved.
         */
        public string? PrimaryServerName { get; set; }

        /**
         * Specifies the replica server name of the virtual machines whose replication settings are to be retrieved.
         */
        public string? ReplicaServerName { get; set; }

        /**
         * Gets replication settings for virtual machines with the specified replication health state.
        Valid values are Normal, Warning, and Critical.
         */
        public VMReplicationHealthState? ReplicationHealth { get; set; }

        /**
         * Gets the replication settings for virtual machines with the specified replication mode.
        Valid values are None, Primary, Replica, and TestReplica.
         */
        public VMReplicationMode? ReplicationMode { get; set; }

        /**
         * Specifies the replication relationship type of the virtual machine.
        Specify whether the replication relationship is a simple primary to replica or is an extended replication chain.
        The cmdlet gets the replication settings for the virtual machines that have the replication type that you specify.
         */
        public VMReplicationRelationshipType? ReplicationRelationshipType { get; set; }

        /**
         * Gets replication settings for virtual machines with the specified replication state.
        Valid values are:
        
         * - Error
        - FailOverWaitingCompletion
        - FailedOver
        - NotApplicable
        - ReadyForInitialReplication
        - Replicating
        - Resynchronizing
        - ResynchronizeSuspended
        - Suspended
        - SyncedReplicationComplete
        - WaitingForInitialReplication
        - WaitingForStartResynchronize
         */
        public VMReplicationState? ReplicationState { get; set; }

        /**
         * Specifies the trust group of the virtual machines whose replication settings you want to retrieve.
         */
        public string? TrustGroup { get; set; }

        /**
         * Specifies the virtual machine whose replication settings are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose replication settings are to be retrieved.
         */
        public string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the replication settings for a virtual machine.
     * </summary>
     * <remarks>
     * The **Get-VMReplication** cmdlet gets the replication settings for a virtual machine.
     * </remarks>
     */
    public VMReplication[] Get_VMReplication(Get_VMReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.PrimaryServerName is not null)
            parameters.Add("PrimaryServerName", args.PrimaryServerName);
        if (args.ReplicaServerName is not null)
            parameters.Add("ReplicaServerName", args.ReplicaServerName);
        if (args.ReplicationHealth is not null)
            parameters.Add("ReplicationHealth", args.ReplicationHealth);
        if (args.ReplicationMode is not null)
            parameters.Add("ReplicationMode", args.ReplicationMode);
        if (args.ReplicationRelationshipType is not null)
            parameters.Add("ReplicationRelationshipType", args.ReplicationRelationshipType);
        if (args.ReplicationState is not null)
            parameters.Add("ReplicationState", args.ReplicationState);
        if (args.TrustGroup is not null)
            parameters.Add("TrustGroup", args.TrustGroup);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMReplication>("Get-VMReplication", parameters);
        return result;
    }

    public class Get_VMReplicationAuthorizationEntryArguments
    {
        /**
         * Specifies the allowed primary server for which replication authorization entries are to be retrieved.
         */
        public string? AllowedPrimaryServer { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which replication authorization entries are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the location where virtual hard disk files are stored when an authorized primary server sends replication data to the specified Replica server.
         */
        public string? ReplicaStorageLocation { get; set; }

        /**
         * Gets the replication authorization entries that have the specified value for TrustGroup.
         */
        public string? TrustGroup { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmreplicationauthorizationentry?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the authorization entries of a Replica server.
     * </summary>
     * <remarks>
     * The **Get-VMReplicationAuthorizationEntry** cmdlet gets the replication authorization entries specified for a Replica server.
     * </remarks>
     */
    public VMReplicationAuthorizationEntry[] Get_VMReplicationAuthorizationEntry(
        Get_VMReplicationAuthorizationEntryArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowedPrimaryServer is not null)
            parameters.Add("AllowedPrimaryServer", args.AllowedPrimaryServer);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ReplicaStorageLocation is not null)
            parameters.Add("ReplicaStorageLocation", args.ReplicaStorageLocation);
        if (args.TrustGroup is not null)
            parameters.Add("TrustGroup", args.TrustGroup);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMReplicationAuthorizationEntry>(
            "Get-VMReplicationAuthorizationEntry",
            parameters
        );
        return result;
    }

    public class Get_VMReplicationServerArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-v hosts which run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmreplicationserver?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the replication and authentication settings of a Replica server.
     * </summary>
     * <remarks>
     * The **Get-VMReplicationServer** cmdlet gets the replication and authentication settings of a Replica server.
     * </remarks>
     */
    public VMReplicationServer[] Get_VMReplicationServer(Get_VMReplicationServerArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMReplicationServer>(
            "Get-VMReplicationServer",
            parameters
        );
        return result;
    }

    public class Get_VMResourcePoolArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the resource pools are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the resource pool or pools to be retrieved.
        Wildcards are allowed.
         */
        public string[]? Name { get; set; }

        /**
         * Specifies the type of the resource pool or pools to be retrieved.
         */
        public VMResourcePoolType[]? ResourcePoolType { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmresourcepool?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the resource pools on one or more virtual machine hosts.
     * </summary>
     * <remarks>
     * The **Get-VMResourcePool** cmdlet gets the resource pools on one or more virtual machine hosts.
     * </remarks>
     */
    public VMResourcePool[] Get_VMResourcePool(Get_VMResourcePoolArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMResourcePool>("Get-VMResourcePool", parameters);
        return result;
    }

    public class Get_VMSanArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the available virtual machine storage area networks (SANs) are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the friendly name of a virtual storage area network (SAN) to be retrieved.
         */
        public string[]? Name { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmsan?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the available virtual machine storage area networks on a Hyper-V host or hosts.
     * </summary>
     * <remarks>
     * The **Get-VMSan** cmdlet gets the available virtual storage area networks (SANs) on one or more Hyper-V hosts.
     * </remarks>
     */
    public VMSan[] Get_VMSan(Get_VMSanArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSan>("Get-VMSan", parameters);
        return result;
    }

    public class Get_VMScsiControllerArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the SCSI controllers are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies the number of the SCSI controller to be retrieved.
         */
        public int? ControllerNumber { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine whose SCSI controllers are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose SCSI controllers are to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot whose SCSI controllers are to be retrieved.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmscsicontroller?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the SCSI controllers of a virtual machine or snapshot.
     * </summary>
     * <remarks>
     * The **Get-VMScsiController** cmdlet gets the SCSI controllers of a virtual machine or snapshot.
     * </remarks>
     */
    public VMScsiController[] Get_VMScsiController(Get_VMScsiControllerArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMScsiController>("Get-VMScsiController", parameters);
        return result;
    }

    public class Get_VMSecurityArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts to run the cmdlet.
        NetBIOS names, IP addresses, and fully-qualified domain names are allowable.
        The default is the local computer.
        Use "localhost" or a dot (".") to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies a user account that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies one or more virtual machines for which this cmdlet gets security settings.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of one or more virtual machines for which this cmdlet gets security settings.
         */
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmsecurity?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets security information about a virtual machine.
     * </summary>
     * <remarks>
     * The **Get-VMSecurity** cmdlet gets security information about a virtual machine.
     * </remarks>
     */
    public VMSecurity[] Get_VMSecurity(Get_VMSecurityArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSecurity>("Get-VMSecurity", parameters);
        return result;
    }

    public class Get_VMStoragePathArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which storage paths are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the path for which matching storage paths are to be retrieved.
         */
        public string[]? Path { get; set; }

        /**
         * Specifies the name of the resource pool for which storage paths are to be retrieved.
         */
        public required string[]? ResourcePoolName { get; set; }

        /**
         * Specifies the type of the resource pool for which storage paths are to be retrieved.
        Valid values are:
        
         * - Memory
        - Processor
        - Ethernet
        - VHD
        - ISO
        - VFD
        - FibreChannelPort
        - FibreChannelConnection
         */
        public required VMResourcePoolType? ResourcePoolType { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmstoragepath?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the storage paths in a storage resource pool.
     * </summary>
     * <remarks>
     * The **Get-VMStoragePath** cmdlet gets the storage paths in a storage resource pool.
     * </remarks>
     */
    public VMStorageResourcePool[] Get_VMStoragePath(Get_VMStoragePathArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMStorageResourcePool>(
            "Get-VMStoragePath",
            parameters
        );
        return result;
    }

    public class Get_VMStorageSettingsArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public PSCredential[]? Credential { get; set; }
        public required VirtualMachine[]? VM { get; set; }
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     *
     * Get-VMStorageSettings [-VMName] <string[]> [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [<CommonParameters>]
     *
     * Get-VMStorageSettings [-VM] <VirtualMachine[]> [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VMStorageSetting[] Get_VMStorageSettings(Get_VMStorageSettingsArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMStorageSetting>("Get-VMStorageSettings", parameters);
        return result;
    }

    public class Get_VMSwitchArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which virtual switches are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the unique identifier of the virtual switch to be retrieved.
         */
        public Guid[]? Id { get; set; }

        /**
         * Specifies the name of the virtual switch to be retrieved.
         */
        public string? Name { get; set; }

        /**
         * Specifies the resource pool from which the virtual switches are to be retrieved.
         */
        public string[]? ResourcePoolName { get; set; }

        /**
         * Specifies the type of the virtual switches to be retrieved.
        Allowed values are **External**, **Internal**, and **Private**.
         */
        public VMSwitchType[]? SwitchType { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmswitch?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets virtual switches from one or more virtual Hyper-V hosts.
     * </summary>
     * <remarks>
     * The **Get-VMSwitch** cmdlet gets the virtual switches from a Hyper-V host. If you specify no parameters, this cmdlet returns all virtual switches from the local Hyper-V host.
     * </remarks>
     */
    public VMSwitch[] Get_VMSwitch(Get_VMSwitchArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.SwitchType is not null)
            parameters.Add("SwitchType", args.SwitchType);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitch>("Get-VMSwitch", parameters);
        return result;
    }

    public class Get_VMSwitchExtensionArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the extensions are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the extension to be retrieved.
         */
        public string[]? Name { get; set; }

        /**
         * Specifies the virtual switch from which the extensions are to be retrieved.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Specifies the name of the virtual switch from which the extensions are to be retrieved.
         */
        public required string[]? VMSwitchName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmswitchextension?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the extensions on one or more virtual switches.
     * </summary>
     * <remarks>
     * The **Get-VMSwitchExtension** cmdlet gets the extensions on one or more virtual switches. These extensions may be of different types, and may be either enabled or disabled. Output can be filtered by extension. The retrieved extension object does not contain embedded objects for features, or an array of feature IDs.
     * </remarks>
     */
    public VMSwitchExtension[] Get_VMSwitchExtension(Get_VMSwitchExtensionArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.VMSwitchName is not null)
            parameters.Add("VMSwitchName", args.VMSwitchName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitchExtension>(
            "Get-VMSwitchExtension",
            parameters
        );
        return result;
    }

    public class Get_VMSwitchExtensionPortDataArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the status of a virtual switch extension applied to a virtual network adapter is to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual switch extension for which status is to be retrieved.
         */
        public VMSwitchExtension[]? Extension { get; set; }

        /**
         * Specifies the name of the virtual switch extension for which status is to be retrieved.
         */
        public string[]? ExtensionName { get; set; }

        /**
         * Specifies the virtual switch port connected to the external network adapter.
         */
        public required SwitchParameter? ExternalPort { get; set; }

        /**
         * Specifies the unique identifier of the feature supported by the virtual switch extension.
         */
        public Guid[]? FeatureId { get; set; }

        /**
         * Specifies the name of the feature supported by the virtual switch extension.
         */
        public string[]? FeatureName { get; set; }

        /**
         * Specifies that the status is to be retrieved from the management (i.e.
        parent, or host) operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the name of the virtual switch.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        The cmdlet gets the status of the virtual switch extension for the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine network adapter.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual machine network adapter.
         */
        public string? VMNetworkAdapterName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmswitchextensionportdata?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Retrieves the status of a virtual switch extension feature applied to a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Get-VMSwitchExtensionPortData** cmdlet retrieves the status of a virtual switch extension feature applied to a virtual network adapter. This port feature data surfaces runtime information and statistics on a per-port basis.
     * </remarks>
     */
    public VMSwitchExtensionPortData[] Get_VMSwitchExtensionPortData(
        Get_VMSwitchExtensionPortDataArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Extension is not null)
            parameters.Add("Extension", args.Extension);
        if (args.ExtensionName is not null)
            parameters.Add("ExtensionName", args.ExtensionName);
        if (args.ExternalPort is not null)
            parameters.Add("ExternalPort", args.ExternalPort);
        if (args.FeatureId is not null)
            parameters.Add("FeatureId", args.FeatureId);
        if (args.FeatureName is not null)
            parameters.Add("FeatureName", args.FeatureName);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitchExtensionPortData>(
            "Get-VMSwitchExtensionPortData",
            parameters
        );
        return result;
    }

    public class Get_VMSwitchExtensionPortFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more virtual machine hosts on which the features configured on a virtual network adapter are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual switch extension.
         */
        public VMSwitchExtension[]? Extension { get; set; }

        /**
         * Specifies the name of the virtual switch extension.
         */
        public string[]? ExtensionName { get; set; }

        /**
         * Specifies the virtual switch port connected to the external network adapter.
         */
        public required SwitchParameter? ExternalPort { get; set; }

        /**
         * Specifies the unique identifier of the feature supported by the virtual switch extension.
         */
        public Guid[]? FeatureId { get; set; }

        /**
         * Specifies the name of the feature supported by the virtual switch extension.
         */
        public string[]? FeatureName { get; set; }

        /**
         * Specifies that the features are to be retrieved from the management (i.e.
        parent, or host) operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the name of the virtual switch.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies the virtual machine on which the features configured on a virtual switch are to be retrieved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine on which the features configured on a virtual switch are to be retrieved.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the network adapter.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the network adapter.
         */
        public string? VMNetworkAdapterName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmswitchextensionportfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the features configured on a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Get-VMSwitchExtensionPortFeature** cmdlet gets the features configured on a virtual network adapter.
     * </remarks>
     */
    public VMSwitchExtensionPortFeature[] Get_VMSwitchExtensionPortFeature(
        Get_VMSwitchExtensionPortFeatureArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Extension is not null)
            parameters.Add("Extension", args.Extension);
        if (args.ExtensionName is not null)
            parameters.Add("ExtensionName", args.ExtensionName);
        if (args.ExternalPort is not null)
            parameters.Add("ExternalPort", args.ExternalPort);
        if (args.FeatureId is not null)
            parameters.Add("FeatureId", args.FeatureId);
        if (args.FeatureName is not null)
            parameters.Add("FeatureName", args.FeatureName);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitchExtensionPortFeature>(
            "Get-VMSwitchExtensionPortFeature",
            parameters
        );
        return result;
    }

    public class Get_VMSwitchExtensionSwitchDataArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the status of a virtual switch extension is to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual switch extension for which status is to be retrieved.
         */
        public VMSwitchExtension[]? Extension { get; set; }

        /**
         * Specifies the name of the virtual switch extension for which status is to be retrieved.
         */
        public string[]? ExtensionName { get; set; }

        /**
         * Specifies the unique identifier of a feature supported by the virtual switch extension.
         */
        public Guid[]? FeatureId { get; set; }

        /**
         * Specifies the name of a feature supported by the virtual switch extension.
         */
        public string[]? FeatureName { get; set; }

        /**
         * Specifies the name of the virtual switch.
         */
        public required string[]? SwitchName { get; set; }

        /**
         * Specifies the virtual switch.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmswitchextensionswitchdata?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the status of a virtual switch extension feature applied on a virtual switch.
     * </summary>
     * <remarks>
     * The **Get-VMSwitchExtensionSwitchData** cmdlet gets the status of a virtual switch extension applied on a virtual switch. This switch feature data surfaces runtime information and statistics on a per-switch basis.
     * </remarks>
     */
    public void Get_VMSwitchExtensionSwitchData(Get_VMSwitchExtensionSwitchDataArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Extension is not null)
            parameters.Add("Extension", args.Extension);
        if (args.ExtensionName is not null)
            parameters.Add("ExtensionName", args.ExtensionName);
        if (args.FeatureId is not null)
            parameters.Add("FeatureId", args.FeatureId);
        if (args.FeatureName is not null)
            parameters.Add("FeatureName", args.FeatureName);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Get-VMSwitchExtensionSwitchData", parameters);
    }

    public class Get_VMSwitchExtensionSwitchFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the features configured on a virtual switch are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual switch extension.
         */
        public VMSwitchExtension[]? Extension { get; set; }

        /**
         * Specifies the name of the virtual switch extension.
         */
        public string[]? ExtensionName { get; set; }

        /**
         * Specifies the unique identifier of the feature.
         */
        public Guid[]? FeatureId { get; set; }

        /**
         * Specifies the name of the feature.
         */
        public string[]? FeatureName { get; set; }

        /**
         * Specifies the name of the virtual switch.
         */
        public required string[]? SwitchName { get; set; }

        /**
         * Specifies the virtual switch.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmswitchextensionswitchfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the features configured on a virtual switch.
     * </summary>
     * <remarks>
     * The **Get-VMSwitchExtensionSwitchFeature** cmdlet gets the features configured on a virtual switch. The object can be used to update the configuration of the switch using the Set-VmSwitchExtensionFeature command.
     * </remarks>
     */
    public VMSwitchExtensionSwitchFeature[] Get_VMSwitchExtensionSwitchFeature(
        Get_VMSwitchExtensionSwitchFeatureArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Extension is not null)
            parameters.Add("Extension", args.Extension);
        if (args.ExtensionName is not null)
            parameters.Add("ExtensionName", args.ExtensionName);
        if (args.FeatureId is not null)
            parameters.Add("FeatureId", args.FeatureId);
        if (args.FeatureName is not null)
            parameters.Add("FeatureName", args.FeatureName);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitchExtensionSwitchFeature>(
            "Get-VMSwitchExtensionSwitchFeature",
            parameters
        );
        return result;
    }

    public class Get_VMSwitchTeamArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual switch team that this cmdlet gets.
         */
        public string? Name { get; set; }

        /**
         *
         */
        public VMSwitch[]? VMSwitch { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmswitchteam?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Set-VMSwitchTeam.md">Set-VMSwitchTeam</see>
     * Gets virtual switch teams from Hyper-V hosts.
     * </summary>
     * <remarks>
     * The **Get-VMSwitchTeam** cmdlet gets virtual switch teams from one or more Hyper-V hosts.
     * </remarks>
     * <returns>This cmdlet returns a **VMSwitchTeam** object.</returns>
     */
    public VMSwitchTeam[] Get_VMSwitchTeam(Get_VMSwitchTeamArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitchTeam>("Get-VMSwitchTeam", parameters);
        return result;
    }

    public class Get_VMSystemSwitchExtensionArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the switch extensions are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the switch extension to be retrieved.
         */
        public string[]? Name { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmsystemswitchextension?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the switch extensions installed on a virtual machine host.
     * </summary>
     * <remarks>
     * The **Get-VMSystemSwitchExtension** cmdlet gets the switch extensions installed on a virtual machine host. The returned switch extension does not contain embedded objects for features or an array of feature IDs.
     * </remarks>
     */
    public VMSystemSwitchExtension[] Get_VMSystemSwitchExtension(
        Get_VMSystemSwitchExtensionArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSystemSwitchExtension>(
            "Get-VMSystemSwitchExtension",
            parameters
        );
        return result;
    }

    public class Get_VMSystemSwitchExtensionPortFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the available port-level features are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies one or more extension names for which the features are to be retrieved.
         */
        public string[]? ExtensionName { get; set; }

        /**
         * Specifies the unique identifier of the feature to be retrieved.
         */
        public Guid[]? FeatureId { get; set; }

        /**
         * Specifies the name of the feature to be retrieved.
         */
        public string[]? FeatureName { get; set; }

        /**
         * Specifies one or more system extensions for which the features are to be retrieved.
         */
        public VMSystemSwitchExtension[]? SystemSwitchExtension { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmsystemswitchextensionportfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the port-level features supported by virtual switch extensions on one or more Hyper-V hosts.
     * </summary>
     * <remarks>
     * The **Get-VMSystemSwitchExtensionPortFeature** cmdlet gets the port-level features supported by virtual switch extensions on one or more Hyper-V hosts. The returned feature object will contain default values for the feature. The object can be used to apply the configuration on specific ports using the Add-VmSwitchExtensionPortFeature command.
     * </remarks>
     */
    public void Get_VMSystemSwitchExtensionPortFeature(
        Get_VMSystemSwitchExtensionPortFeatureArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ExtensionName is not null)
            parameters.Add("ExtensionName", args.ExtensionName);
        if (args.FeatureId is not null)
            parameters.Add("FeatureId", args.FeatureId);
        if (args.FeatureName is not null)
            parameters.Add("FeatureName", args.FeatureName);
        if (args.SystemSwitchExtension is not null)
            parameters.Add("SystemSwitchExtension", args.SystemSwitchExtension);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Get-VMSystemSwitchExtensionPortFeature", parameters);
    }

    public class Get_VMSystemSwitchExtensionSwitchFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the switch-level features in an extension are to be retrieved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the extension from which the switch-level features are to be retrieved.
         */
        public string[]? ExtensionName { get; set; }

        /**
         * Specifies the unique identifier of the features are to be retrieved.
         */
        public Guid[]? FeatureId { get; set; }

        /**
         * Specifies the name of the switch-level features to be retrieved.
         */
        public string[]? FeatureName { get; set; }

        /**
         * Specifies the extension from which the switch-level features are to be retrieved.
         */
        public VMSystemSwitchExtension[]? SystemSwitchExtension { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmsystemswitchextensionswitchfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets the switch-level features on one or more Hyper-V hosts.
     * </summary>
     * <remarks>
     * The **Get-VMSystemSwitchExtensionSwitchFeature** cmdlet gets the switch-level features supported by virtual switch extensions in an extension on one or more Hyper-V hosts. The returned feature object will contain default values for the feature. The object can be used to apply the configuration on specific ports using the **Add-VMSwitchExtensionFeature** cmdlet.
     * </remarks>
     */
    public void Get_VMSystemSwitchExtensionSwitchFeature(
        Get_VMSystemSwitchExtensionSwitchFeatureArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ExtensionName is not null)
            parameters.Add("ExtensionName", args.ExtensionName);
        if (args.FeatureId is not null)
            parameters.Add("FeatureId", args.FeatureId);
        if (args.FeatureName is not null)
            parameters.Add("FeatureName", args.FeatureName);
        if (args.SystemSwitchExtension is not null)
            parameters.Add("SystemSwitchExtension", args.SystemSwitchExtension);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction(
            "Get-VMSystemSwitchExtensionSwitchFeature",
            parameters
        );
    }

    public class Get_VMVideoArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies an array of virtual machines for which this cmdlet gets video settings.
        To obtain a **VirtualMachine** object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines for which this cmdlet gets video settings.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies virtual machine checkpoint for which this cmdlet gets video settings.
        To obtain a **VMSnapshot** object, use the **Get-VMSnapshot** cmdlet.
        
         * Checkpoint replaces the previous term, snapshot.
         */
        public required VMSnapshot? VMSnapshot { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/get-vmvideo?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Set-VMVideo.md">Set-VMVideo</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     *
     * <see href="./Get-VMSnapshot.md">Get-VMSnapshot</see>
     * Gets video settings for virtual machines.
     * </summary>
     * <remarks>
     * The **Get-VMVideo** cmdlet gets the video settings for virtual machines.
     * </remarks>
     * <returns>This cmdlet returns a **VMVideo** object.</returns>
     */
    public VMVideo[] Get_VMVideo(Get_VMVideoArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMVideo>("Get-VMVideo", parameters);
        return result;
    }

    public class Grant_VMConnectAccessArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-v hosts which run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns a **Microsoft.HyperV.PowerShell.VMConnectAce** object.
        By default, this cmdlet does not return any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies a user or users to whom access to connect to a virtual machine or machines is to be granted.
         */
        public required string[]? UserName { get; set; }

        /**
         * Specifies the unique identifier of a virtual machine to which connect access is to be granted.
         */
        public required Guid[]? VMId { get; set; }

        /**
         * Specifies the name of a virtual machine to which connect access is to be granted.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/grant-vmconnectaccess?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Grants a user or users access to connect to a virtual machine or machines.
     * </summary>
     * <remarks>
     * The **Grant-VMConnectAccess** cmdlet grants access to a user or users to connect to a virtual machine or machines. The cmdlet is intended for use in providing other applications with the appropriate permissions required to initiate a session with Virtual Machine Connection. Examples of such applications are Virtual Machine Manager.
     * </remarks>
     */
    public void Grant_VMConnectAccess(Grant_VMConnectAccessArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.UserName is not null)
            parameters.Add("UserName", args.UserName);
        if (args.VMId is not null)
            parameters.Add("VMId", args.VMId);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Grant-VMConnectAccess", parameters);
    }

    public class Import_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies a compatibility report which resolves any incompatibilities between the virtual machine and the Hyper-V host.
         */
        public required VMCompatibilityReport? CompatibilityReport { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the virtual machine is to be imported.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies that the imported virtual machine's files should be copied to the server's default locations, as opposed to registering the virtual machine in-place.
         */
        public required SwitchParameter? Copy { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the imported virtual machine should be copied and given a new unique identifier.
        (By default, **Import-VM** gives the new virtual machine the same unique identifier as the imported virtual machine.)
         */
        public SwitchParameter? GenerateNewId { get; set; }

        /**
         * Specifies the path to the exported virtual machine to be imported.
         */
        public required string? Path { get; set; }

        /**
         * Specifies that the imported virtual machine is to be registered in-place, as opposed to copying its files to the server's default locations.
        Choose this option if the virtual machines files are already in the location from which they are to run.
         */
        public SwitchParameter? Register { get; set; }

        /**
         * Specifies the new path to use for a smart paging file, if one is needed.
         */
        public string? SmartPagingFilePath { get; set; }

        /**
         * Specifies the path for any snapshot files associated with the virtual machine.
         */
        public string? SnapshotFilePath { get; set; }

        /**
         * Specifies the folder to which the virtual machine's VHD files are to be copied.
         */
        public string? VhdDestinationPath { get; set; }

        /**
         * Specifies the folder from which the virtual machine's VHD files are to be copied.
         */
        public string? VhdSourcePath { get; set; }

        /**
         * Specifies the path where the virtual machine configuration files are to be stored.
         */
        public string? VirtualMachinePath { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/import-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Imports a virtual machine from a file.
     * </summary>
     * <remarks>
     * The **Import-VM** cmdlet imports a virtual machine from a file.
     * </remarks>
     */
    public VirtualMachine[] Import_VM(Import_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.CompatibilityReport is not null)
            parameters.Add("CompatibilityReport", args.CompatibilityReport);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Copy is not null)
            parameters.Add("Copy", args.Copy);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.GenerateNewId is not null)
            parameters.Add("GenerateNewId", args.GenerateNewId);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.Register is not null)
            parameters.Add("Register", args.Register);
        if (args.SmartPagingFilePath is not null)
            parameters.Add("SmartPagingFilePath", args.SmartPagingFilePath);
        if (args.SnapshotFilePath is not null)
            parameters.Add("SnapshotFilePath", args.SnapshotFilePath);
        if (args.VhdDestinationPath is not null)
            parameters.Add("VhdDestinationPath", args.VhdDestinationPath);
        if (args.VhdSourcePath is not null)
            parameters.Add("VhdSourcePath", args.VhdSourcePath);
        if (args.VirtualMachinePath is not null)
            parameters.Add("VirtualMachinePath", args.VirtualMachinePath);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Import-VM", parameters);
        return result;
    }

    public class Import_VMInitialReplicationArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which initial replication files are to be imported.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns a **Microsoft.HyperV.PowerShell.VirtualMachine** object.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path of the initial replication files to import.
         */
        public required string? Path { get; set; }

        /**
         * Specifies the virtual machine for which the initial replication files are to be imported.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine for which the initial replication files are to be imported.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine replication object for which initial replication files are to be imported.
         */
        public required VMReplication[]? VMReplication { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/import-vminitialreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Imports initial replication files for a Replica virtual machine to complete the initial replication when using external media as the source.
     * </summary>
     * <remarks>
     * The **Import-VMInitialReplication** cmdlet imports initial replication files on a Replica server. It completes the initial replication of a virtual machine when external is used as the source of the files for initial replication.
     * </remarks>
     */
    public void Import_VMInitialReplication(Import_VMInitialReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMReplication is not null)
            parameters.Add("VMReplication", args.VMReplication);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Import-VMInitialReplication", parameters);
    }

    public class Measure_VMArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more virtual machine hosts for which resource utilization is to be reported.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the friendly name of the virtual machine whose resource utilization data will be reported.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the virtual machine whose resource utilization will be reported.
         */
        public required VirtualMachine[]? VM { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/measure-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Add-VMNetworkAdapterAcl.md">Add-VMNetworkAdapterAcl</see>
     *
     * <see href="./Disable-VMResourceMetering.md">Disable-VMResourceMetering</see>
     *
     * <see href="./Enable-VMResourceMetering.md">Enable-VMResourceMetering</see>
     *
     * <see href="./Remove-VMNetworkAdapterAcl.md">Remove-VMNetworkAdapterAcl</see>
     *
     * <see href="./Reset-VMResourceMetering.md">Reset-VMResourceMetering</see>
     * Reports resource utilization data for one or more virtual machines.
     * </summary>
     * <remarks>
     * The **Measure-VM** cmdlet reports data on processor usage, memory usage, network traffic, and disk capacity for one or more virtual machines.
    
    Note: Data is available for reporting through the **Measure-VM** cmdlet only after resource metering is enabled for a virtual machine.
    
    The report has the following fields:
    
    -- ComputerName: The name of the virtual machine host.
    
    -- VMId: The unique identifier of the virtual machine.
    
    -- VMName: The friendly name of the virtual machine.
    
    -- HardDiskMetrics: Information about the performance and throughput of the storage subsystem.
    
    -- MeteringDuration: The duration over which resource utilization data is being reported.
    
    -- AverageProcessorUsage: The average processor usage, in megahertz, of the virtual machine over the period reported in the MeteringDuration field.
    
    -- AverageMemoryUsage: The average memory usage, in megabytes, of the virtual machine over the period reported in the MeteringDuration field.
    
    -- MaximumMemoryUsage: The maximum memory usage, in megabytes, of the virtual machine over the period reported in the MeteringDuration field.
    
    -- MinimumMemoryUsage: The minimum memory usage, in megabytes, of the virtual machine over the time period reported in the MeteringDuration field.
    
    -- TotalDiskAllocation: The maximum disk capacity, in megabytes, allocated to the virtual machine over the time period reported in the MeteringDuration field. For more information, see the 'Notes' following the field descriptions.
    
    -- NetworkMeteredTrafficReport: An array whose elements report the traffic through each NetworkAdapterAcl on the virtual machine or machines over the time period reported in the MeteringDuration field. Each array element has the following properties:
    
    -- NetworkAdapter: The virtual machine network adapter object on which the NetworkAdapterAcl has been configured.
    
    -- LocalAddress: for an inbound packet, the destination IP address in the packet header; for an outbound packet, the source IP address in the packet header.
    
    -- RemoteAddress: for an inbound packet, the source IP address in the packet header; for an outbound packet, the destination IP address in the packet header.
    
    -- Direction: the direction of the network traffic to which the ACL applies. Allowed values are Inbound, Outbound, or Both.
    
    -- TotalTraffic: the amount of network traffic, in megabytes, through the NetworkAdapterAcl.
    
    Notes:
    
    -- The disk capacity allocated to the virtual machine is reported as the sum of two totals -- the total storage capacity of all attached virtual hard disks, and the total amount of physical storage consumed by the virtual machine's snapshots.
    
    -- If the virtual machine has more than one virtual hard disk, then the TotalDiskAllocation property displays the sum of disk capacity allocated to all virtual hard disks.
    
    -- Resource utilization is not reported for disks attached through a virtual Fiber Channel connection or network adapters configured to use single-root I/O virtualization (SR-IOV).
    
    -- If the virtual machine is configured with static memory rather than Dynamic Memory, then AverageMemoryUsage, MinimumMemoryUsage, and MaximumMemoryUsage metrics equals the memory amount configured for the virtual machine.
    
    The default display of a resource pool resource utilization report includes the following columns:
    
    -- VMName: The name of the virtual machine.
    
    -- AvgCPU(Mhz): The average processor usage, in megahertz, of the virtual machine.
    
    -- TotalDisk(M): The average disk usage, in megabytes, of the virtual machine. For more information, see the 'Notes' following the field descriptions.
    
    -- NetworkInbound(M): Total incoming network traffic, in megabytes, to the virtual machine.
    
    -- NetworkOutbound(M): Total outgoing network traffic, in megabytes, from the virtual machine.
     * </remarks>
     */
    public VMMeteringReportForVirtualMachine[] Measure_VM(Measure_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMMeteringReportForVirtualMachine>(
            "Measure-VM",
            parameters
        );
        return result;
    }

    public class Measure_VMReplicationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which to get replication statistics.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of a primary server.
        Replication statistics are retrieved for all virtual machines from the specified primary server.
         */
        public string? PrimaryServerName { get; set; }

        /**
         * Specifies the name of a Replica server of the virtual machines whose replication statistics you want to get.
         */
        public string? ReplicaServerName { get; set; }

        /**
         * Specifies the replication health of the virtual machines whose replication statistics you want to get.
        Valid values are "Critical", "Warning", "Normal", and "NotApplicable".
         */
        public VMReplicationHealthState? ReplicationHealth { get; set; }

        /**
         * Specifies the replication mode of the virtual machines whose replication statistics you want to get.
        Valid values are "None", "Primary", "Replica", "TestReplica" and "ExtendedReplica"
         */
        public VMReplicationMode? ReplicationMode { get; set; }

        /**
         * Specifies the replication relationship type of the virtual machine.
        Specify whether the replication relationship is a simple primary to replica or is an extended replication chain.
        The cmdlet gets replication statistics and information associated with the virtual machines that have the replication type that you specify.
         */
        public VMReplicationRelationshipType? ReplicationRelationshipType { get; set; }

        /**
         * Specifies the replication state of the virtual machines for which you want to get replication statistics.
        Valid values are:
        
         * - Error
        - FailOverWaitingCompletion
        - FailedOver
        - NotApplicable
        - ReadyForInitialReplication
        - Replicating
        - Resynchronizing
        - ResynchronizeSuspended
        - Suspended
        - SyncedReplicationComplete
        - WaitingForInitialReplication
        - WaitingForStartResynchronize
         */
        public VMReplicationState? ReplicationState { get; set; }

        /**
         * Specifies a trust group associated with the virtual machines whose replication statistics you want to get.
         */
        public string? TrustGroup { get; set; }

        /**
         * Specifies the virtual machine for which you want to get replication statistics.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine for which you want to get virtual machine replication statistics.
         */
        public string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/measure-vmreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Gets replication statistics and information associated with a virtual machine.
     * </summary>
     * <remarks>
     * The **Measure-VMReplication** cmdlet gets replication statistics and information associated with virtual machine. Replication statistics are calculated for a predetermined amount of time based on the monitoring interval specified through the **Set-VMReplicationServer** cmdlet.
     * </remarks>
     */
    public VMReplicationHealth[] Measure_VMReplication(Measure_VMReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.PrimaryServerName is not null)
            parameters.Add("PrimaryServerName", args.PrimaryServerName);
        if (args.ReplicaServerName is not null)
            parameters.Add("ReplicaServerName", args.ReplicaServerName);
        if (args.ReplicationHealth is not null)
            parameters.Add("ReplicationHealth", args.ReplicationHealth);
        if (args.ReplicationMode is not null)
            parameters.Add("ReplicationMode", args.ReplicationMode);
        if (args.ReplicationRelationshipType is not null)
            parameters.Add("ReplicationRelationshipType", args.ReplicationRelationshipType);
        if (args.ReplicationState is not null)
            parameters.Add("ReplicationState", args.ReplicationState);
        if (args.TrustGroup is not null)
            parameters.Add("TrustGroup", args.TrustGroup);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMReplicationHealth>(
            "Measure-VMReplication",
            parameters
        );
        return result;
    }

    public class Measure_VMResourcePoolArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more virtual machine hosts for which resource utilization is to be reported.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the friendly name of the resource pool for which resource utilization is to be reported.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the resource type of the virtual machine resource pool for which resource utilization is to be reported.
        Valid values are:
        
         * - Ethernet
        - Memory
        - Processor
        - VHD
         */
        public VMResourcePoolType[]? ResourcePoolType { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/measure-vmresourcepool?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Add-VMNetworkAdapterAcl.md">Add-VMNetworkAdapterAcl</see>
     *
     * <see href="./Disable-VMResourceMetering.md">Disable-VMResourceMetering</see>
     *
     * <see href="./Enable-VMResourceMetering.md">Enable-VMResourceMetering</see>
     *
     * <see href="./Remove-VMNetworkAdapterAcl.md">Remove-VMNetworkAdapterAcl</see>
     *
     * <see href="./Reset-VMResourceMetering.md">Reset-VMResourceMetering</see>
     * Reports resource utilization data for one or more resource pools.
     * </summary>
     * <remarks>
     * The **Measure-VMResourcePool** cmdlet reports data on processor usage, memory usage, network traffic, and disk capacity for one or more virtual machine resource pools.
    
    Note: Data is available for reporting by the **Measure-VMResourcePool** cmdlet only after resource metering is enabled for the virtual machine resource pool or pools.
    
    This cmdlet can also be called with an array of resource pools with the same name. In this case, resource utilization data for different resource types will be aggregated in a single report.
    
    The report has the following fields:
    
    -- ComputerName: The name of the virtual machine host.
    
    -- ResourcePoolType: The type of the virtual machine resource pool.
    
    -- ResourcePoolName: The name of the resource pool.
    
    -- MeteringDuration: The duration over which resource utilization data is being reported.
    
    -- AverageProcessorUsage: The sum of the average processor usage, in megahertz, of the virtual machines under the specified resource pool over the time period reported in the MeteringDuration field.
    
    -- AverageMemoryUsage: The sum of the average memory usage, in megabytes, of the virtual machines under the specified resource pool over the time period reported in the MeteringDuration field.
    
    -- MaximumMemoryUsage: The maximum memory usage, in megabytes, of any virtual machine under the specified resource pool over the time period reported in the MeteringDuration field.
    
    -- MinimumMemoryUsage: The minimum memory usage, in megabytes, of any virtual machine under the specified resource pool over the time period reported in the MeteringDuration field.
    
    -- TotalDiskAllocation: The maximum disk capacity, in gigabytes, allocated to any virtual machine under the specified resource pool over the time period reported in the MeteringDuration field.
    
    -- NetworkMeteredTrafficReport: An array whose elements report the traffic through each NetworkAdapterAcl on the virtual machines under the specified resource pool over the time period reported in the MeteringDuration field.
    
    Each array element has the following properties:
    
    -- LocalAddress: for an inbound packet, the destination IP address in the packet header; for an outbound packet, the source IP address in the packet header.
    
    -- RemoteAddress: for an inbound packet, the source IP address in the packet header; for an outbound packet, the destination IP address in the packet header.
    
    -- Direction: the direction of the network traffic to which the ACL applies. Allowed values are Inbound, Outbound, or Both.
    
    -- TotalTraffic: the amount of network traffic, in megabytes, through the NetworkAdapterAcl.
    
    Notes:
    
    -- The disk capacity allocated to the virtual machine is reported as the sum of the virtual capacity of the virtual machine's virtual hard disks, together with the sum of the physical disk capacity of the virtual machine's virtual hard disk snapshots.
    
    -- Resource utilization information is not available for resource pool types of FiberChannelConnection, FibreChannelPort, VFD, and ISO.
    
    -- If the virtual machines under the specified resource pool are configured with the same values for LocalAddress, RemoteAddress, and Direction, the information from each of these NetworkAdapterAcl objects is aggregated in the TotalTraffic property specified by the NetworkMeteredTrafficReport of the object returned by the **Measure-VMResourcePool** cmdlet.
    
    Default display of a resource pool resource utilization report includes the following columns:
    
    -- Name: the name of the resource pool.
    
    -- ResourcePoolType: the type of the virtual machine resource pool.
    
    --AvgCPU(Mhz): the sum of the average processor usage, in megahertz, of the virtual machines under the specified resource pool.
    
    -- AvgRAM(M): the sum of the average memory usage, in megabytes, of the virtual machines under the specified resource pool.
    
    -- TotalDisk(G): the maximum disk capacity, in gigabytes, allocated to any virtual machine under the specified resource pool.
    
    -- NetworkInbound(M): total incoming traffic, in megabytes, to the virtual machines under the specified resource pool.
    
    -- NetworkOutbound(M): total outgoing network traffic, in megabytes, to the virtual machines under the specified resource pool.
     * </remarks>
     */
    public VMMeteringReportForResourcePool[] Measure_VMResourcePool(
        Measure_VMResourcePoolArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMMeteringReportForResourcePool>(
            "Measure-VMResourcePool",
            parameters
        );
        return result;
    }

    public class Merge_VHDArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which virtual hard disks are to be merged.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the path to the child in the virtual hard disk chain that is the destination for the merge command.
         */
        public string? DestinationPath { get; set; }

        /**
         * Runs the cmdlet without prompting for confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the merged virtual hard disk.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to the child in the virtual hard disk chain that is the source for the merge command.
        If a filename or relative path is specified, the virtual hard disk path will be calculated relative to the current working directory.
         */
        public required string? Path { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/merge-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Merges virtual hard disks.
     * </summary>
     * <remarks>
     * The **Merge-VHD** cmdlet merges virtual hard disks in a differencing virtual hard disk chain. The merge is from a specified source child disk to a specified destination child disk.
    
    Merge is an offline operation; the virtual hard disk chain must not be attached when merge is initiated.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Merge_VHD(Merge_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DestinationPath is not null)
            parameters.Add("DestinationPath", args.DestinationPath);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Merge-VHD",
            parameters
        );
        return result;
    }

    public class Mount_VHDArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual hard disk is to be mounted.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the virtual hard disk is to be mounted without assigning drive letters to the volumes contained within the virtual hard disk.
         */
        public SwitchParameter? NoDriveLetter { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual hard disk to be mounted.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to the virtual hard disk file for the virtual hard disk to be mounted.
        If a filename or relative path is specified, the virtual hard disk path is calculated relative to the current working directory.
         */
        public required string[]? Path { get; set; }

        /**
         * Specifies that the virtual hard disk is to be mounted in read-only mode.
         */
        public SwitchParameter? ReadOnly { get; set; }

        /**
         * Specifies the unique ID of a VHD set.
         */
        public Guid? SnapshotId { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/mount-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="/powershell/module/storage/mount-diskimage">Mount-DiskImage</see>
     * Mounts one or more virtual hard disks.
     * </summary>
     * <remarks>
     * The **Mount-VHD** cmdlet mounts one or more virtual hard disks.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Mount_VHD(Mount_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.NoDriveLetter is not null)
            parameters.Add("NoDriveLetter", args.NoDriveLetter);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.ReadOnly is not null)
            parameters.Add("ReadOnly", args.ReadOnly);
        if (args.SnapshotId is not null)
            parameters.Add("SnapshotId", args.SnapshotId);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Mount-VHD",
            parameters
        );
        return result;
    }

    public class Mount_VMHostAssignableDeviceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the assignable devices are to be mounted. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the assignable device to be mounted on the virtual machine host.
         */
        public required VMHostAssignableDevice[]? HostAssignableDevice { get; set; }

        /**
         * Represents the Device Instance path in the host machine.
         */
        public string? InstancePath { get; set; }

        /**
         * Specifies the location path to the assignable device.
         */
        public string? LocationPath { get; set; }

        /**
         * Returns an object for each process that the cmdlet started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/mount-vmhostassignabledevice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="add-vmhostassignabledevice.md">Add-VMHostAssignableDevice</see>
     *
     * <see href="get-vmhostassignabledevice.md">Get-VMHostAssignableDevice</see>
     *
     * <see href="dismount-vmhostassignabledevice.md">Dismount-VMHostAssignableDevice</see>
     *
     * <see href="remove-vmhostassignabledevice.md">Remove-VMHostAssignableDevice</see>
     * Mounts a device to a virtual machine (VM) host.
     * </summary>
     * <remarks>
     * The `Mount-VMHostAssignableDevice` cmdlet mounts a device such as GPUs, network adapters, or storage controllers that are physically present on the virtual machine host.
     * </remarks>
     */
    public VMHostAssignableDevice[] Mount_VMHostAssignableDevice(
        Mount_VMHostAssignableDeviceArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.HostAssignableDevice is not null)
            parameters.Add("HostAssignableDevice", args.HostAssignableDevice);
        if (args.InstancePath is not null)
            parameters.Add("InstancePath", args.InstancePath);
        if (args.LocationPath is not null)
            parameters.Add("LocationPath", args.LocationPath);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHostAssignableDevice>(
            "Mount-VMHostAssignableDevice",
            parameters
        );
        return result;
    }

    public class Move_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies a compatibility report which includes any adjustments required for the move.
         */
        public required VMCompatibilityReport? CompatibilityReport { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the **CIMSession** on the Hyper-V host to which the virtual machine is to be moved.
         */
        public required CimSession? DestinationCimSession { get; set; }

        /**
         * Specifies a user account that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential? DestinationCredential { get; set; }

        /**
         * Specifies the Hyper-V host to which the virtual machine is to be moved.
         */
        public required string? DestinationHost { get; set; }

        /**
         * Specifies a destination path to which all virtual machine data is to be moved.
         */
        public string? DestinationStoragePath { get; set; }

        /**
         * Specifies that both the virtual machine and its storage are to be moved.
         */
        public SwitchParameter? IncludeStorage { get; set; }

        /**
         * Specifies the friendly name of the virtual machine to be moved.
         */
        public required string? Name { get; set; }

        /**
         * Specifies that an object is to be passed through to be pipeline representing the moved virtual machine.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Indicates that Hyper-V deletes the parent virtual hard disk on the source after this cmdlet moves a differencing virtual hard disk, when the migration is finished.
         */
        public SwitchParameter? RemoveSourceUnmanagedVhds { get; set; }

        /**
         * Specifies the name of the processor resource pool to be used.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Indicates that this cmdlet retains parent virtual hard disks on the source computer.
         */
        public SwitchParameter? RetainVhdCopiesOnSource { get; set; }

        /**
         * Specifies the new path to use for a smart paging file, if one is needed.
         */
        public string? SmartPagingFilePath { get; set; }

        /**
         * Specifies the path for any snapshot files associated with the virtual machine.
         */
        public string? SnapshotFilePath { get; set; }

        /**
         * Specifies an array of hashtables that contain locations for each individual virtual hard disk to be moved.
        Each hashtable should have two entries.
        The first entry specifies the current location of the virtual hard disk to move, and has a key of **SourceFilePath**.
        The second entry specifies the new location for the virtual hard disk, and has a key of **DestinationFilePath**.
        The virtual hard disk name must be identical in both entries.
         */
        public Hashtable[]? Vhds { get; set; }

        /**
         * Specifies the path where the virtual machine configuration files are to be stored.
         */
        public required string? VirtualMachinePath { get; set; }

        /**
         * Specifies the virtual machine to be moved.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/move-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Moves a virtual machine to a new Hyper-V host.
     * </summary>
     * <remarks>
     * The **Move-VM** cmdlet moves a virtual machine to a new Hyper-V host.
     * </remarks>
     */
    public void Move_VM(Move_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.CompatibilityReport is not null)
            parameters.Add("CompatibilityReport", args.CompatibilityReport);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DestinationCimSession is not null)
            parameters.Add("DestinationCimSession", args.DestinationCimSession);
        if (args.DestinationCredential is not null)
            parameters.Add("DestinationCredential", args.DestinationCredential);
        if (args.DestinationHost is not null)
            parameters.Add("DestinationHost", args.DestinationHost);
        if (args.DestinationStoragePath is not null)
            parameters.Add("DestinationStoragePath", args.DestinationStoragePath);
        if (args.IncludeStorage is not null)
            parameters.Add("IncludeStorage", args.IncludeStorage);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RemoveSourceUnmanagedVhds is not null)
            parameters.Add("RemoveSourceUnmanagedVhds", args.RemoveSourceUnmanagedVhds);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.RetainVhdCopiesOnSource is not null)
            parameters.Add("RetainVhdCopiesOnSource", args.RetainVhdCopiesOnSource);
        if (args.SmartPagingFilePath is not null)
            parameters.Add("SmartPagingFilePath", args.SmartPagingFilePath);
        if (args.SnapshotFilePath is not null)
            parameters.Add("SnapshotFilePath", args.SnapshotFilePath);
        if (args.Vhds is not null)
            parameters.Add("Vhds", args.Vhds);
        if (args.VirtualMachinePath is not null)
            parameters.Add("VirtualMachinePath", args.VirtualMachinePath);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Move-VM", parameters);
    }

    public class Move_VMStorageArguments
    {
        /**
         * Allows the move operation to be attempted even if the paths specified for the destination computer cannot be verified prior to attempting the move operation.
         */
        public SwitchParameter? AllowUnverifiedPaths { get; set; }

        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more virtual machine hosts on which the virtual machine storage is to be moved.
        NetBIOS names, IP addresses, and fully-qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies a destination storage path to which all virtual machine storage is to be moved.
         */
        public required string? DestinationStoragePath { get; set; }

        /**
         * Specifies a name.
         */
        public required string? Name { get; set; }

        /**
         * Indicates that Hyper-V deletes the parent virtual hard disk on the source after this cmdlet moves a differencing virtual hard disk, when the migration is finished.
         */
        public SwitchParameter? RemoveSourceUnmanagedVhds { get; set; }

        /**
         * Specifies the name of the storage resource pool to use after the move operation is complete.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Specify **$true** to keep any parent virtual hard disks on the source computer.
        If not specified, all virtual hard disks will be removed from the source computer once the virtual machine is successfully moved.
         */
        public SwitchParameter? RetainVhdCopiesOnSource { get; set; }

        /**
         * Specifies the new path to use for a smart paging file, if one is needed.
         */
        public string? SmartPagingFilePath { get; set; }

        /**
         * Specifies the new path for any snapshot files associated with the virtual machine.
         */
        public string? SnapshotFilePath { get; set; }

        /**
         * Specifies an array of hashtables that contain locations for each individual virtual hard disk to be moved.
        Each hashtable should have two entries.
        The first entry specifies the current location of the virtual hard disk to move, and has a key of SourceFilePath.
        The second entry specifies the new location for the virtual hard disk, and has a key of DestinationFilePath.
        The virtual hard disk name must be identical in both entries.
         */
        public Hashtable[]? Vhds { get; set; }

        /**
         * Specifies the path to the virtual machine configuration file and associated memory files.
         */
        public string? VirtualMachinePath { get; set; }

        /**
         * Specifies the virtual machine whose storage is to be moved.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/move-vmstorage?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Moves the storage of a virtual machine.
     * </summary>
     * <remarks>
     * The **Move-VMStorage** cmdlet moves the storage of a virtual machine.
     * </remarks>
     */
    public void Move_VMStorage(Move_VMStorageArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowUnverifiedPaths is not null)
            parameters.Add("AllowUnverifiedPaths", args.AllowUnverifiedPaths);
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DestinationStoragePath is not null)
            parameters.Add("DestinationStoragePath", args.DestinationStoragePath);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.RemoveSourceUnmanagedVhds is not null)
            parameters.Add("RemoveSourceUnmanagedVhds", args.RemoveSourceUnmanagedVhds);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.RetainVhdCopiesOnSource is not null)
            parameters.Add("RetainVhdCopiesOnSource", args.RetainVhdCopiesOnSource);
        if (args.SmartPagingFilePath is not null)
            parameters.Add("SmartPagingFilePath", args.SmartPagingFilePath);
        if (args.SnapshotFilePath is not null)
            parameters.Add("SnapshotFilePath", args.SnapshotFilePath);
        if (args.Vhds is not null)
            parameters.Add("Vhds", args.Vhds);
        if (args.VirtualMachinePath is not null)
            parameters.Add("VirtualMachinePath", args.VirtualMachinePath);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Move-VMStorage", parameters);
    }

    public class New_VFDArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967)
        or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more virtual machine hosts on which the virtual floppy disk is to be created.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable. The default is the
        local computer. Use `localhost` or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the path to the new virtual floppy disk files to be created.
         */
        public required string[]? Path { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet isn't run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/new-vfd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="set-vmfloppydiskdrive.md">Set-VMFloppyDiskDrive</see>
     * Creates a virtual floppy disk.
     * </summary>
     * <remarks>
     * The `New-VFD` cmdlet creates a new virtual floppy disk.
     * </remarks>
     */
    public System.IO.FileInfo[] New_VFD(New_VFDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<System.IO.FileInfo>("New-VFD", parameters);
        return result;
    }

    public class New_VHDArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Specifies the block size, in bytes, of the virtual hard disk to be created.
         */
        public UInt32? BlockSizeBytes { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual hard disk file(s) are to be created.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a differencing virtual hard disk is to be created.
         */
        public SwitchParameter? Differencing { get; set; }

        /**
         * Specifies that a dynamic virtual hard disk is to be created.
         */
        public SwitchParameter? Dynamic { get; set; }

        /**
         * Specifies that a fixed virtual hard disk is to be created.
         */
        public required SwitchParameter? Fixed { get; set; }

        /**
         * Specifies the logical sector size, in bytes, of the virtual hard disk to be created.
        Valid values are 512 and 4096.
         */
        public UInt32? LogicalSectorSizeBytes { get; set; }

        /**
         * Specifies the path to the parent of the differencing disk to be created (this parameter may be specified only for the creation of a differencing disk).
         */
        public required string? ParentPath { get; set; }

        /**
         * Path to the new virtual hard disk file(s) that is being created as a result of a command.
        If a filename or relative path is specified, the new virtual hard disk path is calculated relative to the current working directory.
         */
        public required string[]? Path { get; set; }

        /**
         * Specifies the physical sector size, in bytes.
        Valid values are 512 and 4096.
         */
        public UInt32? PhysicalSectorSizeBytes { get; set; }

        /**
         * The maximum size, in bytes, of the virtual hard disk to be created.
         */
        public required UInt64? SizeBytes { get; set; }

        /**
         * Specifies the physical disk to be used as the source for the virtual hard disk to be created.
         */
        public required UInt32? SourceDisk { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/new-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Creates one or more new virtual hard disks.
     * </summary>
     * <remarks>
     * The **New-VHD** cmdlet creates one or more new virtual hard disks in either VHD format or the newer VHDX format. The file name extension you specify determines the format.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] New_VHD(New_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.BlockSizeBytes is not null)
            parameters.Add("BlockSizeBytes", args.BlockSizeBytes);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Differencing is not null)
            parameters.Add("Differencing", args.Differencing);
        if (args.Dynamic is not null)
            parameters.Add("Dynamic", args.Dynamic);
        if (args.Fixed is not null)
            parameters.Add("Fixed", args.Fixed);
        if (args.LogicalSectorSizeBytes is not null)
            parameters.Add("LogicalSectorSizeBytes", args.LogicalSectorSizeBytes);
        if (args.ParentPath is not null)
            parameters.Add("ParentPath", args.ParentPath);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.PhysicalSectorSizeBytes is not null)
            parameters.Add("PhysicalSectorSizeBytes", args.PhysicalSectorSizeBytes);
        if (args.SizeBytes is not null)
            parameters.Add("SizeBytes", args.SizeBytes);
        if (args.SourceDisk is not null)
            parameters.Add("SourceDisk", args.SourceDisk);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "New-VHD",
            parameters
        );
        return result;
    }

    public class New_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Specifies the device to use as the boot device for the new virtual machine. Acceptable values are:
        
         * - `CD`
        - `Floppy`
        - `LegacyNetworkAdapter`
        - `IDE`
        - `NetworkAdapter`
        - `VHD`
        
         * When `LegacyNetworkAdapter` is specified, this configures the new virtual machine with a network
        adapter that can be used to perform a PXE boot and install a 32-bit operating system from a network
        installation server.
        
         * Generation 2 virtual machines do not support `Floppy`, `LegacyNetworkAdapter` or `IDE`. Using these
        values with a Generation 2 virtual machine will cause an error.
        
         * `VHD` and `NetworkAdapter` are new to Generation 2 virtual machines. If you specify them on a
        Generation 1 virtual machine, then they are interpreted to be `IDE` and `LegacyNetworkAdapter`
        respectively.
         */
        public BootDevice? BootDevice { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession) or
        [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine is to be created. NetBIOS names,
        IP addresses, and fully qualified domain names are allowable. The default is the local computer.
        Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specific prerelease VM version 255.0. This parameter is used to experiment with new VM
        functionality, but this is not supported and may fail across updates. This VM version is not
        supported in release host builds, meaning you can only use this on pre-release host builds (Windows
        Insider program).
         */
        public SwitchParameter? Experimental { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies the generation, as an integer, for the virtual machine. Acceptable values are:
        
         * - `1`
        - `2`
         */
        public Int16? Generation { get; set; }

        /**
         * Specifies the level of isolation for the virtual machine being created. Acceptable values are:
        
         * - `TrustedLaunch`: Enables guest state isolation and Trusted Launch security features for the
          virtual machine.
        - `VBS`: Enables Virtualization Based Security (VBS) isolation for the virtual machine.
        - `SNP`: Enables AMD Secure Encrypted Virtualization-Secure Nested Paging (SEV-SNP) isolation for
          the virtual machine.
        - `TDX`: Enables Intel Trust Domain Extensions (TDX) isolation for the virtual machine.
        - `Disabled`: Disables all guest state isolation features for the virtual machine.
         */
        public GuestIsolationType? GuestStateIsolationType { get; set; }

        /**
         * Specifies the amount of memory, in bytes, to assign to the virtual machine. The default value is
        `512 MB`.
         */
        public Int64? MemoryStartupBytes { get; set; }

        /**
         * Specifies the name of the new virtual machine. The default name is New virtual machine.
         */
        public string? Name { get; set; }

        /**
         * Creates a new virtual hard disk with the specified path and connects it to the new virtual machine.
        Absolute paths are allowed. If only a file name is specified, the virtual hard disk is created in
        the default path configured for the host.
         */
        public required string? NewVHDPath { get; set; }

        /**
         * Specifies the size of the dynamic virtual hard disk that is created and attached to the new virtual
        machine.
         */
        public required UInt64? NewVHDSizeBytes { get; set; }

        /**
         * Creates a virtual machine without attaching any virtual hard disks.
         */
        public SwitchParameter? NoVHD { get; set; }

        /**
         * Specifies the directory to store the files for the new virtual machine.
         */
        public string? Path { get; set; }

        /**
         * Specific prerelease VM version 254.0. This parameter is used to experiment with new VM
        functionality, but this is not supported and may fail across updates. This VM version is not
        supported in release host builds, meaning you can only use this on pre-release host builds (Windows
        Insider program).
         */
        public SwitchParameter? Prerelease { get; set; }

        /**
         * Specifies the path to the guest state file for the virtual machine being created. Specifying the
        guest state path allows for creation of a new virtual machine that has the same configuration and
        state as the existing virtual machine.
         */
        public string? SourceGuestStatePath { get; set; }

        /**
         * Specifies the friendly name of the virtual switch if you want to connect the new virtual machine to
        an existing virtual switch to provide connectivity to a network. Hyper-V automatically creates a
        virtual machine with one virtual network adapter, but connecting it to a virtual switch is
        optional.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies the version during the VM creation process. See,
        [Get-VMHostSupportedVersion](/powershell/module/hyper-v/get-vmhostsupportedversion) for supported
        VM versions on a given host.
         */
        public Version? Version { get; set; }

        /**
         * Specifies the path to a virtual hard disk file.
         */
        public required string? VHDPath { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/new-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Creates a new virtual machine.
     * </summary>
     * <remarks>
     * The `New-VM` cmdlet creates a new virtual machine.
     * </remarks>
     */
    public VirtualMachine[] New_VM(New_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.BootDevice is not null)
            parameters.Add("BootDevice", args.BootDevice);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Experimental is not null)
            parameters.Add("Experimental", args.Experimental);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.Generation is not null)
            parameters.Add("Generation", args.Generation);
        if (args.GuestStateIsolationType is not null)
            parameters.Add("GuestStateIsolationType", args.GuestStateIsolationType);
        if (args.MemoryStartupBytes is not null)
            parameters.Add("MemoryStartupBytes", args.MemoryStartupBytes);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NewVHDPath is not null)
            parameters.Add("NewVHDPath", args.NewVHDPath);
        if (args.NewVHDSizeBytes is not null)
            parameters.Add("NewVHDSizeBytes", args.NewVHDSizeBytes);
        if (args.NoVHD is not null)
            parameters.Add("NoVHD", args.NoVHD);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.Prerelease is not null)
            parameters.Add("Prerelease", args.Prerelease);
        if (args.SourceGuestStatePath is not null)
            parameters.Add("SourceGuestStatePath", args.SourceGuestStatePath);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.Version is not null)
            parameters.Add("Version", args.Version);
        if (args.VHDPath is not null)
            parameters.Add("VHDPath", args.VHDPath);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("New-VM", parameters);
        return result;
    }

    public class New_VMGroupArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the type of group that this cmdlet creates.
        The acceptable values for this parameter are: ManagementCollectionType and VMCollectionType.
         */
        public required GroupType? GroupType { get; set; }

        /**
         * Specifies the unique ID of the group that this cmdlet creates.
         */
        public Guid? Id { get; set; }

        /**
         * Specifies the name for the group that this cmdlet creates.
         */
        public required string? Name { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/new-vmgroup?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMGroup.md">Get-VMGroup</see>
     *
     * <see href="./Remove-VMGroup.md">Remove-VMGroup</see>
     *
     * <see href="./Rename-VMGroup.md">Rename-VMGroup</see>
     *
     * <see href="./Add-VMGroupMember.md">Add-VMGroupMember</see>
     * Creates a virtual machine group.
     *
     * With Hyper-V, there are two types of VMGroups: a VMCollectionType and a ManagementCollectionType.
     * A VMCollectionType VMGroup contains VMs while the ManagementCollectionType VMGroup contains VMCollectionType VMGroups.
     * For example, you could have two VMCollectionType VMGroups VMG1 (containing VMs VM1 and VM2) and a second VMG2 (containing VMs VM3 and VM4).
     * You could then create a ManagementCollectionType VMGroup VM-All containing the two VMCollectionType VMGroups.
     * You use the [Add-VMGroupMember](./Add-VMGroupMember.md) cmdlet to add VMs to VMCollectionType VMGroups and to add VMCollectionType groups to ManagementCollectionType VMGroups.
     * </summary>
     * <remarks>
     * The **New-VMGroup** cmdlet creates a virtual machine group.
     * </remarks>
     */
    public VMGroup[] New_VMGroup(New_VMGroupArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.GroupType is not null)
            parameters.Add("GroupType", args.GroupType);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMGroup>("New-VMGroup", parameters);
        return result;
    }

    public class New_VMReplicationAuthorizationEntryArguments
    {
        /**
         * Specifies the server that is allowed to send replication data to the Replica server.
        Only fully-qualified domain names and fully qualified international domain names are supported.
        You can use a wildcard (for example, "*") in the first octect to specify a fully qualified domain name, such as *.contoso.com.
         */
        public required string? AllowedPrimaryServer { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the authorization entry is to be created.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the location to store the Replica virtual hard disk files sent from the allowed server when a new Replica virtual machine is created.
         */
        public required string? ReplicaStorageLocation { get; set; }

        /**
         * Identifies a group of primary servers within which a given primary virtual machine can move so replications of the primary virtual machine are accepted by the Replica server only from primary servers that belong to the trust group.
        You can use any string to create a new trust group.
        Ensure all primary servers within a specific trust group use the same string as the value you specify for this parameter.
        
         * Use of a trust group can help you keep virtual machines isolated by maintaining control over which primary servers are trusted to provide replication, while also allowing the virtual machines to move from one primary server to another (such as through live migration or failover from a cluster node).
         */
        public required string? TrustGroup { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/new-vmreplicationauthorizationentry?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Creates a new authorization entry that allows one or more primary servers to replicate data to a specified Replica server.
     * </summary>
     * <remarks>
     * The **New-VMReplicationAuthorizationEntry** cmdlet creates a new authorization entry that allows one or more primary servers to replicate data. To use this cmdlet, the value of the ReplicationAllowedFromAnyServer property of the Replica server must be false. You can use the **Get-VMReplicationServer** cmdlet to check the value of this property.
     * </remarks>
     */
    public VMReplicationAuthorizationEntry[] New_VMReplicationAuthorizationEntry(
        New_VMReplicationAuthorizationEntryArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowedPrimaryServer is not null)
            parameters.Add("AllowedPrimaryServer", args.AllowedPrimaryServer);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ReplicaStorageLocation is not null)
            parameters.Add("ReplicaStorageLocation", args.ReplicaStorageLocation);
        if (args.TrustGroup is not null)
            parameters.Add("TrustGroup", args.TrustGroup);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMReplicationAuthorizationEntry>(
            "New-VMReplicationAuthorizationEntry",
            parameters
        );
        return result;
    }

    public class New_VMResourcePoolArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the resource pool is to be created.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the resource pool
         */
        public required string? Name { get; set; }

        /**
         * Specifies the name of the parent resource pool for the new resource pool.
         */
        public string[]? ParentName { get; set; }

        /**
         * Specifies an array of paths to be associated with a new storage resource pool.
         */
        public string[]? Paths { get; set; }

        /**
         * Specifies the resource type of the resource pool.
         */
        public required VMResourcePoolType[]? ResourcePoolType { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/new-vmresourcepool?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Creates a resource pool.
     * </summary>
     * <remarks>
     * The **New-VMResourcePool** cmdlet creates a resource pool.
     * </remarks>
     */
    public VMResourcePool[] New_VMResourcePool(New_VMResourcePoolArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.ParentName is not null)
            parameters.Add("ParentName", args.ParentName);
        if (args.Paths is not null)
            parameters.Add("Paths", args.Paths);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMResourcePool>("New-VMResourcePool", parameters);
        return result;
    }

    public class New_VMSanArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession? CimSession { get; set; }

        /**
         * Specifies the friendly name of a Hyper-V host on which the new virtual storage area network (SAN) is to be created.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential? Credential { get; set; }

        /**
         * Specifies the host bus adapter (HBA) to be associated with the virtual storage area network (SAN) to be created.
        This can be retrieved by running the **Get-InitiatorPort** cmdlet.
         */
        public CimInstance[]? HostBusAdapter { get; set; }

        /**
         * Specifies the friendly name of the virtual storage area network (SAN) to be created.
         */
        public required string? Name { get; set; }

        /**
         * Specifies a note to be associated with the virtual storage area network (SAN) to be created.
         */
        public string? Note { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }

        /**
         * Specifies the world wide node name (WWNN) of the host bus adapters to be associated with the virtual storage area network (SAN) to be created.
         */
        public required string[]? WorldWideNodeName { get; set; }

        /**
         * Specifies the world wide port name (WWPN) of the host bus adapters to be associated with the virtual storage area network (SAN) to be created.
         */
        public required string[]? WorldWidePortName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/new-vmsan?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Creates a new virtual storage area network (SAN) on a Hyper-V host.
     * </summary>
     * <remarks>
     * The **New-VMSan** cmdlet creates a new virtual storage area network (SAN) on a Hyper-V host.
     * </remarks>
     */
    public VMSan[] New_VMSan(New_VMSanArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.HostBusAdapter is not null)
            parameters.Add("HostBusAdapter", args.HostBusAdapter);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Note is not null)
            parameters.Add("Note", args.Note);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        if (args.WorldWideNodeName is not null)
            parameters.Add("WorldWideNodeName", args.WorldWideNodeName);
        if (args.WorldWidePortName is not null)
            parameters.Add("WorldWidePortName", args.WorldWidePortName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSan>("New-VMSan", parameters);
        return result;
    }

    public class New_VMSwitchArguments
    {
        /**
         * Specifies whether the parent partition (i.e.
        the management operating system) is to have access to the physical NIC bound to the virtual switch to be created.
         */
        public Boolean? AllowManagementOS { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual switch is to be created.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies whether this cmdlet enables teaming for the virtual switch.
         */
        public Boolean? EnableEmbeddedTeaming { get; set; }

        /**
         * Specifies that IO virtualization is to be enabled on the virtual switch to be created.
         */
        public Boolean? EnableIov { get; set; }

        /**
         * Specifies whether this cmdlet enables the packet direct path through the virtual switch.
        The default value is $False.
         */
        public Boolean? EnablePacketDirect { get; set; }

        /**
         * Specifies how minimum bandwidth is to be configured on the virtual switch.
        Allowed values are **Absolute**, **Default**, **None**, or **Weight**.
        If **Absolute** is specified, minimum bandwidth is bits per second.
        If **Weight** is specified, minimum bandwidth is a value ranging from 1 to 100.
        If **None** is specified, minimum bandwidth is disabled on the switch - that is, users cannot configure it on any network adapter connected to the switch.
        If **Default** is specified, the system will set the mode to **Weight**, if the switch is not IOV-enabled, or **None** if the switch is IOV-enabled.
         */
        public VMSwitchBandwidthMode? MinimumBandwidthMode { get; set; }

        /**
         * Specifies the name of the switch to be created.
         */
        public required string? Name { get; set; }

        /**
         * Specifies the interface description of the network adapter to be bound to the switch to be created.
        You can use the **Get-NetAdapter** cmdlet to get the interface description of a network adapter.
         */
        public required string[]? NetAdapterInterfaceDescription { get; set; }

        /**
         * Specifies the name of the network adapter to be bound to the switch to be created.
        You can use the **Get-NetAdapter** cmdlet to get the interface description of a network adapter.
         */
        public required string[]? NetAdapterName { get; set; }

        /**
         * Specifies a note to be associated with the switch to be created.
         */
        public string? Notes { get; set; }

        /**
         * Specifies the type of the switch to be created.
        Allowed values are **Internal** and **Private**.
        To create an External virtual switch, specify either the **NetAdapterInterfaceDescription** or the **NetAdapterName** parameter, which implicitly set the type of the virtual switch to External.
         */
        public required VMSwitchType? SwitchType { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/new-vmswitch?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Creates a new virtual switch on one or more virtual machine hosts.
     * </summary>
     * <remarks>
     * The **New-VMSwitch** cmdlet creates a new virtual switch on one or more virtual machine hosts.
     * </remarks>
     */
    public VMSwitch[] New_VMSwitch(New_VMSwitchArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowManagementOS is not null)
            parameters.Add("AllowManagementOS", args.AllowManagementOS);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.EnableEmbeddedTeaming is not null)
            parameters.Add("EnableEmbeddedTeaming", args.EnableEmbeddedTeaming);
        if (args.EnableIov is not null)
            parameters.Add("EnableIov", args.EnableIov);
        if (args.EnablePacketDirect is not null)
            parameters.Add("EnablePacketDirect", args.EnablePacketDirect);
        if (args.MinimumBandwidthMode is not null)
            parameters.Add("MinimumBandwidthMode", args.MinimumBandwidthMode);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NetAdapterInterfaceDescription is not null)
            parameters.Add("NetAdapterInterfaceDescription", args.NetAdapterInterfaceDescription);
        if (args.NetAdapterName is not null)
            parameters.Add("NetAdapterName", args.NetAdapterName);
        if (args.Notes is not null)
            parameters.Add("Notes", args.Notes);
        if (args.SwitchType is not null)
            parameters.Add("SwitchType", args.SwitchType);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitch>("New-VMSwitch", parameters);
        return result;
    }

    public class Optimize_VHDArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual machine is to be optimized.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the mode in which the virtual hard disk is to be optimized.
        For a **VHD** disk, the default mode is **Full**.
        For a **VHDX** disk, the default mode is **Quick**.
        Valid modes are as follows:
        
         * - **Full** scans for zero blocks and reclaims unused blocks. (Allowable only if the virtual hard disk is mounted read-only.)
        - **Pretrimmed** performs as **Quick** mode, but does not require the virtual hard disk to be mounted read-only. The detection of unused space is less effective than **Quick** mode (in which the virtual hard disk had been mounted read-only) because the scan cannot query information about free space in the NTFS file system within the virtual hard disk. Useful when the VHDX-format file has been used by operating system instances that are at least Windows 8 or Windows Server 2012, or when this cmdlet has already been run on a .vhdx file in **Retrim** mode.
        - **Prezeroed** performs as **Quick** mode, but does not require the virtual hard disk to be mounted read-only. The unused space detection will be less effective than if the virtual hard disk had been mounted read-only as the scan will be unable to query information about free space in the NTFS file system within the virtual hard disk. Useful if a tool was run previously to zero all the free space on the virtual disk as this mode of compaction can then reclaim that space for subsequent block allocations. This form of compaction can also be useful in handling virtual hard disk containing file systems other than NTFS.
        - **Quick** reclaims unused blocks, but does not scan for zero blocks. (Allowable only if the virtual hard disk is mounted read-only.)
        - **Retrim** sends down retrims without scanning for zero blocks or reclaiming unused blocks. (Allowable only if the virtual hard disk is mounted read-only.)
         */
        public VhdCompactMode? Mode { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual hard disk to be optimized.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies one or more paths to the dynamic or differencing virtual hard disk files to be optimized.
         */
        public required string[]? Path { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/optimize-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Optimizes the allocation of space used by virtual hard disk files, except for fixed virtual hard disks.
     * </summary>
     * <remarks>
     * The **Optimize-VHD** cmdlet optimizes the allocation of space in one or more virtual hard disk files, except for fixed virtual hard disks. The **Compact** operation is used to optimize the files. This operation reclaims unused blocks as well as rearranges the blocks to be more efficiently packed, which reduces the size of a virtual hard disk file.
    
    To use Optimize-VHD, the virtual hard disk must not be attached or must be attached in read-only mode.
    
    The compact operation can succeed without reducing the file size, if no optimization is possible.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Optimize_VHD(Optimize_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Mode is not null)
            parameters.Add("Mode", args.Mode);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Optimize-VHD",
            parameters
        );
        return result;
    }

    public class Optimize_VHDSetArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VirtualHardDisk** object that it optimizes.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of paths of VHD sets that this cmdlet optimizes.
         */
        public required string[]? Path { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/optimize-vhdset?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VHDSet.md">Get-VHDSet</see>
     * Optimizes VHD set files.
     * </summary>
     * <remarks>
     * The **Optimize-VHDSet** cmdlet optimizes the allocation of space used by virtual hard disk (VHD) set files.
     * </remarks>
     * <returns>This cmdlet returns a **VirtualHardDisk** object, if you specify the **Passthru** parameter.</returns>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Optimize_VHDSet(Optimize_VHDSetArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Optimize-VHDSet",
            parameters
        );
        return result;
    }

    public class Remove_VHDSnapshotArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967)
        or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet. NetBIOS names, IP addresses, and fully
        qualified domain names are allowable. The default is the local computer. Use `localhost` or a dot
        (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies an array of paths of VHD set files. This cmdlet removes a checkpoint from the files that
        this parameter specifies. If you specify a file name or relative path, the cmdlet determines the
        full path relative to the current working folder.
         */
        public required string[]? Path { get; set; }

        /**
         * Indicates that this cmdlet persists an RCT-only reference point after it deletes the checkpoint.
         */
        public SwitchParameter? PersistReferencePoint { get; set; }

        /**
         * Specifies an array of unique IDs of VHD checkpoint that this cmdlet removes from the VHD set file.
         */
        public required Guid[]? SnapshotId { get; set; }

        /**
         * Specifies an array of VHD checkpoints that this cmdlet removes from a VHD set file.
         */
        public required VHDSnapshotInfo[]? VHDSnapshot { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet isn't run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vhdsnapshot?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="get-vhdsnapshot.md">Get-VHDSnapshot</see>
     * Removes a checkpoint from a VHD set file.
     * </summary>
     * <remarks>
     * The `Remove-VHDSnapshot` cmdlet removes a virtual hard disk (VHD) checkpoint from a VHD set file.
    
    Checkpoint replaces the previous term, snapshot.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VHDSnapshotInfo[] Remove_VHDSnapshot(
        Remove_VHDSnapshotArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.PersistReferencePoint is not null)
            parameters.Add("PersistReferencePoint", args.PersistReferencePoint);
        if (args.SnapshotId is not null)
            parameters.Add("SnapshotId", args.SnapshotId);
        if (args.VHDSnapshot is not null)
            parameters.Add("VHDSnapshot", args.VHDSnapshot);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VHDSnapshotInfo>(
            "Remove-VHDSnapshot",
            parameters
        );
        return result;
    }

    public class Remove_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the virtual machine is to be deleted.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that confirmation prompts are to be suppressed during deletion of the virtual machine.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies the name of the virtual machine to be deleted.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual machine to be deleted.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine to be deleted.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Deletes a virtual machine.
     * </summary>
     * <remarks>
     * The **Remove-VM** cmdlet deletes a virtual machine. Running this cmdlet deletes the virtual machine's configuration file, but does not delete any virtual hard drives. If the virtual machine has any snapshots, these are deleted and merged into the virtual hard disk files after the virtual machine is deleted.
     * </remarks>
     */
    public void Remove_VM(Remove_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VM", parameters);
    }

    public class Remove_VMAssignableDeviceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on the virtual network adapters are to be retrieved. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Removes the Device Instance path in the host machine.
         */
        public string? InstancePath { get; set; }

        /**
         * Specifies the location path to the assignable device.
         */
        public string? LocationPath { get; set; }

        /**
         * Returns an object for each process that the cmdlet started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the assignable device object that you want to remove from the virtual machine. This is
        usually an object retrieved from a cmdlet like `Get-VMAssignableDevice`.
         */
        public required VMAssignedDevice[]? VMAssignableDevice { get; set; }

        /**
         * Specifies the name of the virtual machine from which you want to remove the assignable device.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmassignabledevice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="add-vmassignabledevice.md">Add-VMAssignableDevice</see>
     *
     * <see href="get-vmassignabledevice.md">Get-VMAssignableDevice</see>
     * Removes information about the assignable devices from a specific virtual machine.
     * </summary>
     * <remarks>
     * The `Remove-VMAssignableDevice` cmdlet removes an assignable device from a specified virtual machine (VM). This is often used in scenarios where a physical device, such as a GPU or network adapter, was previously assigned to a VM and needs to be unassigned.
     * </remarks>
     */
    public VMAssignedDevice[] Remove_VMAssignableDevice(Remove_VMAssignableDeviceArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.InstancePath is not null)
            parameters.Add("InstancePath", args.InstancePath);
        if (args.LocationPath is not null)
            parameters.Add("LocationPath", args.LocationPath);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMAssignableDevice is not null)
            parameters.Add("VMAssignableDevice", args.VMAssignableDevice);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMAssignedDevice>(
            "Remove-VMAssignableDevice",
            parameters
        );
        return result;
    }

    public class Remove_VMDvdDriveArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the DVD drive is to be deleted.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies the number of the location on the controller at which the DVD drive is to be deleted.
        If not specified, the number of the first available location on the controller is used.
         */
        public required int? ControllerLocation { get; set; }

        /**
         * Specifies the number of the controller from which the DVD drive is to be deleted.
        If not specified, the first IDE controller on which the specified **ControllerLocation** is available is used.
         */
        public required int? ControllerNumber { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the DVD drive to be deleted.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the DVD drive to be deleted.
         */
        public required DvdDrive[]? VMDvdDrive { get; set; }

        /**
         * Specifies the name of the virtual machine from which the DVD drive is to be deleted.
         */
        public required string? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmdvddrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Deletes a DVD drive from a virtual machine.
     * </summary>
     * <remarks>
     * The **Remove-VMDvdDrive** cmdlet deletes a DVD drive from a virtual machine.
     * </remarks>
     */
    public void Remove_VMDvdDrive(Remove_VMDvdDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMDvdDrive is not null)
            parameters.Add("VMDvdDrive", args.VMDvdDrive);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMDvdDrive", parameters);
    }

    public class Remove_VMFibreChannelHbaArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the Fibre Channel host bus adapter is to be removed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an object is to be passed through to be pipeline representing the removed Fibre Channel host bus adapter.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies one or more Fibre Channel host bus adapters to be removed from a virtual machine.
         */
        public required VMFibreChannelHba[]? VMFibreChannelHba { get; set; }

        /**
         * Specifies the virtual machine from which the Fibre Channel host bus adapters are to be removed.
         */
        public required string? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }

        /**
         * Specifies the World Wide Node name of address set A associated with the Fibre Channel host bus adapter to be removed.
         */
        public required string? WorldWideNodeNameSetA { get; set; }

        /**
         * Specifies the World Wide Node name of address set B associated with the Fibre Channel host bus adapter to be removed.
         */
        public required string? WorldWideNodeNameSetB { get; set; }

        /**
         * Specifies the World Wide Port name of address set A associated with the Fibre Channel host bus adapter to be removed.
         */
        public required string? WorldWidePortNameSetA { get; set; }

        /**
         * Specifies the World Wide Port name of address set B associated with the Fibre Channel host bus adapter to be removed.
         */
        public required string? WorldWidePortNameSetB { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmfibrechannelhba?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes a Fibre Channel host bus adapter from a virtual machine.
     * </summary>
     * <remarks>
     * The **Remove-VMFibreChannelHba** cmdlet removes a Fibre Channel host bus adapter from a virtual machine.
     * </remarks>
     */
    public void Remove_VMFibreChannelHba(Remove_VMFibreChannelHbaArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMFibreChannelHba is not null)
            parameters.Add("VMFibreChannelHba", args.VMFibreChannelHba);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        if (args.WorldWideNodeNameSetA is not null)
            parameters.Add("WorldWideNodeNameSetA", args.WorldWideNodeNameSetA);
        if (args.WorldWideNodeNameSetB is not null)
            parameters.Add("WorldWideNodeNameSetB", args.WorldWideNodeNameSetB);
        if (args.WorldWidePortNameSetA is not null)
            parameters.Add("WorldWidePortNameSetA", args.WorldWidePortNameSetA);
        if (args.WorldWidePortNameSetB is not null)
            parameters.Add("WorldWidePortNameSetB", args.WorldWidePortNameSetB);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMFibreChannelHba", parameters);
    }

    public class Remove_VMGpuPartitionAdapterArguments
    {
        /**
         * This is a VM's GPU partition identification number used to remove a GPU from a VM.
         */
        public string? AdapterId { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on the virtual network adapters are to be retrieved. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer.Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Returns an object for each process that the cmdlet started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine whose virtual network adapters are to be retrieved. The asterisk (`*`)
        is the wildcard. If it is specified the cmdlet returns virtual network adapters from every virtual
        machine in the system.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * GPU partition object obtained from `Get-VMGpuPartitionAdapter`.
         */
        public required VMGpuPartitionAdapter[]? VMGpuPartitionAdapter { get; set; }

        /**
         * Specifies the name of the virtual machine whose network adapters are to be removed.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmgpupartitionadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="add-vmgpupartitionadapter.md">Add-VMGpuPartitionAdapter</see>
     *
     * <see href="get-vmgpupartitionadapter.md">Get-VMGpuPartitionAdapter</see>
     *
     * <see href="set-vmgpupartitionadapter.md">Set-VMGpuPartitionAdapter</see>
     * Removes an assigned GPU partition from a virtual machine.
     * </summary>
     * <remarks>
     * The `Remove-VMGpuPartitionAdapter` cmdlet removes an assigned graphic processing unit partition from a virtual machine and releases that partition back to the host GPU.
     * </remarks>
     */
    public VMGpuPartitionAdapter[] Remove_VMGpuPartitionAdapter(
        Remove_VMGpuPartitionAdapterArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.AdapterId is not null)
            parameters.Add("AdapterId", args.AdapterId);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMGpuPartitionAdapter is not null)
            parameters.Add("VMGpuPartitionAdapter", args.VMGpuPartitionAdapter);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMGpuPartitionAdapter>(
            "Remove-VMGpuPartitionAdapter",
            parameters
        );
        return result;
    }

    public class Remove_VMGroupArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies the unique ID of an empty virtual machine group that this cmdlet removes.
         */
        public required Guid? Id { get; set; }

        /**
         * Specifies the name of an empty virtual machine group that this cmdlet removes.
         */
        public required string? Name { get; set; }

        /**
         * Specifies an empty virtual machine group that this cmdlet removes.
        To obtain a **VMGroup** object, use the **Get-VMGroup** cmdlet.
         */
        public required VMGroup? VMGroup { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmgroup?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMGroup.md">Get-VMGroup</see>
     *
     * <see href="./New-VMGroup.md">New-VMGroup</see>
     *
     * <see href="./Rename-VMGroup.md">Rename-VMGroup</see>
     * Removes a virtual machine group.
     * </summary>
     * <remarks>
     * The **Remove-VMGroup** cmdlet removes a virtual machine group. Before you can remove a group, it must be empty.
     * </remarks>
     */
    public System.Object[] Remove_VMGroup(Remove_VMGroupArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.VMGroup is not null)
            parameters.Add("VMGroup", args.VMGroup);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<System.Object>("Remove-VMGroup", parameters);
        return result;
    }

    public class Remove_VMGroupMemberArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the unique ID of the virtual machine group from which this cmdlet removes virtual machines or groups of virtual machines.
         */
        public required Guid? Id { get; set; }

        /**
         * Specifies the name of the virtual machine group from which this cmdlet removes virtual machines or groups of virtual machines.
         */
        public required string? Name { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VMGroup** object that it configures.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machines that this cmdlet removes from a virtual machine group.
        To obtain a **VirtualMachine** object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the virtual machine group from which this cmdlet removes virtual machines or groups of virtual machines.
        To obtain a **VMGroup** object, use the **Get-VMGroup** cmdlet.
         */
        public required VMGroup? VMGroup { get; set; }

        /**
         * Specifies an array of groups of virtual machines that this cmdlet removes from a virtual machine group.
         */
        public required VMGroup[]? VMGroupMember { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmgroupmember?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Add-VMGroupMember.md">Add-VMGroupMember</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     *
     * <see href="./Get-VMGroup.md">Get-VMGroup</see>
     * Removes members from a virtual machine group.
     * </summary>
     * <remarks>
     * The **Remove-VMGroupMember** cmdlet removes either virtual machines or groups of virtual machines from a virtual machine group.
     * </remarks>
     * <returns>This cmdlet returns a **VMGroup** object, if you specify the **Passthru** parameter.</returns>
     */
    public VMGroup[] Remove_VMGroupMember(Remove_VMGroupMemberArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMGroup is not null)
            parameters.Add("VMGroup", args.VMGroup);
        if (args.VMGroupMember is not null)
            parameters.Add("VMGroupMember", args.VMGroupMember);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMGroup>("Remove-VMGroupMember", parameters);
        return result;
    }

    public class Remove_VMHardDiskDriveArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the virtual hard disk drive is to be deleted.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies the number of the location on the controller at which the virtual hard disk drive is to be deleted.
        If not specified, the number of the first available location on the controller is used.
         */
        public required int? ControllerLocation { get; set; }

        /**
         * Specifies the number of the controller from which the virtual hard disk drive is to be deleted.
        If not specified, the first controller on which the specified **ControllerLocation** is available is used.
         */
        public required int? ControllerNumber { get; set; }

        /**
         * Specifies the type of the controller where the virtual hard disk is to be deleted.
        Allowed values are **IDE** and **SCSI**.
         */
        public required ControllerType? ControllerType { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an object is to be passed through to be pipeline representing the virtual hard disk drive to be deleted.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual hard disk drive to be deleted.
         */
        public required HardDiskDrive[]? VMHardDiskDrive { get; set; }

        /**
         * Specifies the name of the virtual machine from which the virtual hard disk is to be deleted.
         */
        public required string? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmharddiskdrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Deletes a hard disk drive from a virtual machine.
     * </summary>
     * <remarks>
     * The **Remove-VMHardDiskDrive** cmdlet deletes a hard disk drive from a virtual machine.
     * </remarks>
     */
    public void Remove_VMHardDiskDrive(Remove_VMHardDiskDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.ControllerType is not null)
            parameters.Add("ControllerType", args.ControllerType);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMHardDiskDrive is not null)
            parameters.Add("VMHardDiskDrive", args.VMHardDiskDrive);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMHardDiskDrive", parameters);
    }

    public class Remove_VMHostAssignableDeviceArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the assignable devices are to be removed. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies the device object to be removed. You can get this object using
        `Get-VMHostAssignableDevice`.
         */
        public required VMHostAssignableDevice[]? HostAssignableDevice { get; set; }

        /**
         * Specifies the Device Instance path in the host machine.
         */
        public string? InstancePath { get; set; }

        /**
         * Specifies the location path to the assignable device.
         */
        public string? LocationPath { get; set; }

        /**
         * Specifies the name of the resource pool from which to remove an assignable device.
         */
        public required string[]? ResourcePoolName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmhostassignabledevice?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="add-vmhostassignabledevice.md">Add-VMHostAssignableDevice</see>
     *
     * <see href="get-vmhostassignabledevice.md">Get-VMHostAssignableDevice</see>
     *
     * <see href="dismount-vmhostassignabledevice.md">Dismount-VMHostAssignableDevice</see>
     *
     * <see href="mount-vmhostassignabledevice.md">Mount-VMHostAssignableDevice</see>
     * Removes a device assigned to a virtual machine (VM) host.
     * </summary>
     * <remarks>
     * The `Remove-VMHostAssignableDevice` cmdlet removes a device that is assigned to a virtual machine host. Depending on the parameters specified, you can remove devices by providing either the instance or location path of the device.
     * </remarks>
     */
    public System.Object[] Remove_VMHostAssignableDevice(
        Remove_VMHostAssignableDeviceArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.HostAssignableDevice is not null)
            parameters.Add("HostAssignableDevice", args.HostAssignableDevice);
        if (args.InstancePath is not null)
            parameters.Add("InstancePath", args.InstancePath);
        if (args.LocationPath is not null)
            parameters.Add("LocationPath", args.LocationPath);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<System.Object>(
            "Remove-VMHostAssignableDevice",
            parameters
        );
        return result;
    }

    public class Remove_VMKeyStorageDriveArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public object? Confirm { get; set; }
        public PSCredential[]? Credential { get; set; }
        public object? Passthru { get; set; }
        public required KeyStorageDrive[]? VMKeyStorageDrive { get; set; }
        public required string? VMName { get; set; }
        public object? WhatIf { get; set; }
    }

    /** <summary>
     *
     * Remove-VMKeyStorageDrive [-VMName] <string> [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * Remove-VMKeyStorageDrive [-VMKeyStorageDrive] <KeyStorageDrive[]> [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public KeyStorageDrive[] Remove_VMKeyStorageDrive(Remove_VMKeyStorageDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMKeyStorageDrive is not null)
            parameters.Add("VMKeyStorageDrive", args.VMKeyStorageDrive);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<KeyStorageDrive>(
            "Remove-VMKeyStorageDrive",
            parameters
        );
        return result;
    }

    public class Remove_VMMigrationNetworkArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the network is to be removed from use with migration.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.MigrationNetwork** object is to be passed through to the pipeline representing the network removed from use with migration.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies a string representing an IPv4 or IPv6 subnet mask which identifies the network to be removed from use with migration.
         */
        public required string? Subnet { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmmigrationnetwork?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes a network from use with migration.
     * </summary>
     * <remarks>
     * The **Remove-VMMigrationNetwork** cmdlet removes a network from use with migration.
     * </remarks>
     */
    public void Remove_VMMigrationNetwork(Remove_VMMigrationNetworkArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Subnet is not null)
            parameters.Add("Subnet", args.Subnet);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMMigrationNetwork", parameters);
    }

    public class Remove_VMNetworkAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual network adapter is to be removed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the management operating system  of the virtual network adapter to be removed.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the name of the virtual network adapter to be removed.
         */
        public string? Name { get; set; }

        /**
         * Specifies that an object to be passed through to the pipeline representing the virtual machine network adapter to be removed.
        This is a **Microsoft.HyperV.PowerShell.VMInternalNetworkAdapter** object, if **-ManagementOS** is specified; otherwise it is a **Microsoft.HyperV.PowerShell.VMNetworkAdapter** object.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual switch connected to the virtual network adapter to be removed.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies the virtual machine that has the virtual network adapter you want to remove.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine that has the virtual network adapter you want to remove.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine network adapter to be removed.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmnetworkadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes one or more virtual network adapters from a virtual machine.
     * </summary>
     * <remarks>
     * The **Remove-VMNetworkAdapter** cmdlet removes one or more virtual network adapters from a virtual machine.
     * </remarks>
     */
    public void Remove_VMNetworkAdapter(Remove_VMNetworkAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMNetworkAdapter", parameters);
    }

    public class Remove_VMNetworkAdapterAclArguments
    {
        /**
         * Specifies the action of the ACL to be removed.
        Allowed values are **Allow**, **Deny**, and **Meter**.
         */
        public required VMNetworkAdapterAclAction? Action { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the ACL applied to a virtual machine network adapter is to be removed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * The direction of the network traffic (from the perspective of the virtual machine) to which the ACL applies.
        Allowed values are **Inbound**, **Outbound**, or **Both**.
         */
        public required VMNetworkAdapterAclDirection? Direction { get; set; }

        /**
         * Specifies the ACL to be removed.
         */
        public required VMNetworkAdapterAclSetting[]? InputObject { get; set; }

        /**
         * Specifies the local IP address.
        It can be either IPv4 or IPv6 address.
        It can be either a host address or a subnet address, e.g.
        1.2.3.4, 2001::2008, 192.168.1.0/24, or f001:f002:f003:f004::1/64.the IP address can also be a wildcard, 0.0.0.0/0 for all IPv4 addresses, ::/0 for all IPv6 addresses, or ANY for all IPv4 and IPv6 addresses.
         */
        public string[]? LocalIPAddress { get; set; }

        /**
         * Specifies the local MAC address (e.g.
        00-ab-00-11-22-33).
        Use the wildcard **ANY** to specify all MAC addresses.
         */
        public string[]? LocalMacAddress { get; set; }

        /**
         * Specifies that the ACL is to be removed from the management (e.g.
        the parent, or host) operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VMNetworkAdapterAclSetting** object is to be passed through to the pipeline representing the ACL to be removed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the remote IP address.
        . It can be either IPv4 or IPv6 address.
        It can be either a host address or a subnet address, e.g.
        1.2.3.4, 2001::2008, 192.168.1.0/24, or f001:f002:f003:f004::1/64.
        the IP address can also be a wildcard, 0.0.0.0/0 for all IPv4 addresses, ::/0 for all IPv6 addresses, or ANY for all IPv4 and IPv6 addresses.
         */
        public string[]? RemoteIPAddress { get; set; }

        /**
         * Specifies the remote MAC address.
        . It can be a host MAC address, e.g.
        00-ab-00-11-22-33, or a wildcard, ANY, for all MAC addresses.
         */
        public string[]? RemoteMacAddress { get; set; }

        /**
         * Specifies the virtual machine from which the ACL is to be removed.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine from which the ACL is to be removed.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine network adapter from which ACL is to be removed.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual machine network adapter from which the ACL is to be removed.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmnetworkadapteracl?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes an ACL applied to the traffic through a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Remove-VMNetworkAdapterAcl** cmdlet removes an ACL applied to the traffic through a virtual network adapter.
     * </remarks>
     */
    public void Remove_VMNetworkAdapterAcl(Remove_VMNetworkAdapterAclArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.Action is not null)
            parameters.Add("Action", args.Action);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Direction is not null)
            parameters.Add("Direction", args.Direction);
        if (args.InputObject is not null)
            parameters.Add("InputObject", args.InputObject);
        if (args.LocalIPAddress is not null)
            parameters.Add("LocalIPAddress", args.LocalIPAddress);
        if (args.LocalMacAddress is not null)
            parameters.Add("LocalMacAddress", args.LocalMacAddress);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RemoteIPAddress is not null)
            parameters.Add("RemoteIPAddress", args.RemoteIPAddress);
        if (args.RemoteMacAddress is not null)
            parameters.Add("RemoteMacAddress", args.RemoteMacAddress);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMNetworkAdapterAcl", parameters);
    }

    public class Remove_VMNetworkAdapterExtendedAclArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet removes an ACL associated with a virtual network adapter on the Hyper-V hosts that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the direction of network traffic, from the perspective of the virtual machine, to which the ACL applies.
        The cmdlet removes an ACL that has the value that you specify.
        The acceptable values for this parameter are:
        
         * -- Inbound
        
         * -- Outbound
         */
        public required VMNetworkAdapterExtendedAclDirection? Direction { get; set; }

        /**
         * Specifies the input to this cmdlet.
        You can use this parameter, or you can pipe the input to this cmdlet.
         */
        public required VMNetworkAdapterExtendedAclSetting[]? InputObject { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent or host operating system.
        If you specify this parameter, this cmdlet removes an ACL that applies in the parent or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machines as **VirtualMachine** objects.
        The cmdlet removes an ACL for network adapters that belong to the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines.
        The cmdlet removes an ACL for network adapters that belong to the virtual machines that you specify.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies an array virtual machine network adapters as **VMNetworkAdapterBase** objects.
        The cmdlet removes an ACL for the network adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
        The cmdlet removes an ACL for the network adapter that you specify.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies the weight of an ACL entry.
        Because weight is unique for each entry, if you specify a value for this parameter, the cmdlet removes a specific extended ACL entry.
         */
        public required int? Weight { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmnetworkadapterextendedacl?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Add-VMNetworkAdapterExtendedAcl.md">Add-VMNetworkAdapterExtendedAcl</see>
     *
     * <see href="./Get-VMNetworkAdapterExtendedAcl.md">Get-VMNetworkAdapterExtendedAcl</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     *
     * <see href="./Get-VMNetworkAdapter.md">Get-VMNetworkAdapter</see>
     * Removes an extended ACL for a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Remove-VMNetworkAdapterExtendedAcl** cmdlet removes an extended access control list (ACL) for a virtual network adapter.
     * </remarks>
     */
    public VMNetworkAdapterExtendedAclSetting[] Remove_VMNetworkAdapterExtendedAcl(
        Remove_VMNetworkAdapterExtendedAclArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Direction is not null)
            parameters.Add("Direction", args.Direction);
        if (args.InputObject is not null)
            parameters.Add("InputObject", args.InputObject);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.Weight is not null)
            parameters.Add("Weight", args.Weight);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterExtendedAclSetting>(
            "Remove-VMNetworkAdapterExtendedAcl",
            parameters
        );
        return result;
    }

    public class Remove_VMNetworkAdapterRoutingDomainMappingArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet removes the virtual subnets from the Hyper-V hosts that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the input to this cmdlet.
        You can use this parameter, or you can pipe the input to this cmdlet.
         */
        public required VMNetworkAdapterRoutingDomainSetting[]? InputObject { get; set; }

        /**
         * Indicates that the cmdlet removes the virtual subnet on the parent partition or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the ID of a routing domain.
        The ID of a routing domain is a system-assigned GUID.
        The cmdlet removes the virtual subnet from the routing domain that you specify.
         */
        public Guid? RoutingDomainID { get; set; }

        /**
         * Specifies the name of a routing domain.
        The cmdlet removes the virtual subnet from the routing domain that you specify.
         */
        public string? RoutingDomainName { get; set; }

        /**
         * Specifies an array of virtual machines.
        The cmdlet removes the virtual subnet from the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines.
        The cmdlet removes the virtual subnet from the virtual machines that you specify.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies an array of virtual machine network adapters as **VMNetworkAdapterBase** objects.
        The cmdlet removes the virtual subnet for the adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
        The cmdlet removes the virtual subnet for the adapter that you specify.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmnetworkadapterroutingdomainmapping?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMNetworkAdapterRoutingDomainMapping.md">Get-VMNetworkAdapterRoutingDomainMapping</see>
     *
     * <see href="./Add-VmNetworkAdapterRoutingDomainMapping.md">Add-VmNetworkAdapterRoutingDomainMapping</see>
     *
     * <see href="./Set-VmNetworkAdapterRoutingDomainMapping.md">Set-VmNetworkAdapterRoutingDomainMapping</see>
     * Removes a routing domain from a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Remove-VmNetworkAdapterRoutingDomainMapping** cmdlet removes a routing domain from a virtual network adapter on a multitenant gateway virtual machine.
     * </remarks>
     */
    public VMNetworkAdapterRoutingDomainSetting[] Remove_VMNetworkAdapterRoutingDomainMapping(
        Remove_VMNetworkAdapterRoutingDomainMappingArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.InputObject is not null)
            parameters.Add("InputObject", args.InputObject);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RoutingDomainID is not null)
            parameters.Add("RoutingDomainID", args.RoutingDomainID);
        if (args.RoutingDomainName is not null)
            parameters.Add("RoutingDomainName", args.RoutingDomainName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterRoutingDomainSetting>(
            "Remove-VMNetworkAdapterRoutingDomainMapping",
            parameters
        );
        return result;
    }

    public class Remove_VMNetworkAdapterTeamMappingArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the name of a virtual machine network adapter.
         */
        public string? Name { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of a switch.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies a virtual machine.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Specifies the name of a virtual machine.
         */
        public required string? VMName { get; set; }

        /**
         * Specifies a virtual machine network adapter.
         */
        public required VMNetworkAdapterBase? VMNetworkAdapter { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmnetworkadapterteammapping?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMNetworkAdapterTeamMapping.md">Get-VMNetworkAdapterTeamMapping</see>
     *
     * <see href="./Set-VMNetworkAdapterTeamMapping.md">Set-VMNetworkAdapterTeamMapping</see>
     *
     * </summary>
     * <remarks>
     * The **Remove-VMNetworkAdapterTeamMapping** cmdlet
     * </remarks>
     */
    public VMNetworkAdapterTeamMappingSetting[] Remove_VMNetworkAdapterTeamMapping(
        Remove_VMNetworkAdapterTeamMappingArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterTeamMappingSetting>(
            "Remove-VMNetworkAdapterTeamMapping",
            parameters
        );
        return result;
    }

    public class Remove_VMPmemControllerArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public object? Confirm { get; set; }
        public PSCredential[]? Credential { get; set; }
        public object? Passthru { get; set; }
        public required string[]? VMName { get; set; }
        public required VMPmemController[]? VMPmemController { get; set; }
        public object? WhatIf { get; set; }
    }

    /** <summary>
     *
     * Remove-VMPmemController [-VMName] <string[]> [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * Remove-VMPmemController [-VMPmemController] <VMPmemController[]> [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VMPmemController[] Remove_VMPmemController(Remove_VMPmemControllerArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMPmemController is not null)
            parameters.Add("VMPmemController", args.VMPmemController);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMPmemController>(
            "Remove-VMPmemController",
            parameters
        );
        return result;
    }

    public class Remove_VMRemoteFx3dVideoAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a RemoteFX 3D video adapter is to be removed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **VMRemoteFxVideoAdapter** object is to be to be passed through to the pipeline representing the RemoteFX 3D video adapter to be removed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine from which the RemoteFX 3D video adapter to be removed.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine from which the RemoteFX 3D video adapter is to be removed.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the RemoteFX 3D video adapater to be removed.
         */
        public required VMRemoteFx3DVideoAdapter[]? VMRemoteFx3dVideoAdapter { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmremotefx3dvideoadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes a RemoteFX 3D video adapter from a virtual machine.
     * </summary>
     * <remarks>
     * The **Remove-VMRemoteFx3dVideoAdapter** cmdlet removes a RemoteFX 3D video adapter from a virtual machine.
     * </remarks>
     */
    public void Remove_VMRemoteFx3dVideoAdapter(Remove_VMRemoteFx3dVideoAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMRemoteFx3dVideoAdapter is not null)
            parameters.Add("VMRemoteFx3dVideoAdapter", args.VMRemoteFx3dVideoAdapter);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMRemoteFx3dVideoAdapter", parameters);
    }

    public class Remove_VMReplicationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the replication relationship of a virtual machine is to be removed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **VMReplication** object is to be passed through to the pipeline representing the virtual machine for which the replication relationship will be removed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the replication relationship type of the virtual machine.
        Specify whether the replication relationship is a simple primary to replica or is an extended replication chain.
        The cmdlet removes the replication relationship of the virtual machines that have the replication type that you specify.
         */
        public VMReplicationRelationshipType? ReplicationRelationshipType { get; set; }

        /**
         * Specifies the virtual machine for which the replication relationship is to be removed.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine for which the replication relationship is to be removed.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies a virtual machine replication object associated with the virtual machine whose replication relationship is to be removed.
         */
        public required VMReplication[]? VMReplication { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes the replication relationship of a virtual machine.
     * </summary>
     * <remarks>
     * The **Remove-VMReplication** cmdlet removes the replication relationship of a virtual machine. Replication must be removed independently from both the primary and Replica virtual machines. Removing replication on a Replica virtual machine does not delete the Replica virtual machine.
     * </remarks>
     */
    public void Remove_VMReplication(Remove_VMReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ReplicationRelationshipType is not null)
            parameters.Add("ReplicationRelationshipType", args.ReplicationRelationshipType);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMReplication is not null)
            parameters.Add("VMReplication", args.VMReplication);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMReplication", parameters);
    }

    public class Remove_VMReplicationAuthorizationEntryArguments
    {
        /**
         * Specifies the allowed primary server for which the authorization entry is to be removed.
         */
        public required string? AllowedPrimaryServer { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the authorization entry is to be removed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **VMReplicationAuthorizationEntry** object is to be passed through to the pipeline representing the authorization entry to be removed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the trust group for which the authorization entries are to be removed.
         */
        public required string? TrustGroup { get; set; }

        /**
         * Specifies the authorization entry to be removed.
         */
        public required VMReplicationAuthorizationEntry[]? VMReplicationAuthorizationEntry { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmreplicationauthorizationentry?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes an authorization entry from a Replica server.
     * </summary>
     * <remarks>
     * The **Remove-VMReplicationAuthorizationEntry** cmdlet removes an authorization entry from a Replica server, which cancels authorization for the primary server associated with the entry. After the authorization entry is removed, the Replica server does not accept replication data from the corresponding primary server.
     * </remarks>
     */
    public void Remove_VMReplicationAuthorizationEntry(
        Remove_VMReplicationAuthorizationEntryArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowedPrimaryServer is not null)
            parameters.Add("AllowedPrimaryServer", args.AllowedPrimaryServer);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.TrustGroup is not null)
            parameters.Add("TrustGroup", args.TrustGroup);
        if (args.VMReplicationAuthorizationEntry is not null)
            parameters.Add("VMReplicationAuthorizationEntry", args.VMReplicationAuthorizationEntry);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMReplicationAuthorizationEntry", parameters);
    }

    public class Remove_VMResourcePoolArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the resource pool.
         */
        public required string? Name { get; set; }

        /**
         * Specifies that a **VMResourcePool** object is to be passed through to the pipeline representing the removed resource pool.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the type of the resource pool to be deleted.
         */
        public required VMResourcePoolType[]? ResourcePoolType { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmresourcepool?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Deletes a resource pool from one or more virtual machine hosts.
     * </summary>
     * <remarks>
     * The **Remove-VMResourcePool** cmdlet deletes a resource pool from one or more virtual machine hosts.
     * </remarks>
     */
    public void Remove_VMResourcePool(Remove_VMResourcePoolArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMResourcePool", parameters);
    }

    public class Remove_VMSanArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies a Hyper-V host from which the virtual storage area network (SAN) is to be removed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual storage area network (SAN) to be removed from the Hyper-V host.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the removed virtual machine storage area network.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmsan?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes a virtual storage area network (SAN) from a Hyper-V host.
     * </summary>
     * <remarks>
     * The **Remove-VMSan** cmdlet removes a virtual storage area network (SAN) from a Hyper-V host.
     * </remarks>
     */
    public void Remove_VMSan(Remove_VMSanArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMSan", parameters);
    }

    public class Remove_VMSavedStateArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine saved state is to be deleted.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual machine whose saved state is to be deleted.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose saved state is to be deleted.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the snapshot whose saved state is to be deleted.
         */
        public required VMSnapshot? VMSnapshot { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmsavedstate?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Deletes the saved state of a saved virtual machine.
     * </summary>
     * <remarks>
     * The **Remove-VMSavedState** cmdlet deletes the saved state of a saved virtual machine. Note: data contained in the memory of the virtual machine may be lost; data on its virtual hard disk drives are unaffected.
     * </remarks>
     */
    public void Remove_VMSavedState(Remove_VMSavedStateArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMSnapshot is not null)
            parameters.Add("VMSnapshot", args.VMSnapshot);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMSavedState", parameters);
    }

    public class Remove_VMScsiControllerArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts from which the SCSI controller is to be removed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies the number of the controller.
        The cmdlet removes the SCSI controller that you specify.
         */
        public required int? ControllerNumber { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **VMScsiController** object is to be passed through to the pipeline representing the SCSI controller to be removed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of names of virtual machines.
        The cmdlet removes an SCSI controller from the virtual machines that you specify.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the SCSI controller to be removed.
         */
        public required VMScsiController[]? VMScsiController { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmscsicontroller?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes a SCSI controller from a virtual machine.
     * </summary>
     * <remarks>
     * The **Remove-VMScsiController** cmdlet removes a SCSI controller from a virtual machine.
     * </remarks>
     */
    public void Remove_VMScsiController(Remove_VMScsiControllerArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMScsiController is not null)
            parameters.Add("VMScsiController", args.VMScsiController);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMScsiController", parameters);
    }

    public class Remove_VMStoragePathArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a path is to be removed from a resource pool.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **System.String** is to be passed through to the pipeline representing the path to be removed from the resource pool.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to be removed from the storage resource pool.
         */
        public required string[]? Path { get; set; }

        /**
         * Specifies the name of the resource pool from which the path is to be removed.
         */
        public required string[]? ResourcePoolName { get; set; }

        /**
         * Specifies the type of the resource pool from which the path is to be removed.
        Allowed values are **VFD**, **ISO**, and **VHD**.
         */
        public required VMResourcePoolType? ResourcePoolType { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmstoragepath?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes a path from a storage resource pool.
     * </summary>
     * <remarks>
     * The **Remove-VMStoragePath** cmdlet removes a path from a storage resource pool.
     * </remarks>
     */
    public void Remove_VMStoragePath(Remove_VMStoragePathArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMStoragePath", parameters);
    }

    public class Remove_VMSwitchArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual switch is to be deleted.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies the name of the virtual switch to be deleted.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the name of the resource pool from which the switch is to be deleted.
         */
        public string[]? ResourcePoolName { get; set; }

        /**
         * Specifies the virtual switch to be deleted.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmswitch?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Deletes a virtual switch.
     * </summary>
     * <remarks>
     * The **Remove-VMSwitch** cmdlet deletes a virtual switch.
     * </remarks>
     */
    public void Remove_VMSwitch(Remove_VMSwitchArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMSwitch", parameters);
    }

    public class Remove_VMSwitchExtensionPortFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the external port on the virtual switch that binds to a physical network adapter.
         */
        public SwitchParameter? ExternalPort { get; set; }

        /**
         * Specifies that the feature is to be removed from the management (e.g.
        the parent, or host) operating system.
         */
        public SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VMSwitchExtensionPortFeature** is to be passed through to the pipeline representing the feature to be removed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual switch from which the feature is to be removed.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies the virtual machine from which the feature is to be removed.
         */
        public VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine from which the feature is to be removed.
         */
        public string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine network adapter from which the feature is to be removed.
         */
        public VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual network adapter from which the feature is to be removed.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies the feature to be removed.
         */
        public required VMSwitchExtensionPortFeature[]? VMSwitchExtensionFeature { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmswitchextensionportfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes a feature from a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Remove-VMSwitchExtensionPortFeature** cmdlet removes a feature from a virtual network adapter. The feature must have already been configured on the virtual network adapter.
     * </remarks>
     */
    public void Remove_VMSwitchExtensionPortFeature(
        Remove_VMSwitchExtensionPortFeatureArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ExternalPort is not null)
            parameters.Add("ExternalPort", args.ExternalPort);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.VMSwitchExtensionFeature is not null)
            parameters.Add("VMSwitchExtensionFeature", args.VMSwitchExtensionFeature);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMSwitchExtensionPortFeature", parameters);
    }

    public class Remove_VMSwitchExtensionSwitchFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VMSwitchExtensionSwitchFeature** is to be passed through to the pipeline representing the feature to be removed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual switch from which the feature is to be removed.
         */
        public string[]? SwitchName { get; set; }

        /**
         * Specifies the virtual switch from which the feature is to be removed.
         */
        public VMSwitch[]? VMSwitch { get; set; }

        /**
         * Specifies the feature to be removed.
         */
        public required VMSwitchExtensionSwitchFeature[]? VMSwitchExtensionFeature { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmswitchextensionswitchfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Removes a feature from a virtual switch.
     * </summary>
     * <remarks>
     * The **Remove-VMSwitchExtensionSwitchFeature** cmdlet removes a feature from a virtual switch. The feature already must have been configured on the virtual switch.
     * </remarks>
     */
    public void Remove_VMSwitchExtensionSwitchFeature(
        Remove_VMSwitchExtensionSwitchFeatureArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.VMSwitchExtensionFeature is not null)
            parameters.Add("VMSwitchExtensionFeature", args.VMSwitchExtensionFeature);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Remove-VMSwitchExtensionSwitchFeature", parameters);
    }

    public class Remove_VMSwitchTeamMemberArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies an array of interface descriptions of virtual network adapters that this cmdlet removes from a switch team.
         */
        public string[]? NetAdapterInterfaceDescription { get; set; }

        /**
         * Specifies an array of names of virtual network adapters that this cmdlet removes from a switch team.
         */
        public string[]? NetAdapterName { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VMSwitch** object that it modifies.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual switches from which this cmdlet removes network adapters.
        To obtain a **VMSwitch** object, use the **Get-VMSwitch** cmdlet.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Specifies an array of names of virtual switches from which this cmdlet removes network adapters.
         */
        public required string[]? VMSwitchName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/remove-vmswitchteammember?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Add-VMSwitchTeamMember.md">Add-VMSwitchTeamMember</see>
     *
     * <see href="./Get-VMSwitch.md">Get-VMSwitch</see>
     * Removes a member from a virtual machine switch team.
     * </summary>
     * <remarks>
     * The **Remove-VMSwitchTeamMember** cmdlet removes virtual network adapters from a virtual machine switch team.
     * </remarks>
     * <returns>This cmdlet returns an array of **VMSwitch** objects, if you specify the **Passthru** parameter.</returns>
     */
    public VMSwitch[] Remove_VMSwitchTeamMember(Remove_VMSwitchTeamMemberArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.NetAdapterInterfaceDescription is not null)
            parameters.Add("NetAdapterInterfaceDescription", args.NetAdapterInterfaceDescription);
        if (args.NetAdapterName is not null)
            parameters.Add("NetAdapterName", args.NetAdapterName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.VMSwitchName is not null)
            parameters.Add("VMSwitchName", args.VMSwitchName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitch>("Remove-VMSwitchTeamMember", parameters);
        return result;
    }

    public class Rename_VMArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which this cmdlet operates.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual machine to be renamed.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the name to which the virtual machine is to be renamed.
         */
        public required string? NewName { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual machine to be renamed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine to be renamed.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/rename-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Renames a virtual machine.
     * </summary>
     * <remarks>
     * The **Rename-VM** cmdlet renames a virtual machine.
     * </remarks>
     */
    public void Rename_VM(Rename_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NewName is not null)
            parameters.Add("NewName", args.NewName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Rename-VM", parameters);
    }

    public class Rename_VMGroupArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the unique ID of the virtual machine group that this cmdlet renames.
         */
        public required Guid? Id { get; set; }

        /**
         * Specifies an array of names of virtual machine groups that this cmdlet renames.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the new name for the virtual machine group.
         */
        public required string? NewName { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VMGroup** object that it renames.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machine groups that this cmdlet renames.
        To obtain a **VMGroup** object, use the **Get-VMGroup** cmdlet.
         */
        public required VMGroup[]? VMGroup { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/rename-vmgroup?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMGroup.md">Get-VMGroup</see>
     *
     * <see href="./New-VMGroup.md">New-VMGroup</see>
     *
     * <see href="./Remove-VMGroup.md">Remove-VMGroup</see>
     * Renames virtual machine groups.
     * </summary>
     * <remarks>
     * The **Rename-VMGroup** cmdlet renames virtual machine groups.
     * </remarks>
     * <returns>This cmdlet returns a **Microsoft.HyperV.PowerShell.VMGroup** object, if you specify the **Passthru** parameter.</returns>
     */
    public VMGroup[] Rename_VMGroup(Rename_VMGroupArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Id is not null)
            parameters.Add("Id", args.Id);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NewName is not null)
            parameters.Add("NewName", args.NewName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMGroup is not null)
            parameters.Add("VMGroup", args.VMGroup);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMGroup>("Rename-VMGroup", parameters);
        return result;
    }

    public class Rename_VMNetworkAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual network adapter is to be renamed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that you want to rename a virtual network adapter that belongs to the management operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the existing name of the virtual network adapter.
         */
        public string? Name { get; set; }

        /**
         * Specifies the new name for the virtual network adapter.
         */
        public required string? NewName { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual network adapter to be renamed.
        This is a **Microsoft.HyperV.PowerShell.VMInternalNetworkAdapter** object, if ManagementOS is specified; otherwise it is a **Microsoft.HyperV.PowerShell.VMNetworkAdapter** object.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine that has the virtual network adapter you want to rename.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine that has the virtual network adapter you want to rename.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual network adapter to be renamed.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/rename-vmnetworkadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Renames a virtual network adapter on a virtual machine or on the management operating system.
     * </summary>
     * <remarks>
     * The **Rename-VMNetworkAdapter** cmdlet renames a virtual network adapter on a virtual machine or on the management operating system.
     * </remarks>
     */
    public void Rename_VMNetworkAdapter(Rename_VMNetworkAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NewName is not null)
            parameters.Add("NewName", args.NewName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Rename-VMNetworkAdapter", parameters);
    }

    public class Rename_VMResourcePoolArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the resource pool is to be renamed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the friendly name of the resource pool to be renamed.
         */
        public required string? Name { get; set; }

        /**
         * Specifies the name to which the specified resource pool is to be renamed.
         */
        public required string? NewName { get; set; }

        /**
         * Specifies that a **VMResourcePool** object is to be passed through to the pipeline representing the resource pool to be renamed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the type of the resource pool to be renamed.
         */
        public required VMResourcePoolType? ResourcePoolType { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/rename-vmresourcepool?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Renames a resource pool on one or more Hyper-V hosts.
     * </summary>
     * <remarks>
     * The **Rename-VMResourcePool** cmdlet renames a resource pool on one or more Hyper-V hosts.
     * </remarks>
     */
    public void Rename_VMResourcePool(Rename_VMResourcePoolArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NewName is not null)
            parameters.Add("NewName", args.NewName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Rename-VMResourcePool", parameters);
    }

    public class Rename_VMSanArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies the name of the Hyper-V host on which the virtual storage area network (SAN) is to be renamed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the current name of the virtual storage area network (SAN) to be renamed.
         */
        public required string? Name { get; set; }

        /**
         * Specifies the new name of the virtual storage area network (SAN) to be renamed.
         */
        public required string? NewName { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the renamed virtual storage area network (SAN).
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/rename-vmsan?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Renames a virtual storage area network (SAN).
     * </summary>
     * <remarks>
     * The **Rename-VMSan** cmdlet renames a virtual storage area network (SAN).
     * </remarks>
     */
    public void Rename_VMSan(Rename_VMSanArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NewName is not null)
            parameters.Add("NewName", args.NewName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Rename-VMSan", parameters);
    }

    public class Rename_VMSwitchArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual switch is to be renamed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual switch to be renamed.
         */
        public required string? Name { get; set; }

        /**
         * Specifies the name to which the virtual switch is to be renamed.
         */
        public required string? NewName { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.EthernetSwitch** object is to be passed through to the pipeline representing the virtual switch to be renamed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual switch to be renamed.
         */
        public required VMSwitch? VMSwitch { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/rename-vmswitch?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Renames a virtual switch.
     * </summary>
     * <remarks>
     * The **Rename-VMSwitch** cmdlet renames a virtual switch.
     * </remarks>
     */
    public void Rename_VMSwitch(Rename_VMSwitchArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NewName is not null)
            parameters.Add("NewName", args.NewName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Rename-VMSwitch", parameters);
    }

    public class Repair_VMArguments
    {
        /**
         * Specifies a compatibility report which includes adjustments to be made during repair.
         */
        public required VMCompatibilityReport? CompatibilityReport { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the newly modified compatibility report.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path of the virtual machine to be repaired.
         */
        public string? Path { get; set; }

        /**
         * Specifies the path to be search for virtual machine snapshots.
         */
        public string? SnapshotFilePath { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/repair-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Repairs one or more virtual machines.
     * </summary>
     * <remarks>
     * The **Repair-VM** cmdlet corrects some issues that can impact the ability to import or move a virtual machine. If Compare-VM determines that an import or move operation would fail for a particular VM, it returns a collection of incompatibilities that need to be fixed before the operation can succeed. Most of these incompatibilities can be fixed by using Set-VM. However, Set-VM does not modify either the path where the VM configuration is stored or the path where the snapshot files are stored. Repair-VM handles these two particular issues in this one specific situation.
     * </remarks>
     */
    public void Repair_VM(Repair_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CompatibilityReport is not null)
            parameters.Add("CompatibilityReport", args.CompatibilityReport);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.SnapshotFilePath is not null)
            parameters.Add("SnapshotFilePath", args.SnapshotFilePath);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Repair-VM", parameters);
    }

    public class Reset_VMReplicationStatisticsArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the replication statistics of a virtual machine are to be reset.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **VMReplication** object is to be passed through to the pipeline representing the replication whose statistics are to be reset.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the replication relationship type of the virtual machine.
        Specify whether the replication relationship is a simple primary to replica or is an extended replication chain.
        The cmdlet resets the replication statistics for the virtual machines that have the replication type that you specify.
         */
        public VMReplicationRelationshipType? ReplicationRelationshipType { get; set; }

        /**
         * Specifies the virtual machine whose replication statistics are to be reset.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose replication statistics are to be reset.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine replication whose replication statistics are to be reset.
         */
        public required VMReplication[]? VMReplication { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/reset-vmreplicationstatistics?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Resets the replication statistics of a virtual machine.
     * </summary>
     * <remarks>
     * The **Reset-VMReplicationStatistics** cmdlet resets the replication statistics of a virtual machine. Statistics accumulated up to that time are deleted, and replication monitoring begins collecting a new set of statistics. If replication health was reported as "Warning", then this operation also changes the health to "Normal".
     * </remarks>
     */
    public void Reset_VMReplicationStatistics(Reset_VMReplicationStatisticsArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ReplicationRelationshipType is not null)
            parameters.Add("ReplicationRelationshipType", args.ReplicationRelationshipType);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMReplication is not null)
            parameters.Add("VMReplication", args.VMReplication);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Reset-VMReplicationStatistics", parameters);
    }

    public class Reset_VMResourceMeteringArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more virtual machine hosts for which resource utilization data is to be reset.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the friendly name of the virtual machine resource pool for which resource utilization data is to be reset.
         */
        public required string? ResourcePoolName { get; set; }

        /**
         * Specifies the resource type of the virtual machine resource pool for which resource utilization data is to be reset.
         */
        public VMResourcePoolType? ResourcePoolType { get; set; }

        /**
         * Specifies the virtual machine for which resource utilization data is to be reset.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the friendly name of the virtual machine for which resource utilization data is to be reset.
         */
        public required string[]? VMName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/reset-vmresourcemetering?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Measure-VM.md">Measure-VM</see>
     *
     * <see href="./Measure-VMResourcePool.md">Measure-VMResourcePool</see>
     * Resets the resource utilization data collected by Hyper-V resource metering.
     * </summary>
     * <remarks>
     * The **Reset-VMResourceMetering** cmdlet resets the resource utilization data collected by Hyper-V resource metering.
    
    When this cmdlet is called, the virtual machine or resource pool resource utilization data collected up to current point of time is deleted. Hyper-V continues to collect resource utilization data after reset.
     * </remarks>
     */
    public void Reset_VMResourceMetering(Reset_VMResourceMeteringArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Reset-VMResourceMetering", parameters);
    }

    public class Resize_VHDArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual hard disk is to be resized.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an object representing the resized virtual hard disk is to be passed through to the pipeline.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to the virtual hard disk that is to be resized.
         */
        public required string[]? Path { get; set; }

        /**
         * Specifies the size to which the virtual hard disk is to be resized.
         */
        public required UInt64? SizeBytes { get; set; }

        /**
         * Specifies that the virtual hard disk is to be resized to its minimum possible size.
         */
        public required SwitchParameter? ToMinimumSize { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/resize-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Resizes a virtual hard disk.
     * </summary>
     * <remarks>
     * The **Resize-VHD** cmdlet changes the maximum physical size of a virtual hard disk. It can expand both VHD and VHDX files but can shrink only VHDX files. The shrink operation fails if it would shrink the virtual disk to less than its minimum size (available through the VHDX object's **MinimumSize** property).
    
    If the virtual disk file connects to a virtual machine's IDE chain, you **cannot** resize the virtual disk while the virtual machine is online. If the virtual disk file connects to a virtual machine's SCSI chain, you **can** resize the virtual disk while the virtual machine is online.
    
    > [!NOTE] > Resize-VHD does not remove empty blocks from a dynamically-expanding virtual hard disk file. Use Optimize-VHD instead.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Resize_VHD(Resize_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.SizeBytes is not null)
            parameters.Add("SizeBytes", args.SizeBytes);
        if (args.ToMinimumSize is not null)
            parameters.Add("ToMinimumSize", args.ToMinimumSize);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Resize-VHD",
            parameters
        );
        return result;
    }

    public class Restart_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine is to be restarted.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         *
         */
        public UInt16? Delay { get; set; }

        /**
         *
         */
        public WaitVMTypes? For { get; set; }

        /**
         * Specifies that no prompt for confirmation is to appear before the virtual machine is restarted.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies the name of the virtual machine to be restarted.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual machine to be restarted.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the duration of the wait, in seconds. When the timeout elapses, **Restart-VM** returns to the command prompt, even if the virtual machine isn't restarted.
        
         * This parameter is only valid with the `-Wait` parameter. The `-Timeout` parameter overrides the `-Wait` parameter's indefinite waiting period.
         */
        public int? Timeout { get; set; }

        /**
         * Specifies the virtual machine to be restarted.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * **Restart-VM** suppresses the PowerShell prompt and blocks the pipeline until the virtual machine has restarted. You can use this parameter in a script to restart the virtual machine and then continue to process when the restart is finished.
        
         * The `-Wait` parameter waits indefinitely for the virtual machine to restart. You can use the `-Timeout` parameter to adjust the timing and the `-For` and `-Delay` parameters to wait for particular services to become available on the restarted virtual machine.
         */
        public required SwitchParameter? Wait { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/restart-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Restarts a virtual machine.
     * </summary>
     * <remarks>
     * The **Restart-VM** cmdlet restarts a virtual machine. Running this cmdlet results in a "hard" restart, like powering the computer down, then back up again. This can result in data loss in the virtual machine.
     * </remarks>
     */
    public void Restart_VM(Restart_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Delay is not null)
            parameters.Add("Delay", args.Delay);
        if (args.For is not null)
            parameters.Add("For", args.For);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Timeout is not null)
            parameters.Add("Timeout", args.Timeout);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.Wait is not null)
            parameters.Add("Wait", args.Wait);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Restart-VM", parameters);
    }

    public class Resume_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine is to be resumed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual machine to be resumed.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual machine to be resumed.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        The cmdlet resumes the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/resume-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Resumes a suspended (paused) virtual machine.
     * </summary>
     * <remarks>
     * The **Resume-VM** cmdlet resumes a suspended (paused) virtual machine.
     * </remarks>
     */
    public void Resume_VM(Resume_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Resume-VM", parameters);
    }

    public class Resume_VMReplicationArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine replication is to be resumed.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Indicates that Hyper-V Replica continues the resynchronization comparisons from where it left off when you resume the virtual machine replication.
         */
        public SwitchParameter? Continue { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet returns a **VMReplication** object.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the replication relationship type of the virtual machine.
        Specify whether the replication relationship is a simple primary to replica or is an extended replication chain.
        The cmdlet resumes the replication of the virtual machines that have the replication type that you specify.
         */
        public VMReplicationRelationshipType? ReplicationRelationshipType { get; set; }

        /**
         * Specifies that resynchronization is to be started for the virtual machine.
        Resynchronization requires significant storage, processor, and network resources.
        We recommend running this process during off-peak hours.
        Use the **Set-VMReplication** cmdlet to specify whether to automatically resynchronize the virtual machine in the future.
         */
        public SwitchParameter? Resynchronize { get; set; }

        /**
         * Specifies when resynchronization should start.
        If not specified, resynchronization starts immediately.
        You can schedule the resynchronization to start up to 7 days later.
         */
        public DateTime? ResynchronizeStartTime { get; set; }

        /**
         * Specifies the virtual machine whose replication is to be resumed.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose replication is to be resumed.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies a virtual machine replication object representing the virtual machine replication to be resumed.
         */
        public required VMReplication[]? VMReplication { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/resume-vmreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Resumes a virtual machine replication that is in a state of Paused, Error, Resynchronization Required, or Suspended.
     * </summary>
     * <remarks>
     * The **Resume-VMReplication** cmdlet resumes replication of a virtual machine with a replication state of Paused, Error, Resynchronization Required, or Suspended.
     * </remarks>
     */
    public void Resume_VMReplication(Resume_VMReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Continue is not null)
            parameters.Add("Continue", args.Continue);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ReplicationRelationshipType is not null)
            parameters.Add("ReplicationRelationshipType", args.ReplicationRelationshipType);
        if (args.Resynchronize is not null)
            parameters.Add("Resynchronize", args.Resynchronize);
        if (args.ResynchronizeStartTime is not null)
            parameters.Add("ResynchronizeStartTime", args.ResynchronizeStartTime);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMReplication is not null)
            parameters.Add("VMReplication", args.VMReplication);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Resume-VMReplication", parameters);
    }

    public class Revoke_VMConnectAccessArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which this cmdlet operates.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **VMConnectAce** is to be passed through to the pipeline for each revocation of access.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the user or users to whom access to connect to a virtual machine or machines is to be revoked.
         */
        public required string[]? UserName { get; set; }

        /**
         * Specifies the unique identifier of a virtual machine or machines to which connect access is to be revoked.
         */
        public required Guid[]? VMId { get; set; }

        /**
         * Specifies the name or names of the virtual machine or machines to which access is being revoked.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/revoke-vmconnectaccess?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Revokes access for one or more users to connect to a one or more virtual machines.
     * </summary>
     * <remarks>
     * The **Revoke-VMConnectAccess** cmdlet revokes access for one or more users to connect to one or more virtual machines. This cmdlet is intended for use in providing other applications with the appropriate permissions required to initiate a session with Virtual Machine Connection. Examples of such applications are Virtual Machine Manager.
     * </remarks>
     */
    public void Revoke_VMConnectAccess(Revoke_VMConnectAccessArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.UserName is not null)
            parameters.Add("UserName", args.UserName);
        if (args.VMId is not null)
            parameters.Add("VMId", args.VMId);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Revoke-VMConnectAccess", parameters);
    }

    public class Save_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine is to be saved.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual machine to be saved.
         */
        public required string[]? Name { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine to be saved.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/save-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Saves a virtual machine.
     * </summary>
     * <remarks>
     * The **Save-VM** cmdlet saves a virtual machine. This is similar to hibernating a physical computer.
     * </remarks>
     */
    public VirtualMachine[] Save_VM(Save_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Save-VM", parameters);
        return result;
    }

    public class Set_VHDArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the parent of a virtual hard disk in a differencing hard disk chain is to be set.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies that the check for identifier mismatch between the parent and child virtual hard disk is to be skipped.
         */
        public SwitchParameter? IgnoreIdMismatch { get; set; }

        /**
         * Specifies the path to the virtual hard disk file of the virtual hard disk representing the leaf node of the virtual hard disk chain.
        Required when performing the operation in online mode.
         */
        public string? LeafPath { get; set; }

        /**
         * Specifies the path to the parent disk of a differencing virtual hard disk.
        Can be performed regardless of whether the disk is online or offline.
         */
        public required string? ParentPath { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual hard disk whose parent is to be set.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to the virtual hard disk file of the virtual hard disk drive whose parent in the virtual hard disk chain is to be set.
         */
        public required string? Path { get; set; }

        /**
         * Specifies the physical sector size, in bytes.
        Valid values are 512 and 4096.
        This parameter is supported only on a VHDX-format disk that is not attached when the operation is initiated.
         */
        public required UInt32? PhysicalSectorSizeBytes { get; set; }

        /**
         * Indicates that the cmdlet modifies the disk identifier of the virtual disk associated with the virtual hard disk file.
        The disk identifier is the SCSI Vital Product Data (VPD) Page 0x83h identifier associated with a disk.
        Use this parameter only for a VHDX-format disk.
         */
        public required SwitchParameter? ResetDiskIdentifier { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Sets properties associated with a virtual hard disk.
     * </summary>
     * <remarks>
     * The **Set-VHD** cmdlet sets the ParentPath or PhysicalSectorSizeBytes properties of a virtual hard disk. The two properties must be set in separate operations.
     * </remarks>
     */
    public Microsoft.Vhd.PowerShell.VirtualHardDisk[] Set_VHD(Set_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.IgnoreIdMismatch is not null)
            parameters.Add("IgnoreIdMismatch", args.IgnoreIdMismatch);
        if (args.LeafPath is not null)
            parameters.Add("LeafPath", args.LeafPath);
        if (args.ParentPath is not null)
            parameters.Add("ParentPath", args.ParentPath);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.PhysicalSectorSizeBytes is not null)
            parameters.Add("PhysicalSectorSizeBytes", args.PhysicalSectorSizeBytes);
        if (args.ResetDiskIdentifier is not null)
            parameters.Add("ResetDiskIdentifier", args.ResetDiskIdentifier);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<Microsoft.Vhd.PowerShell.VirtualHardDisk>(
            "Set-VHD",
            parameters
        );
        return result;
    }

    public class Set_VMArguments
    {
        /**
         * Specifies that no error is to be thrown if the specified path is not verified as accessible by the cluster.
        This parameter is applicable to clustered virtual machines.
         */
        public SwitchParameter? AllowUnverifiedPaths { get; set; }

        /**
         * Specifies whether automatic checkpoints are enabled.
         */
        public Boolean? AutomaticCheckpointsEnabled { get; set; }

        /**
         * Specifies the action to take when the VM encounters a critical error, and exceeds the timeout duration specified by the **AutomaticCriticalErrorActionTimeout** cmdlet.
        The acceptable values for this parameter are: Pause and None.
         */
        public CriticalErrorAction? AutomaticCriticalErrorAction { get; set; }

        /**
         * Specifies the amount of time, in minutes, to wait in critical pause before powering off the virtual machine.
         */
        public int? AutomaticCriticalErrorActionTimeout { get; set; }

        /**
         * Specifies the action the virtual machine is to take upon start.
        Allowed values are **Nothing**, **StartIfRunning**, and **Start**.
         */
        public StartAction? AutomaticStartAction { get; set; }

        /**
         * Specifies the number of seconds by which the virtual machine's start should be delayed.
         */
        public int? AutomaticStartDelay { get; set; }

        /**
         * Specifies the action the virtual machine is to take when the virtual machine host shuts down.
        Allowed values are **TurnOff**, **Save**, and **ShutDown**.
         */
        public StopAction? AutomaticStopAction { get; set; }

        /**
         * Allows you to configure the type of checkpoints created by Hyper-V.
        The acceptable values for this parameter are:
        
         * - Disabled.
        Block creation of checkpoints.
        - Standard.
        Create standard checkpoints.
        - Production.
        Create production checkpoints if supported by guest operating system.
        Otherwise, create standard checkpoints.
        - ProductionOnly.
        Create production checkpoints if supported by guest operating system.
        Otherwise, the operation fails.
         */
        public CheckpointType? CheckpointType { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual machine is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the virtual machine is to be configured to use dynamic memory.
         */
        public SwitchParameter? DynamicMemory { get; set; }

        /**
         * Specifies whether this virtual machine uses guest controlled cache types.
         */
        public Boolean? GuestControlledCacheTypes { get; set; }

        /**
         *
         */
        public UInt64? HighMemoryMappedIoSpace { get; set; }

        /**
         * Specifies whether virtual machine connection in basic mode locks the console after a user disconnects.
         */
        public OnOffState? LockOnDisconnect { get; set; }

        /**
         *
         */
        public UInt32? LowMemoryMappedIoSpace { get; set; }

        /**
         * Specifies the maximum amount of memory that the virtual machine is to be allocated.
        (Applies only to virtual machines using dynamic memory.)
         */
        public Int64? MemoryMaximumBytes { get; set; }

        /**
         * Specifies the minimum amount of memory that the virtual machine is to be allocated.
        (Applies only to virtual machines using dynamic memory.)
         */
        public Int64? MemoryMinimumBytes { get; set; }

        /**
         * Specifies the amount of memory that the virtual machine is to be allocated upon startup.
        (If the virtual machine does not use dynamic memory, then this is the static amount of memory to be allocated.)
         */
        public Int64? MemoryStartupBytes { get; set; }

        /**
         * Specifies the name of the virtual machine to be configured.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the name to which the virtual machine is to be renamed.
         */
        public string? NewVMName { get; set; }

        /**
         * Specifies notes to be associated with the virtual machine.
         */
        public string? Notes { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual machine to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the number of virtual processors for the virtual machine.
         */
        public Int64? ProcessorCount { get; set; }

        /**
         * Specifies the folder in which the Smart Paging file is to be stored.
         */
        public string? SmartPagingFilePath { get; set; }

        /**
         * Specifies the folder in which the virtual machine is to store its snapshot files.
         */
        public string? SnapshotFileLocation { get; set; }

        /**
         * This cmdlet configures the virtual machine to use static memory.
        Specify the amount of static memory to allocate by using the **MemoryStartupBytes** parameter.
         */
        public SwitchParameter? StaticMemory { get; set; }

        /**
         * Specifies the virtual machine to be configured.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VM** cmdlet configures a virtual machine.
     * </remarks>
     */
    public void Set_VM(Set_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowUnverifiedPaths is not null)
            parameters.Add("AllowUnverifiedPaths", args.AllowUnverifiedPaths);
        if (args.AutomaticCheckpointsEnabled is not null)
            parameters.Add("AutomaticCheckpointsEnabled", args.AutomaticCheckpointsEnabled);
        if (args.AutomaticCriticalErrorAction is not null)
            parameters.Add("AutomaticCriticalErrorAction", args.AutomaticCriticalErrorAction);
        if (args.AutomaticCriticalErrorActionTimeout is not null)
            parameters.Add(
                "AutomaticCriticalErrorActionTimeout",
                args.AutomaticCriticalErrorActionTimeout
            );
        if (args.AutomaticStartAction is not null)
            parameters.Add("AutomaticStartAction", args.AutomaticStartAction);
        if (args.AutomaticStartDelay is not null)
            parameters.Add("AutomaticStartDelay", args.AutomaticStartDelay);
        if (args.AutomaticStopAction is not null)
            parameters.Add("AutomaticStopAction", args.AutomaticStopAction);
        if (args.CheckpointType is not null)
            parameters.Add("CheckpointType", args.CheckpointType);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DynamicMemory is not null)
            parameters.Add("DynamicMemory", args.DynamicMemory);
        if (args.GuestControlledCacheTypes is not null)
            parameters.Add("GuestControlledCacheTypes", args.GuestControlledCacheTypes);
        if (args.HighMemoryMappedIoSpace is not null)
            parameters.Add("HighMemoryMappedIoSpace", args.HighMemoryMappedIoSpace);
        if (args.LockOnDisconnect is not null)
            parameters.Add("LockOnDisconnect", args.LockOnDisconnect);
        if (args.LowMemoryMappedIoSpace is not null)
            parameters.Add("LowMemoryMappedIoSpace", args.LowMemoryMappedIoSpace);
        if (args.MemoryMaximumBytes is not null)
            parameters.Add("MemoryMaximumBytes", args.MemoryMaximumBytes);
        if (args.MemoryMinimumBytes is not null)
            parameters.Add("MemoryMinimumBytes", args.MemoryMinimumBytes);
        if (args.MemoryStartupBytes is not null)
            parameters.Add("MemoryStartupBytes", args.MemoryStartupBytes);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NewVMName is not null)
            parameters.Add("NewVMName", args.NewVMName);
        if (args.Notes is not null)
            parameters.Add("Notes", args.Notes);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ProcessorCount is not null)
            parameters.Add("ProcessorCount", args.ProcessorCount);
        if (args.SmartPagingFilePath is not null)
            parameters.Add("SmartPagingFilePath", args.SmartPagingFilePath);
        if (args.SnapshotFileLocation is not null)
            parameters.Add("SnapshotFileLocation", args.SnapshotFileLocation);
        if (args.StaticMemory is not null)
            parameters.Add("StaticMemory", args.StaticMemory);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VM", parameters);
    }

    public class Set_VMBiosArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts for which the BIOS is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that NumLock is to be disabled in the BIOS of the virtual machine to be configured.
         */
        public SwitchParameter? DisableNumLock { get; set; }

        /**
         * Specifies that NumLock is to be enabled in the BIOS of the virtual machine to be configured.
         */
        public SwitchParameter? EnableNumLock { get; set; }

        /**
         * Specifies that an **Microsoft.HyperV.PowerShell.Bios** object is to be passed through to the pipeline representing the BIOS to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of boot devices representing the boot order in the BIOS of the virtual machine.
        The boot devices are specified as members of the **BootDevices** enumeration (**CD**, **IDE**, **LegacyNetworkAdapter**, **Floppy**).
        
         * Note: The other BootDevices enumeration values of VHD and NetworkAdapter are for Generation 2 VMs only, and are not valid with this cmdlet.
         */
        public BootDevice[]? StartupOrder { get; set; }

        /**
         * Specifies the virtual machine for which the BIOS is to be configured.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of BIOS objects.
        The cmdlet configures the BIOS that you specify for the virtual machines.
        To obtain a BIOS object, use the **Get-VMBios** cmdlet.
         */
        public required VMBios[]? VMBios { get; set; }

        /**
         * Specifies the name of the virtual machine for which the BIOS is to be configured.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmbios?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures the BIOS of a Generation 1 virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMBios** cmdlet configures the BIOS of a Generation 1 virtual machine. Note: This cmdlet does not operate with Generation 2 virtual machine. If attempted, the cmdlet throws an error.
     * </remarks>
     */
    public void Set_VMBios(Set_VMBiosArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DisableNumLock is not null)
            parameters.Add("DisableNumLock", args.DisableNumLock);
        if (args.EnableNumLock is not null)
            parameters.Add("EnableNumLock", args.EnableNumLock);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.StartupOrder is not null)
            parameters.Add("StartupOrder", args.StartupOrder);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMBios is not null)
            parameters.Add("VMBios", args.VMBios);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMBios", parameters);
    }

    public class Set_VMComPortArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the COM port of a virtual machine is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the state of the COM port for use by debuggers.
        The acceptable values for this parameter are: On and Off.
         */
        public OnOffState? DebuggerMode { get; set; }

        /**
         * Specifies the Id (1 or 2) of the COM port to be configured.
         */
        public required int? Number { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.ComPort** object is to be passed through to the pipeline representing the COM port to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies a named pipe path for the COM port to be configured.
        Specify local pipes as "\\\\.\pipe\PipeName" and remote pipes as "\\\\RemoteServer\pipe\PipeName".
         */
        public string? Path { get; set; }

        /**
         * Specifies the virtual machine for which the COM port is to be configured.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the COM port to be configured.
         */
        public required VMComPort[]? VMComPort { get; set; }

        /**
         * Specifies the name of the virtual machine for which the COM port is to be configured.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmcomport?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures the COM port of a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMComPort** cmdlet configures the COM port of a virtual machine.
     * </remarks>
     */
    public void Set_VMComPort(Set_VMComPortArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DebuggerMode is not null)
            parameters.Add("DebuggerMode", args.DebuggerMode);
        if (args.Number is not null)
            parameters.Add("Number", args.Number);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMComPort is not null)
            parameters.Add("VMComPort", args.VMComPort);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMComPort", parameters);
    }

    public class Set_VMDvdDriveArguments
    {
        /**
         * Specifies that no error is to be thrown if the specified path is not verified as accessible by the cluster.
        This parameter is applicable to clustered virtual machines.
         */
        public SwitchParameter? AllowUnverifiedPaths { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the DVD drive is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies the IDE controller location of the DVD drives to be configured.
        If not specified, DVD drives in all controller locations are configured.
         */
        public int? ControllerLocation { get; set; }

        /**
         * Specifies the IDE controller of the DVD drives to be configured.
        If not specified, DVD drives attached to all controllers are configured.
         */
        public int? ControllerNumber { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.DvdDrive** object is to be passed through to the pipeline representing the virtual DVD drive to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to the ISO file or physical DVD drive that will serve as media for the virtual DVD drive.
         */
        public string? Path { get; set; }

        /**
         * Specifies the friendly name of the ISO resource pool to which this DVD drive is to be associated.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Specifies the controller location to which this virtual DVD drive should be moved.
         */
        public int? ToControllerLocation { get; set; }

        /**
         * Specifies the controller number to which this VMDvdDrive should be moved.
         */
        public int? ToControllerNumber { get; set; }

        /**
         * Specifies the virtual DVD drive to be configured.
         */
        public required DvdDrive[]? VMDvdDrive { get; set; }

        /**
         * Specifies the name of the virtual machine on which the DVD drive is to be configured.
         */
        public required string? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmdvddrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a virtual DVD drive.
     * </summary>
     * <remarks>
     * The **Set-VMDvdDrive** cmdlet configures the controller and location of a virtual DVD drive.
     * </remarks>
     */
    public void Set_VMDvdDrive(Set_VMDvdDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowUnverifiedPaths is not null)
            parameters.Add("AllowUnverifiedPaths", args.AllowUnverifiedPaths);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.ToControllerLocation is not null)
            parameters.Add("ToControllerLocation", args.ToControllerLocation);
        if (args.ToControllerNumber is not null)
            parameters.Add("ToControllerNumber", args.ToControllerNumber);
        if (args.VMDvdDrive is not null)
            parameters.Add("VMDvdDrive", args.VMDvdDrive);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMDvdDrive", parameters);
    }

    public class Set_VMFibreChannelHbaArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a Fibre Channel host bus adapter is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the World Wide Names for sets A and B are to be generated automatically.
        When this parameter is specified, parameters **WorldWideNodeNameSetA**, **WorldWideNodeNameSetB**, **WorldWidePortNameSetA**, and **WorldWidePortNameSetB** cannot be used.
         */
        public required SwitchParameter? GenerateWwn { get; set; }

        /**
         * Specifies the World Wide Node name of address set A to be associated with the Fibre Channel host bus adapter.
         */
        public string? NewWorldWideNodeNameSetA { get; set; }

        /**
         * Specifies the World Wide Node name of address set B to be associated with the Fibre Channel host bus adapter.
         */
        public string? NewWorldWideNodeNameSetB { get; set; }

        /**
         * Specifies the World Wide Port name of address set A to be associated with the Fibre Channel host bus adapter.
         */
        public string? NewWorldWidePortNameSetA { get; set; }

        /**
         * Specifies the World Wide Port name of address set B to be associated with the Fibre Channel host bus adapter.
         */
        public string? NewWorldWidePortNameSetB { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the configured Fibre Channel host bus adapter.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual storage area network (SAN) to be associated with the Fibre Channel host bus adapter.
         */
        public required string? SanName { get; set; }

        /**
         * Specifies the Fibre Channel host bus adapter to be configured.
         */
        public required VMFibreChannelHba? VMFibreChannelHba { get; set; }

        /**
         * Specifies the name of the virtual machine to which the virtual Fibre Channel host bus adapter parameters are to be set.
         */
        public required string? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }

        /**
         * Specifies the World Wide Node name of address set A that is associated with the Fibre Channel host bus adapter.
         */
        public required string? WorldWideNodeNameSetA { get; set; }

        /**
         * Specifies the World Wide Node name of address set B that is associated with the Fibre Channel host bus adapter.
         */
        public required string? WorldWideNodeNameSetB { get; set; }

        /**
         * Specifies the World Wide Port name of address set A that is associated with the Fibre Channel host bus adapter.
         */
        public required string? WorldWidePortNameSetA { get; set; }

        /**
         * Specifies the World Wide Port name of address set B that is associated with the Fibre Channel host bus adapter.
         */
        public required string? WorldWidePortNameSetB { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmfibrechannelhba?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a Fibre Channel host bus adapter on a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMFibreChannelHba** cmdlet configures a Fibre Channel host bus adapter on a virtual machine.
     * </remarks>
     */
    public VMFibreChannelHba[] Set_VMFibreChannelHba(Set_VMFibreChannelHbaArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.GenerateWwn is not null)
            parameters.Add("GenerateWwn", args.GenerateWwn);
        if (args.NewWorldWideNodeNameSetA is not null)
            parameters.Add("NewWorldWideNodeNameSetA", args.NewWorldWideNodeNameSetA);
        if (args.NewWorldWideNodeNameSetB is not null)
            parameters.Add("NewWorldWideNodeNameSetB", args.NewWorldWideNodeNameSetB);
        if (args.NewWorldWidePortNameSetA is not null)
            parameters.Add("NewWorldWidePortNameSetA", args.NewWorldWidePortNameSetA);
        if (args.NewWorldWidePortNameSetB is not null)
            parameters.Add("NewWorldWidePortNameSetB", args.NewWorldWidePortNameSetB);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SanName is not null)
            parameters.Add("SanName", args.SanName);
        if (args.VMFibreChannelHba is not null)
            parameters.Add("VMFibreChannelHba", args.VMFibreChannelHba);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        if (args.WorldWideNodeNameSetA is not null)
            parameters.Add("WorldWideNodeNameSetA", args.WorldWideNodeNameSetA);
        if (args.WorldWideNodeNameSetB is not null)
            parameters.Add("WorldWideNodeNameSetB", args.WorldWideNodeNameSetB);
        if (args.WorldWidePortNameSetA is not null)
            parameters.Add("WorldWidePortNameSetA", args.WorldWidePortNameSetA);
        if (args.WorldWidePortNameSetB is not null)
            parameters.Add("WorldWidePortNameSetB", args.WorldWidePortNameSetB);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMFibreChannelHba>(
            "Set-VMFibreChannelHba",
            parameters
        );
        return result;
    }

    public class Set_VMFirmwareArguments
    {
        /**
         * Specifies an array of devices.
        The boot order determines the order of the devices from which to boot.
        The acceptable values for this parameter are:
        
         * -- VMBootSource
        
         * -- VMNetworkAdapter
        
         * -- HardDiskDrive
        
         * -- DVDDrive
        
         * The VMBootSource value describes a boot entry in firmware nonvolatile Random Access Memory (NVRAM).
         */
        public VMComponentObject[]? BootOrder { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies the names of the Hyper-V hosts whose firmware configuration you want to modify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies the console mode type for the virtual machine.
        This parameter allows a virtual machine to run without graphical user interface.
         */
        public ConsoleModeType? ConsoleMode { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies whether to enable secure boot.
        The acceptable values for this parameter are:
        
         * -- On
        
         * -- Off
        
         * Secure boot uses a public key infrastructure that protects the integrity of the operating system.
         */
        public OnOffState? EnableSecureBoot { get; set; }

        /**
         * Specifies the device from which to attempt to boot from first.
        The acceptable values for this parameter are:
        
         * -- VMBootSource
        
         * -- VMNetworkAdapter
        
         * -- HardDiskDrive
        
         * -- DVDDrive
        
         * The VMBootSource value describes a boot entry in firmware NVRAM.
         */
        public VMComponentObject? FirstBootDevice { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the behavior of the virtual machine after a start failure.
        For a value of On, if the virtual machine fails to start correctly from a device, the virtual machine is paused.
         */
        public OnOffState? PauseAfterBootFailure { get; set; }

        /**
         * Specifies the IP protocol version to use during a network boot.
         */
        public IPProtocolPreference? PreferredNetworkBootProtocol { get; set; }

        /**
         * Specifies the name of the secure boot template.
        If secure boot is enabled, you must have a valid secure boot template for the guest operating system to start.
         */
        public string? SecureBootTemplate { get; set; }

        /**
         * Specifies the ID of the secure boot template.
         */
        public Guid? SecureBootTemplateId { get; set; }

        /**
         * Specifies the virtual machine objects for which want to modify the firmware configuration.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of virtual machine firmware configurations.
        The cmdlet sets the firmware configurations you specify.
         */
        public required VMFirmware[]? VMFirmware { get; set; }

        /**
         * Specifies an array of names of virtual machines for which you want to modify the firmware configuration.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmfirmware?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMFirmware.md">Get-VMFirmware</see>
     * Sets the firmware configuration of a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMFirmware** cmdlet sets the firmware configuration of a Generation 2 virtual machine.
     * </remarks>
     */
    public VMFirmware[] Set_VMFirmware(Set_VMFirmwareArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.BootOrder is not null)
            parameters.Add("BootOrder", args.BootOrder);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ConsoleMode is not null)
            parameters.Add("ConsoleMode", args.ConsoleMode);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.EnableSecureBoot is not null)
            parameters.Add("EnableSecureBoot", args.EnableSecureBoot);
        if (args.FirstBootDevice is not null)
            parameters.Add("FirstBootDevice", args.FirstBootDevice);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.PauseAfterBootFailure is not null)
            parameters.Add("PauseAfterBootFailure", args.PauseAfterBootFailure);
        if (args.PreferredNetworkBootProtocol is not null)
            parameters.Add("PreferredNetworkBootProtocol", args.PreferredNetworkBootProtocol);
        if (args.SecureBootTemplate is not null)
            parameters.Add("SecureBootTemplate", args.SecureBootTemplate);
        if (args.SecureBootTemplateId is not null)
            parameters.Add("SecureBootTemplateId", args.SecureBootTemplateId);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMFirmware is not null)
            parameters.Add("VMFirmware", args.VMFirmware);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMFirmware>("Set-VMFirmware", parameters);
        return result;
    }

    public class Set_VMFloppyDiskDriveArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual floppy disk drive is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.FloppyDiskDrive** object is to be passed through to the pipeline representing the virtual floppy disk drive to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to the virtual floppy drive file.
        If specified as **$null**, the drive is set to contain no media.
         */
        public string? Path { get; set; }

        /**
         * Specifies the name of the virtual floppy disk resource pool to use for this virtual floppy disk.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Specifies the virtual machine in which the virtual floppy disk drive is to be configured.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the virtual floppy disk drive to be configured.
         */
        public required VMFloppyDiskDrive[]? VMFloppyDiskDrive { get; set; }

        /**
         * Specifies the name of the virtual machine on which the virtual floppy disk drive is to be configured.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmfloppydiskdrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a virtual floppy disk drive.
     * </summary>
     * <remarks>
     * The **Set-VMFloppyDiskDrive** cmdlet configures a virtual floppy disk drive.
     * </remarks>
     */
    public VMFloppyDiskDrive[] Set_VMFloppyDiskDrive(Set_VMFloppyDiskDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMFloppyDiskDrive is not null)
            parameters.Add("VMFloppyDiskDrive", args.VMFloppyDiskDrive);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMFloppyDiskDrive>(
            "Set-VMFloppyDiskDrive",
            parameters
        );
        return result;
    }

    public class Set_VMGpuPartitionAdapterArguments
    {
        /**
         * A VM's GPU partition identification number used to display the GPU information assigned to a VM.
         */
        public string? AdapterId { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on the virtual network adapters are to be retrieved. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * The maximum number of compute assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MaxPartitionCompute { get; set; }

        /**
         * The maximum number of decoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MaxPartitionDecode { get; set; }

        /**
         * The maximum number of encoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MaxPartitionEncode { get; set; }

        /**
         * The maximum VRAM in bytes supported by the host GPU. This is defined by the manufacturer's driver.
         */
        public UInt64? MaxPartitionVRAM { get; set; }

        /**
         * The minimum number of compute assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MinPartitionCompute { get; set; }

        /**
         * The minimum number of decoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MinPartitionDecode { get; set; }

        /**
         * The minimum number of encoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? MinPartitionEncode { get; set; }

        /**
         * The minimum VRAM in bytes supported by the host GPU. This is defined by the manufacturer's driver.
         */
        public UInt64? MinPartitionVRAM { get; set; }

        /**
         * The optimal number of compute assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? OptimalPartitionCompute { get; set; }

        /**
         * The optimal number of decoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? OptimalPartitionDecode { get; set; }

        /**
         * The optimal number of encoders assigned by the host GPU. This is defined by the manufacturer's
        driver.
         */
        public UInt64? OptimalPartitionEncode { get; set; }

        /**
         * The optimal VRAM in bytes supported by the host GPU. This is defined by the manufacturer's driver.
         */
        public UInt64? OptimalPartitionVRAM { get; set; }

        /**
         * Returns an object for each process that the cmdlet started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine whose virtual network adapters are to be retrieved. The asterisk (`*`)
        is the wildcard. If it is specified the cmdlet returns virtual network adapters from every virtual
        machine in the system.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * GPU partition object obtained from `Get-VMGpuPartitionAdapter`.
         */
        public required VMGpuPartitionAdapter[]? VMGpuPartitionAdapter { get; set; }

        /**
         * Specifies the name of the virtual machine whose network adapters are to be configured.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs. The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmgpupartitionadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="add-vmgpupartitionadapter.md">Add-VMGpuPartitionAdapter</see>
     *
     * <see href="get-vmgpupartitionadapter.md">Get-VMGpuPartitionAdapter</see>
     *
     * <see href="remove-vmgpupartitionadapter.md">Remove-VMGpuPartitionAdapter</see>
     * Assigns a partition of a GPU to a virtual machine.
     * </summary>
     * <remarks>
     * The `Set-VMGpuPartitionAdapter` cmdlet assigns a partition of a GPU to a virtual machine. Running the command against a virtual machine assigns a full partition. Additional parameters exist to assign more specific options to a VM.
     * </remarks>
     */
    public VMGpuPartitionAdapter[] Set_VMGpuPartitionAdapter(
        Set_VMGpuPartitionAdapterArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.AdapterId is not null)
            parameters.Add("AdapterId", args.AdapterId);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.MaxPartitionCompute is not null)
            parameters.Add("MaxPartitionCompute", args.MaxPartitionCompute);
        if (args.MaxPartitionDecode is not null)
            parameters.Add("MaxPartitionDecode", args.MaxPartitionDecode);
        if (args.MaxPartitionEncode is not null)
            parameters.Add("MaxPartitionEncode", args.MaxPartitionEncode);
        if (args.MaxPartitionVRAM is not null)
            parameters.Add("MaxPartitionVRAM", args.MaxPartitionVRAM);
        if (args.MinPartitionCompute is not null)
            parameters.Add("MinPartitionCompute", args.MinPartitionCompute);
        if (args.MinPartitionDecode is not null)
            parameters.Add("MinPartitionDecode", args.MinPartitionDecode);
        if (args.MinPartitionEncode is not null)
            parameters.Add("MinPartitionEncode", args.MinPartitionEncode);
        if (args.MinPartitionVRAM is not null)
            parameters.Add("MinPartitionVRAM", args.MinPartitionVRAM);
        if (args.OptimalPartitionCompute is not null)
            parameters.Add("OptimalPartitionCompute", args.OptimalPartitionCompute);
        if (args.OptimalPartitionDecode is not null)
            parameters.Add("OptimalPartitionDecode", args.OptimalPartitionDecode);
        if (args.OptimalPartitionEncode is not null)
            parameters.Add("OptimalPartitionEncode", args.OptimalPartitionEncode);
        if (args.OptimalPartitionVRAM is not null)
            parameters.Add("OptimalPartitionVRAM", args.OptimalPartitionVRAM);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMGpuPartitionAdapter is not null)
            parameters.Add("VMGpuPartitionAdapter", args.VMGpuPartitionAdapter);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMGpuPartitionAdapter>(
            "Set-VMGpuPartitionAdapter",
            parameters
        );
        return result;
    }

    public class Set_VMHardDiskDriveArguments
    {
        /**
         * Specifies that no error is to be thrown if the specified path is not verified as accessible by the cluster.
        This parameter is applicable to clustered virtual machines.
         */
        public SwitchParameter? AllowUnverifiedPaths { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual hard drive is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies the number of the location on the controller to which the virtual hard drive to be configured is attached.
        If not specified, all hard drives are configured.
         */
        public int? ControllerLocation { get; set; }

        /**
         * Specifies the number of the controller to which the virtual hard drive to be configured is attached.
        If not specified, all hard drives are configured.
         */
        public int? ControllerNumber { get; set; }

        /**
         * Specifies the type of the controller to which the virtual hard drive to be configured is attached.
        Allowed values are **Floppy**, **IDE**, and **SCSI**.
         */
        public ControllerType? ControllerType { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the disk number of the offline physical hard drive that should be connected as a passthrough disk.
         */
        public UInt32? DiskNumber { get; set; }

        /**
         * Specifies the maximum normalized I/O operations per second (IOPS) for the hard disk.
        Hyper-V calculates normalized IOPS as the total size of I/O per second divided by 8 KB.
         */
        public UInt64? MaximumIOPS { get; set; }

        /**
         * Specifies the minimum normalized I/O operations per second (IOPS) for the hard disk.
        Hyper-V calculates normalized IOPS as the total size of I/O per second divided by 8 KB.
         */
        public UInt64? MinimumIOPS { get; set; }

        /**
         *
         */
        public CacheAttributes? OverrideCacheAttributes { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.HardDiskDrive** object is to be passed through to the pipeline representing the virtual hard drive to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the path to media the virtual hard disk is to use.
         */
        public string? Path { get; set; }

        /**
         * Specifies the storage Quality of Service (QoS) policy to associate with the hard disk drive.
         */
        public CimInstance? QoSPolicy { get; set; }

        /**
         * Specifies the ID for a storage QoS policy to associate with the hard disk drive.
         */
        public string? QoSPolicyID { get; set; }

        /**
         * Specifies the name of the virtual hard disk resource pool to which this drive belongs.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Indicates whether the hard disk supports SCSI persistent reservation semantics.
        Specify this parameter when the hard disk is a shared disk that is used by multiple virtual machines.
         */
        public Boolean? SupportPersistentReservations { get; set; }

        /**
         * Specifies the controller location to which this drive should be moved.
        Allowed values are 0 and 1 for IDE controllers, and from 0 to 63 for SCSI controllers.
         */
        public int? ToControllerLocation { get; set; }

        /**
         * Specifies the controller location to which this drive should be moved.
        Allowed values are 0 and 1 for IDE controllers, and from 0 to 3 for SCSI controllers.
         */
        public int? ToControllerNumber { get; set; }

        /**
         * Specifies the type of controller to which this drive should be moved.
        Allowed values are IDE and SCSI.
         */
        public ControllerType? ToControllerType { get; set; }

        /**
         * Specifies one or more hard disks to be configured.
         */
        public required HardDiskDrive[]? VMHardDiskDrive { get; set; }

        /**
         * Specifies the name of the virtual machine on which the virtual hard drive is to be configured.
         */
        public required string? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmharddiskdrive?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a virtual hard disk.
     * </summary>
     * <remarks>
     * The **Set-VMHardDiskDrive** cmdlet configures a virtual hard disk.
     * </remarks>
     */
    public HardDiskDrive[] Set_VMHardDiskDrive(Set_VMHardDiskDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowUnverifiedPaths is not null)
            parameters.Add("AllowUnverifiedPaths", args.AllowUnverifiedPaths);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.ControllerType is not null)
            parameters.Add("ControllerType", args.ControllerType);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DiskNumber is not null)
            parameters.Add("DiskNumber", args.DiskNumber);
        if (args.MaximumIOPS is not null)
            parameters.Add("MaximumIOPS", args.MaximumIOPS);
        if (args.MinimumIOPS is not null)
            parameters.Add("MinimumIOPS", args.MinimumIOPS);
        if (args.OverrideCacheAttributes is not null)
            parameters.Add("OverrideCacheAttributes", args.OverrideCacheAttributes);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.QoSPolicy is not null)
            parameters.Add("QoSPolicy", args.QoSPolicy);
        if (args.QoSPolicyID is not null)
            parameters.Add("QoSPolicyID", args.QoSPolicyID);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.SupportPersistentReservations is not null)
            parameters.Add("SupportPersistentReservations", args.SupportPersistentReservations);
        if (args.ToControllerLocation is not null)
            parameters.Add("ToControllerLocation", args.ToControllerLocation);
        if (args.ToControllerNumber is not null)
            parameters.Add("ToControllerNumber", args.ToControllerNumber);
        if (args.ToControllerType is not null)
            parameters.Add("ToControllerType", args.ToControllerType);
        if (args.VMHardDiskDrive is not null)
            parameters.Add("VMHardDiskDrive", args.VMHardDiskDrive);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<HardDiskDrive>("Set-VMHardDiskDrive", parameters);
        return result;
    }

    public class Set_VMHostArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which this cmdlet operates.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates whether users can use enhanced mode when they connect to virtual machines on this server by using Virtual Machine Connection.
         */
        public Boolean? EnableEnhancedSessionMode { get; set; }

        /**
         * Specifies the default  value of the World Wide Node Name  on the Hyper-V host.
         */
        public string? FibreChannelWwnn { get; set; }

        /**
         * Specifies the maximum value that can be used to generate World Wide Port Names on the Hyper-V host.
        Use with the **FibreChannelWwpnMinimum** parameter to establish a range of WWPNs that the specified Hyper-V host can assign to virtual Fibre Channel adapters.
         */
        public string? FibreChannelWwpnMaximum { get; set; }

        /**
         * Specifies the minimum value that can be used to generate the World Wide Port Names on the Hyper-V host.
        Use with the **FibreChannelWwpnMaximum** parameter to establish a range of WWPNs that the specified Hyper-V host can assign to virtual Fibre Channel adapters.
         */
        public string? FibreChannelWwpnMinimum { get; set; }

        /**
         * Specifies the maximum MAC address using a valid hexadecimal value.
        Use with the **MacAddressMinimum** parameter to establish a range of MAC addresses that the specified Hyper-V host can assign to virtual machines configured to receive dynamic MAC addresses.
         */
        public string? MacAddressMaximum { get; set; }

        /**
         * Specifies the minimum MAC address using a valid hexadecimal value.
        Use with the **MacAddressMaximum** parameter to establish a range of MAC addresses that the specified Hyper-V host can assign to virtual machines configured to receive dynamic MAC addresses.
         */
        public string? MacAddressMinimum { get; set; }

        /**
         * Specifies the maximum number of storage migrations that can be performed at the same time on the Hyper-V host.
         */
        public UInt32? MaximumStorageMigrations { get; set; }

        /**
         * Specifies the maximum number of live migrations that can be performed at the same time on the
        Hyper-V host. If your host is part a Failover Cluster, the cluster property takes precedence any
        values set by the **MaximumVirtualMachineMigrations** parameter. To check the cluster property,
        you can run the PowerShell command `(Get-Cluster).MaximumParallelMigrations`.
         */
        public UInt32? MaximumVirtualMachineMigrations { get; set; }

        /**
         * Specifies whether virtual machines on the Hyper-V host can use resources from more than one NUMA node.
         */
        public Boolean? NumaSpanningEnabled { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.Host** is to be passed through to the pipeline representing the Hyper-V host to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies how often the Hyper-V host saves the data that tracks resource usage.
        The range is a minimum of 1 hour to a maximum of 24 hours.
        Time within that range can be specified using a format of hh:mm:ss, where hh indicates hours, mm indicates minutes, and ss indicates seconds.
        You also can use a Timespan object to specify the interval.
         */
        public TimeSpan? ResourceMeteringSaveInterval { get; set; }

        /**
         * Specifies how networks are selected for incoming live migration traffic.
        If set to $True, any available network on the host can be used for this traffic.
        If set to $False, incoming live migration traffic is transmitted only on the networks specified in the **MigrationNetworks** property of the host.
        The **Get-VMMigrationNetwork** cmdlet returns the list of networks that can be used for migration traffic.
         */
        public Boolean? UseAnyNetworkForMigration { get; set; }

        /**
         * Specifies the default folder to store virtual hard disks on the Hyper-V host. This is not a functional setting. The Hyper-V Manager snap-in and Windows Admin Center query it to offer you a default path, but the Hyper-V API (for example `CreateFixedVirtualHardDisk`) and `New-VHD` don't use it.
         */
        public string? VirtualHardDiskPath { get; set; }

        /**
         * Specifies the type of authentication to be used for live migrations.
        The acceptable values for this parameter are: Kerberos and CredSSP.
         */
        public MigrationAuthenticationType? VirtualMachineMigrationAuthenticationType { get; set; }

        /**
         * Specifies the performance option to use for live migration.
        The acceptable values for this parameter are:
        
         * - Compression.
        Compress data to speed up live migration on constrained networks.
        - SMBTransport.
        Use server message block (SMB) to get the highest throughput possible.
        - None.
        Perform standard live migration.
         */
        public VMMigrationPerformance? VirtualMachineMigrationPerformanceOption { get; set; }

        /**
         * Specifies the default folder to store virtual machine configuration files on the Hyper-V host. This is a functional setting, meaning that if you do not supply a path to VM creation tools (for example `New-VM`), Hyper-V will use this path. Hyper-V will create at least one subfolder in this path, called "Virtual Machines".
         */
        public string? VirtualMachinePath { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmhost?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a Hyper-V host.
     * </summary>
     * <remarks>
     * The **Set-VMHost** cmdlet configures a Hyper-V host.
     * </remarks>
     */
    public void Set_VMHost(Set_VMHostArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.EnableEnhancedSessionMode is not null)
            parameters.Add("EnableEnhancedSessionMode", args.EnableEnhancedSessionMode);
        if (args.FibreChannelWwnn is not null)
            parameters.Add("FibreChannelWwnn", args.FibreChannelWwnn);
        if (args.FibreChannelWwpnMaximum is not null)
            parameters.Add("FibreChannelWwpnMaximum", args.FibreChannelWwpnMaximum);
        if (args.FibreChannelWwpnMinimum is not null)
            parameters.Add("FibreChannelWwpnMinimum", args.FibreChannelWwpnMinimum);
        if (args.MacAddressMaximum is not null)
            parameters.Add("MacAddressMaximum", args.MacAddressMaximum);
        if (args.MacAddressMinimum is not null)
            parameters.Add("MacAddressMinimum", args.MacAddressMinimum);
        if (args.MaximumStorageMigrations is not null)
            parameters.Add("MaximumStorageMigrations", args.MaximumStorageMigrations);
        if (args.MaximumVirtualMachineMigrations is not null)
            parameters.Add("MaximumVirtualMachineMigrations", args.MaximumVirtualMachineMigrations);
        if (args.NumaSpanningEnabled is not null)
            parameters.Add("NumaSpanningEnabled", args.NumaSpanningEnabled);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ResourceMeteringSaveInterval is not null)
            parameters.Add("ResourceMeteringSaveInterval", args.ResourceMeteringSaveInterval);
        if (args.UseAnyNetworkForMigration is not null)
            parameters.Add("UseAnyNetworkForMigration", args.UseAnyNetworkForMigration);
        if (args.VirtualHardDiskPath is not null)
            parameters.Add("VirtualHardDiskPath", args.VirtualHardDiskPath);
        if (args.VirtualMachineMigrationAuthenticationType is not null)
            parameters.Add(
                "VirtualMachineMigrationAuthenticationType",
                args.VirtualMachineMigrationAuthenticationType
            );
        if (args.VirtualMachineMigrationPerformanceOption is not null)
            parameters.Add(
                "VirtualMachineMigrationPerformanceOption",
                args.VirtualMachineMigrationPerformanceOption
            );
        if (args.VirtualMachinePath is not null)
            parameters.Add("VirtualMachinePath", args.VirtualMachinePath);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMHost", parameters);
    }

    public class Set_VMHostClusterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of names of the virtual machine host clusters that this cmdlet configures.
         */
        public required string[]? ClusterName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies an array of virtual machine host clusters that this cmdlet configures.
        To obtain a **VMHostCluster** object, use the **Get-VMHostCluster** cmdlet.
         */
        public required VMHostCluster[]? InputObject { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VMHostCluster** object that it configures.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the location of the shared storage for the virtual machine host cluster.
         */
        public string? SharedStoragePath { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmhostcluster?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMHostCluster.md">Get-VMHostCluster</see>
     * Configures a virtual machine host cluster.
     * </summary>
     * <remarks>
     * The **Set-VMHostCluster** cmdlet configures a virtual machine host cluster.
     * </remarks>
     * <returns>This cmdlet returns a **VMHostCluster** object, if you specify the **Passthru** parameter.</returns>
     */
    public VMHostCluster[] Set_VMHostCluster(Set_VMHostClusterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ClusterName is not null)
            parameters.Add("ClusterName", args.ClusterName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.InputObject is not null)
            parameters.Add("InputObject", args.InputObject);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SharedStoragePath is not null)
            parameters.Add("SharedStoragePath", args.SharedStoragePath);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHostCluster>("Set-VMHostCluster", parameters);
        return result;
    }

    public class Set_VMHostPartitionableGpuArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer. Enter a computer name or a session
        object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession)
        or [Get-CimSession](/powershell/module/cimcmdlets/get-cimsession) cmdlet. The default is the
        current session on the local computer.
         */
        public required CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on the virtual network adapters are to be retrieved. NetBIOS
        names, IP addresses, and fully qualified domain names are allowed. The default is the local
        computer. Use localhost or a dot (`.`) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action. The default is the
        current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Full GPU object, obtained by executing `Get-VMHostPartitionableGpu`.
         */
        public required VMHostPartitionableGpu[]? HostPartitionableGpu { get; set; }

        /**
         * Specifies the name of the GPU.
         */
        public string? Name { get; set; }

        /**
         * Specifies the number of partitions that the GPU will assign. The number of partitions is defined by
        the manufacturer.
         */
        public UInt16? PartitionCount { get; set; }

        /**
         * Returns an object for each process that the cmdlet started.
         */
        public SwitchParameter? Passthru { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmhostpartitionablegpu?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="get-vmhostpartitionablegpu.md">Get-VMHostPartitionableGpu</see>
     * Configures the host partitionable GPU to the number of partitions supported by the manufacturer.
     * </summary>
     * <remarks>
     * The `Set-VMHostPartitionableGpu` cmdlet configures the host partitionable GPU to the number of partitions supported by the manufacturer.
     * </remarks>
     */
    public VMHostPartitionableGpu[] Set_VMHostPartitionableGpu(
        Set_VMHostPartitionableGpuArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.HostPartitionableGpu is not null)
            parameters.Add("HostPartitionableGpu", args.HostPartitionableGpu);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.PartitionCount is not null)
            parameters.Add("PartitionCount", args.PartitionCount);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMHostPartitionableGpu>(
            "Set-VMHostPartitionableGpu",
            parameters
        );
        return result;
    }

    public class Set_VMKeyProtectorArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts to run the cmdlet.
        NetBIOS names, IP addresses, and fully-qualified domain names are allowable.
        The default is the local computer.
        Use "localhost" or a dot (".") to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies a user account that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the key protector to use for the virtual machine.
         */
        public Byte[]? KeyProtector { get; set; }

        /**
         * Specifies that this cmdlet generates a new local key protector.
         */
        public SwitchParameter? NewLocalKeyProtector { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Indicates that this cmdlet restores the last known good key protector.
         */
        public SwitchParameter? RestoreLastKnownGoodKeyProtector { get; set; }

        /**
         * Specifies one or more virtual machines for which to set a key protector.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of one or more virtual machines for which to set a key protector.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmkeyprotector?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMKeyProtector.md">Get-VMKeyProtector</see>
     * Configures a key protector for a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMKeyProtector** cmdlet configures a key protector for a virtual machine.
     * </remarks>
     */
    public VirtualMachine[] Set_VMKeyProtector(Set_VMKeyProtectorArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.KeyProtector is not null)
            parameters.Add("KeyProtector", args.KeyProtector);
        if (args.NewLocalKeyProtector is not null)
            parameters.Add("NewLocalKeyProtector", args.NewLocalKeyProtector);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RestoreLastKnownGoodKeyProtector is not null)
            parameters.Add(
                "RestoreLastKnownGoodKeyProtector",
                args.RestoreLastKnownGoodKeyProtector
            );
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Set-VMKeyProtector", parameters);
        return result;
    }

    public class Set_VMKeyStorageDriveArguments
    {
        public object? AllowUnverifiedPaths { get; set; }
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public object? Confirm { get; set; }
        public int? ControllerLocation { get; set; }
        public int? ControllerNumber { get; set; }
        public PSCredential[]? Credential { get; set; }
        public object? Passthru { get; set; }
        public string? ResourcePoolName { get; set; }
        public int? ToControllerLocation { get; set; }
        public int? ToControllerNumber { get; set; }
        public required KeyStorageDrive[]? VMKeyStorageDrive { get; set; }
        public required string? VMName { get; set; }
        public object? WhatIf { get; set; }
    }

    /** <summary>
     *
     * Set-VMKeyStorageDrive [-VMName] <string> [[-ControllerNumber] <int>] [[-ControllerLocation] <int>] [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-ToControllerNumber <int>] [-ToControllerLocation <int>] [-ResourcePoolName <string>] [-AllowUnverifiedPaths] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * Set-VMKeyStorageDrive [-VMKeyStorageDrive] <KeyStorageDrive[]> [-ToControllerNumber <int>] [-ToControllerLocation <int>] [-ResourcePoolName <string>] [-AllowUnverifiedPaths] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public KeyStorageDrive[] Set_VMKeyStorageDrive(Set_VMKeyStorageDriveArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowUnverifiedPaths is not null)
            parameters.Add("AllowUnverifiedPaths", args.AllowUnverifiedPaths);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.ControllerLocation is not null)
            parameters.Add("ControllerLocation", args.ControllerLocation);
        if (args.ControllerNumber is not null)
            parameters.Add("ControllerNumber", args.ControllerNumber);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.ToControllerLocation is not null)
            parameters.Add("ToControllerLocation", args.ToControllerLocation);
        if (args.ToControllerNumber is not null)
            parameters.Add("ToControllerNumber", args.ToControllerNumber);
        if (args.VMKeyStorageDrive is not null)
            parameters.Add("VMKeyStorageDrive", args.VMKeyStorageDrive);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<KeyStorageDrive>("Set-VMKeyStorageDrive", parameters);
        return result;
    }

    public class Set_VMMemoryArguments
    {
        /**
         * Specifies the percentage of memory to reserve as a buffer in the virtual machine to be configured.
        Allowed values range from 5 to 2000.
         */
        public int? Buffer { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the memory of a virtual machine is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies whether dynamic memory is to be enabled on the virtual machine to be configured.
         */
        public Boolean? DynamicMemoryEnabled { get; set; }

        /**
         * Specifies the maximum amount of memory per NUMA node in the virtual machine to be configured.
         */
        public Int64? MaximumAmountPerNumaNodeBytes { get; set; }

        /**
         * Specifies the maximum amount of memory to be used by a virtual machine which has dynamic memory enabled.
         */
        public Int64? MaximumBytes { get; set; }

        /**
         * Specifies the minimum amount of memory to be used by a virtual machine which has dynamic memory enabled.
         */
        public Int64? MinimumBytes { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.Memory** object is to be passed through to the pipeline representing the virtual machine memory to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Sets the priority for memory availability to this virtual machine relative to other virtual machines on the virtual machine host.
        Allowed values range from 0 to 100.
         */
        public int? Priority { get; set; }

        /**
         * Specifies the name of the memory resource pool for this virtual machine.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Specifies the initial amount of memory to be assigned to a virtual machine with dynamic memory enabled, or the total amount of memory to be assigned to a virtual machine with dynamic memory disabled.
         */
        public Int64? StartupBytes { get; set; }

        /**
         * Specifies the virtual machine whose memory is to be configured.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the virtual machine memory to be configured.
         */
        public required VMMemory[]? VMMemory { get; set; }

        /**
         * Specifies the name of the virtual machine whose memory is to be configured.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmmemory?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures the memory of a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMMemory** cmdlet configures the memory of a virtual machine.
     * </remarks>
     */
    public void Set_VMMemory(Set_VMMemoryArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.Buffer is not null)
            parameters.Add("Buffer", args.Buffer);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DynamicMemoryEnabled is not null)
            parameters.Add("DynamicMemoryEnabled", args.DynamicMemoryEnabled);
        if (args.MaximumAmountPerNumaNodeBytes is not null)
            parameters.Add("MaximumAmountPerNumaNodeBytes", args.MaximumAmountPerNumaNodeBytes);
        if (args.MaximumBytes is not null)
            parameters.Add("MaximumBytes", args.MaximumBytes);
        if (args.MinimumBytes is not null)
            parameters.Add("MinimumBytes", args.MinimumBytes);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Priority is not null)
            parameters.Add("Priority", args.Priority);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.StartupBytes is not null)
            parameters.Add("StartupBytes", args.StartupBytes);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMMemory is not null)
            parameters.Add("VMMemory", args.VMMemory);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMMemory", parameters);
    }

    public class Set_VMMigrationNetworkArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which this cmdlet operates.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the new priority of the virtual machine migration network.
        Multiple networks can have the same priority.
         */
        public UInt32? NewPriority { get; set; }

        /**
         * Specifies a string representing the new subnet value to be set on the migration network.
         */
        public string? NewSubnet { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.MigrationNetwork** is to be passed through to the pipeline representing the migration network to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies a string representing an IPv4 or IPv6 subnet mask which identifies the migration network whose properties are to be set.
        Wildcards are allowed.
         */
        public required string? Subnet { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmmigrationnetwork?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Sets the subnet, subnet mask, and/or priority of a migration network.
     * </summary>
     * <remarks>
     * The **Set-VMMigrationNetwork** cmdlet sets the subnet, subnet mask, and/or priority of a migration network.
     * </remarks>
     */
    public void Set_VMMigrationNetwork(Set_VMMigrationNetworkArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.NewPriority is not null)
            parameters.Add("NewPriority", args.NewPriority);
        if (args.NewSubnet is not null)
            parameters.Add("NewSubnet", args.NewSubnet);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Subnet is not null)
            parameters.Add("Subnet", args.Subnet);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMMigrationNetwork", parameters);
    }

    public class Set_VMNetworkAdapterArguments
    {
        /**
         * Specifies whether the virtual network adapter can be teamed with other network adapters connected to the same virtual switch.
        The value can be **On** (allowed) or **Off** (disallowed).
         */
        public OnOffState? AllowTeaming { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which features of the network adapter are to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies whether this adapter uses device naming.
         */
        public OnOffState? DeviceNaming { get; set; }

        /**
         * Specifies whether to drop DHCP messages from a virtual machine claiming to be a DHCP server.
        Allowed values are **On**, which drops DHCP messages because the virtualized DHCP server is considered untrusted) or **Off**, which allows the message to be received because the virtualized DHCP server is considered to be trustworthy.
         */
        public OnOffState? DhcpGuard { get; set; }

        /**
         * Specifies the dynamic IP address limit, an integer.
         */
        public UInt32? DynamicIPAddressLimit { get; set; }

        /**
         * Assigns a dynamically generated MAC address to the virtual network adapter..
         */
        public SwitchParameter? DynamicMacAddress { get; set; }

        /**
         * Specifies whether the adapter uses fix speed of 10G.
         */
        public OnOffState? FixSpeed10G { get; set; }

        /**
         * Specifies whether IEEE 802.1p tagged packets from the virtual machine should be trusted.
        The value should be either **On** (trusted) or **Off** (not trusted).
        If it is on, the IEEE 802.1p tagged packets will be let go as is.
        If it is off, the priority value is reset to 0.
         */
        public OnOffState? IeeePriorityTag { get; set; }

        /**
         * Specifies the interrupt moderation value for a single-root I/O virtualization (SR-IOV) virtual function assigned to a virtual network adapter.
        Allowed values are **Default**, **Adaptive**, **Off**, **Low**, **Medium**, and **High**.
        If **Default** is chosen, the value is determined by the physical network adapter vendor's setting.
        If **Adaptive** is chosen, the interrupt moderation rate will be based on the runtime traffic pattern.
         */
        public IovInterruptModerationValue? IovInterruptModeration { get; set; }

        /**
         * Specifies the number of hardware queue pairs to be allocated to an SR-IOV virtual function.
        If receive-side scaling (RSS) is required, and if the physical network adapter that binds to the virtual switch supports RSS on SR-IOV virtual functions, then more than one queue pair is required.
        Allowed values range from 1 to 4294967295.
         */
        public UInt32? IovQueuePairsRequested { get; set; }

        /**
         * Specifies whether single-root I/O virtualization (SR-IOV) is to be enabled on this virtual network adapter.
        The relative weight sets the affinity of the virtual network adapter to the assigned SR-IOV virtual function.
        The range of the value is from 0 through 100.
        Specify 0 to disable SR-IOV on the virtual network adapter.
         */
        public UInt32? IovWeight { get; set; }

        /**
         * Specifies the maximum number of security associations that can be offloaded to the physical network adapter that is bound to the virtual switch and that supports IPSec Task Offload.
        Specify zero to disable the feature.
         */
        public UInt32? IPsecOffloadMaximumSecurityAssociation { get; set; }

        /**
         * Specifies whether virtual machines may change the source MAC address in outgoing packets to one not assigned to them.
        Allowed values are **On** (allowing the virtual machine to use a different MAC address) and **Off** (allowing the virtual machine to use only the MAC address assigned to it).
         */
        public OnOffState? MacAddressSpoofing { get; set; }

        /**
         * Specifies the virtual network adapter in the management operating system to be configured.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the unique identifiers of the virtual switch extension features that are required for this virtual network adapter to operate.
         */
        public string[]? MandatoryFeatureId { get; set; }

        /**
         * Specifies the maximum bandwidth, in bits per second, for the virtual network adapter.
        The specified value is rounded to the nearest multiple of eight.
        Specify zero to disable the feature.
         */
        public Int64? MaximumBandwidth { get; set; }

        /**
         * Specifies the minimum bandwidth, in bits per second, for the virtual network adapter.
        The specified value is rounded to the nearest multiple of eight.
        A value larger than 100 Mbps is recommended.
         */
        public Int64? MinimumBandwidthAbsolute { get; set; }

        /**
         * Specifies the minimum bandwidth, in terms of relative weight, for the virtual network adapter.
        The weight describes how much bandwidth to provide to the virtual network adapter relative to other virtual network adapters connected to the same virtual switch.
        The range of the value is from 0 through 100.
        Specify 0 to disable the feature.
         */
        public UInt32? MinimumBandwidthWeight { get; set; }

        /**
         * Specifies the name for the virtual network adapter.
        The cmdlet changes the name to the value that you specify.
         */
        public string? Name { get; set; }

        /**
         * Indicates whether to not monitor the network adapter if the virtual machine that it belongs to is part of a cluster.
        By default, network adapters for clustered virtual machines are monitored.
         */
        public Boolean? NotMonitoredInCluster { get; set; }

        /**
         * Specifies the number of packets to wait for before signaling an interrupt.
         */
        public UInt32? PacketDirectModerationCount { get; set; }

        /**
         * Specifies the amount of time, in milliseconds, to wait before signaling an interrupt after a packet arrives.
         */
        public UInt32? PacketDirectModerationInterval { get; set; }

        /**
         * Specifies the number of processors to use for virtual switch processing inside of the host.
         */
        public UInt32? PacketDirectNumProcs { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual network adapter to be configured.
        This is a  **Microsoft.HyperV.PowerShell.VMInternalNetworkAdapter** object, if ManagementOS is specified; or a **Microsoft.HyperV.PowerShell.VMNetworkAdapter** object otherwise.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the port mirroring mode for the network adapter to be configured.
        Allowed values are **None**, **Source**, and **Destination**.
        If a virtual network adapter is configured as **Source**, every packet it sends or receives is copied and forwarded to a virtual network adapter configured to receive the packets.
        If a virtual network adapter is configured as **Destination**, it receives copied packets from the source virtual network adapter.
        The source and destination virtual network adapters must be connected to the same virtual switch.
        Specify **None** to disable the feature.
         */
        public VMNetworkAdapterPortMirroringMode? PortMirroring { get; set; }

        /**
         * Specifies the name of the resource pool.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Specifies whether to drop **Router Advertisement** and **Redirection** messages from unauthorized virtual machines.
        The value can be either **On** or **Off**.
        If **On** is specified, such messages are dropped.
        If **Off** is specified, such messages are sent.
         */
        public OnOffState? RouterGuard { get; set; }

        /**
         * Assigns a specific a MAC address to the virtual network adapter.
         */
        public string? StaticMacAddress { get; set; }

        /**
         * Specifies the number of broadcast, multicast, and unknown unicast packets per second a virtual machine is allowed to send through the specified virtual network adapter.
        Broadcast, multicast, and unknown unicast packets beyond the limit during that one second interval are dropped.
        A value of zero (0) means there is no limit.
         */
        public UInt32? StormLimit { get; set; }

        /**
         * This parameter applies only to virtual machines that are enabled for replication.
        It specifies the name of the network resource pool that will be used by this virtual network adapter when its virtual machine is created during a test failover.
         */
        public string? TestReplicaPoolName { get; set; }

        /**
         * This parameter applies only to virtual machines that are enabled for replication.
        It specifies the name of the virtual switch to which the virtual network adapter should be connected when its virtual machine is created during a test failover.
         */
        public string? TestReplicaSwitchName { get; set; }

        /**
         * Specifies the virtual subnet ID to use with Hyper-V Network Virtualization.
        Allowed values range from 4096 to 16777215 (2^24 - 1), in addition to 0.
        Use 0 to clear this parameter.
         */
        public UInt32? VirtualSubnetId { get; set; }

        /**
         * Specifies the virtual machine that has the virtual network you want to configure.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         *
         */
        public Boolean? VmmqEnabled { get; set; }

        /**
         *
         */
        public UInt32? VmmqQueuePairs { get; set; }

        /**
         * Specifies the name of the virtual machine that has the virtual network adapteryou want to configure.
         */
        public required string? VMName { get; set; }

        /**
         * Specifies the virtual network adapter.
         */
        public required VMNetworkAdapterBase? VMNetworkAdapter { get; set; }

        /**
         * Specifies whether virtual machine queue (VMQ) is to be enabled on the virtual network adapter.
        . The relative weight describes the affinity of the virtual network adapter to use VMQ.
        The range of value is from 0 through 100.
        Specify 0 to disable VMQ on the virtual network adapter.
         */
        public UInt32? VmqWeight { get; set; }

        /**
         *
         */
        public Boolean? VrssEnabled { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmnetworkadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures features of the virtual network adapter in a virtual machine or the management operating system.
     * </summary>
     * <remarks>
     * The **Set-VMNetworkAdapter** cmdlet configures features of the virtual network adapter in a virtual machine or the management operating system.
     * </remarks>
     */
    public void Set_VMNetworkAdapter(Set_VMNetworkAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowTeaming is not null)
            parameters.Add("AllowTeaming", args.AllowTeaming);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DeviceNaming is not null)
            parameters.Add("DeviceNaming", args.DeviceNaming);
        if (args.DhcpGuard is not null)
            parameters.Add("DhcpGuard", args.DhcpGuard);
        if (args.DynamicIPAddressLimit is not null)
            parameters.Add("DynamicIPAddressLimit", args.DynamicIPAddressLimit);
        if (args.DynamicMacAddress is not null)
            parameters.Add("DynamicMacAddress", args.DynamicMacAddress);
        if (args.FixSpeed10G is not null)
            parameters.Add("FixSpeed10G", args.FixSpeed10G);
        if (args.IeeePriorityTag is not null)
            parameters.Add("IeeePriorityTag", args.IeeePriorityTag);
        if (args.IovInterruptModeration is not null)
            parameters.Add("IovInterruptModeration", args.IovInterruptModeration);
        if (args.IovQueuePairsRequested is not null)
            parameters.Add("IovQueuePairsRequested", args.IovQueuePairsRequested);
        if (args.IovWeight is not null)
            parameters.Add("IovWeight", args.IovWeight);
        if (args.IPsecOffloadMaximumSecurityAssociation is not null)
            parameters.Add(
                "IPsecOffloadMaximumSecurityAssociation",
                args.IPsecOffloadMaximumSecurityAssociation
            );
        if (args.MacAddressSpoofing is not null)
            parameters.Add("MacAddressSpoofing", args.MacAddressSpoofing);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.MandatoryFeatureId is not null)
            parameters.Add("MandatoryFeatureId", args.MandatoryFeatureId);
        if (args.MaximumBandwidth is not null)
            parameters.Add("MaximumBandwidth", args.MaximumBandwidth);
        if (args.MinimumBandwidthAbsolute is not null)
            parameters.Add("MinimumBandwidthAbsolute", args.MinimumBandwidthAbsolute);
        if (args.MinimumBandwidthWeight is not null)
            parameters.Add("MinimumBandwidthWeight", args.MinimumBandwidthWeight);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NotMonitoredInCluster is not null)
            parameters.Add("NotMonitoredInCluster", args.NotMonitoredInCluster);
        if (args.PacketDirectModerationCount is not null)
            parameters.Add("PacketDirectModerationCount", args.PacketDirectModerationCount);
        if (args.PacketDirectModerationInterval is not null)
            parameters.Add("PacketDirectModerationInterval", args.PacketDirectModerationInterval);
        if (args.PacketDirectNumProcs is not null)
            parameters.Add("PacketDirectNumProcs", args.PacketDirectNumProcs);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.PortMirroring is not null)
            parameters.Add("PortMirroring", args.PortMirroring);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.RouterGuard is not null)
            parameters.Add("RouterGuard", args.RouterGuard);
        if (args.StaticMacAddress is not null)
            parameters.Add("StaticMacAddress", args.StaticMacAddress);
        if (args.StormLimit is not null)
            parameters.Add("StormLimit", args.StormLimit);
        if (args.TestReplicaPoolName is not null)
            parameters.Add("TestReplicaPoolName", args.TestReplicaPoolName);
        if (args.TestReplicaSwitchName is not null)
            parameters.Add("TestReplicaSwitchName", args.TestReplicaSwitchName);
        if (args.VirtualSubnetId is not null)
            parameters.Add("VirtualSubnetId", args.VirtualSubnetId);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VmmqEnabled is not null)
            parameters.Add("VmmqEnabled", args.VmmqEnabled);
        if (args.VmmqQueuePairs is not null)
            parameters.Add("VmmqQueuePairs", args.VmmqQueuePairs);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VmqWeight is not null)
            parameters.Add("VmqWeight", args.VmqWeight);
        if (args.VrssEnabled is not null)
            parameters.Add("VrssEnabled", args.VrssEnabled);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMNetworkAdapter", parameters);
    }

    public class Set_VMNetworkAdapterFailoverConfigurationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Clears the configured IPv4 failover settings.
        The IPv4 address configured in the primary virtual machine (static or dynamic) will be used by the Replica virtual machine.
         */
        public SwitchParameter? ClearFailoverIPv4Settings { get; set; }

        /**
         * Clears the configured IPv6 failover settings.
        The IPv6 address configured in the primary virtual machine (static or dynamic) will be used by the Replica virtual machine.
         */
        public SwitchParameter? ClearFailoverIPv6Settings { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the IP address configuration of a virtual network adapter is to be set.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the IPv4 address to set on the VMNetworkAdapter for use on failover of the virtual machine.
        You must also specify the **IPv4SubnetMask** parameter when you specify this parameter.
         */
        public string? IPv4Address { get; set; }

        /**
         * Specifies the IPv4 alternate DNS server to be set on the VMNetworkAdapter for use on failover of the virtual machine.
         */
        public string? IPv4AlternateDNSServer { get; set; }

        /**
         * Specifies the IPv4 default gateway to be set on VMNetworkAdapter for use on failover of the virtual machine..
         */
        public string? IPv4DefaultGateway { get; set; }

        /**
         * Specifies the IPv4 preferred DNS server to be set on VMNetworkAdapter for use on failover of the virtual machine.
         */
        public string? IPv4PreferredDNSServer { get; set; }

        /**
         * Specifies the IPv4 subnet mask to be set on VMNetworkAdapter for use on failover of the virtual machine.
        You must specify the **IPv4Address** parameter when you specify this parameter.
         */
        public string? IPv4SubnetMask { get; set; }

        /**
         * Specifies the IPv6 address to be set on VMNetworkAdapter for use on failover of the virtual machine.
        You must specify the **IPv6SubnetPrefixLength** parameter when you specify this parameter.
         */
        public string? IPv6Address { get; set; }

        /**
         * Specifies the IPv6 alternate DNS server to be set on VMNetworkAdapter for use on failover of the virtual machine.
         */
        public string? IPv6AlternateDNSServer { get; set; }

        /**
         * Specifies the IPv6 default gateway to be set on VMNetworkAdapter for use on failover of the virtual machine.
         */
        public string? IPv6DefaultGateway { get; set; }

        /**
         * Specifies the IPv6 preferred DNS server to be set on VMNetworkAdapter for use on failover of the virtual machine.
         */
        public string? IPv6PreferredDNSServer { get; set; }

        /**
         * Specifies the IPv6 subnet prefix length to be set on VMNetworkAdapter for use on failover of the virtual machine.
        You must specify the **IPv6Address** parameter when you specify this parameter.
         */
        public int? IPv6SubnetPrefixLength { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VMNetworkAdapterFailoverConfiguration** object is to be passed through to the pipeline representing the IP address configuration to be set.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine for which you want to configure the IP address.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Specifies the friendly name of the virtual machine for which you want to configure the IP address.
         */
        public required string? VMName { get; set; }

        /**
         * Specifies the virtual network adapter for which you want to configure the IP address.
         */
        public required VMNetworkAdapter? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual network adapter for which you want to set the IP address.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmnetworkadapterfailoverconfiguration?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures the IP address of a virtual network adapter to be used when a virtual machine fails over.
     * </summary>
     * <remarks>
     * The **Set-VMNetworkAdapterFailoverConfiguration** cmdlet sets the configuration of an IP address of a virtual network adapter  to be used when a virtual machine fails over.
     * </remarks>
     */
    public void Set_VMNetworkAdapterFailoverConfiguration(
        Set_VMNetworkAdapterFailoverConfigurationArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ClearFailoverIPv4Settings is not null)
            parameters.Add("ClearFailoverIPv4Settings", args.ClearFailoverIPv4Settings);
        if (args.ClearFailoverIPv6Settings is not null)
            parameters.Add("ClearFailoverIPv6Settings", args.ClearFailoverIPv6Settings);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.IPv4Address is not null)
            parameters.Add("IPv4Address", args.IPv4Address);
        if (args.IPv4AlternateDNSServer is not null)
            parameters.Add("IPv4AlternateDNSServer", args.IPv4AlternateDNSServer);
        if (args.IPv4DefaultGateway is not null)
            parameters.Add("IPv4DefaultGateway", args.IPv4DefaultGateway);
        if (args.IPv4PreferredDNSServer is not null)
            parameters.Add("IPv4PreferredDNSServer", args.IPv4PreferredDNSServer);
        if (args.IPv4SubnetMask is not null)
            parameters.Add("IPv4SubnetMask", args.IPv4SubnetMask);
        if (args.IPv6Address is not null)
            parameters.Add("IPv6Address", args.IPv6Address);
        if (args.IPv6AlternateDNSServer is not null)
            parameters.Add("IPv6AlternateDNSServer", args.IPv6AlternateDNSServer);
        if (args.IPv6DefaultGateway is not null)
            parameters.Add("IPv6DefaultGateway", args.IPv6DefaultGateway);
        if (args.IPv6PreferredDNSServer is not null)
            parameters.Add("IPv6PreferredDNSServer", args.IPv6PreferredDNSServer);
        if (args.IPv6SubnetPrefixLength is not null)
            parameters.Add("IPv6SubnetPrefixLength", args.IPv6SubnetPrefixLength);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction(
            "Set-VMNetworkAdapterFailoverConfiguration",
            parameters
        );
    }

    public class Set_VMNetworkAdapterIsolationArguments
    {
        /**
         * Indicates whether the virtual machine sends and receives untagged traffic.
         */
        public Boolean? AllowUntaggedTraffic { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet modifies isolation settings for virtual machines hosted by the computers that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the ID of the network for traffic to the default compartment on virtual machines that have multitenancy enabled.
        The value that you specify applies only to untagged traffic.
        This parameter has an effect only if you specify a value of $True for the *AllowUntaggedTraffic* parameter.
         */
        public int? DefaultIsolationID { get; set; }

        /**
         * Specifies the isolation mode for the adapter.
        The acceptable values for this parameter are:
        
         * - NativeVirtualSubnet.
        Hyper-V Network Virtualization.
        - ExternalVirtualSubnet.
        A third party network virtualization solution.
        - VLAN.
        - None.
        
         * If you specify a value of None, the network adapter uses its default isolation mode.
        Set the default isolation mode by using the **Set-VMNetworkAdapterVlan** cmdlet or the **Set-VMNetworkAdapter** cmdlet.
         */
        public VMNetworkAdapterIsolationMode? IsolationMode { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent or host operating system.
        If you specify this parameter, this cmdlet modifies isolation settings for the parent or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies whether to use multiple isolation IDs for the virtual machine.
        The acceptable values for this parameter are:
        
         * - On.
        Indicate isolation IDs so that the virtual machine provides services to multiple tenants on different isolation subnets.
        - Off.
        Do not indicate isolation IDs to virtual machine.
         */
        public OnOffState? MultiTenantStack { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        The cmdlet modifies isolation settings for adapters that belong to the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines.
        The cmdlet modifies isolation settings for adapters that belong to the virtual machines that you specify.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies an array VM network adapters as **VMNetworkAdapterBase** objects.
        The cmdlet modifies isolation settings for the adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
        The cmdlet modifies isolation settings for the adapters that you specify.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmnetworkadapterisolation?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMNetworkAdapterIsolation.md">Get-VMNetworkAdapterIsolation</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     *
     * <see href="./Get-VMNetworkAdapter.md">Get-VMNetworkAdapter</see>
     *
     * <see href="./Set-VMNetworkAdapter.md">Set-VMNetworkAdapter</see>
     *
     * <see href="./Set-VMNetworkAdapterVlan.md">Set-VMNetworkAdapterVlan</see>
     * Modifies isolation settings for a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Set-VMNetworkAdapterIsolation** cmdlet modifies isolation settings for a virtual network adapter. You can isolate a virtual machine adapter by using virtual local area network (VLAN), Hyper-V Network Virtualization or a third party virtualization solution. You can specify the isolation method and modify other settings, which include multitenancy settings. For more information about multitenancy, see the **Add-VMNetworkAdapterRoutingDomainMapping** cmdlet.
     * </remarks>
     */
    public VMNetworkAdapterIsolationSetting[] Set_VMNetworkAdapterIsolation(
        Set_VMNetworkAdapterIsolationArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowUntaggedTraffic is not null)
            parameters.Add("AllowUntaggedTraffic", args.AllowUntaggedTraffic);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DefaultIsolationID is not null)
            parameters.Add("DefaultIsolationID", args.DefaultIsolationID);
        if (args.IsolationMode is not null)
            parameters.Add("IsolationMode", args.IsolationMode);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.MultiTenantStack is not null)
            parameters.Add("MultiTenantStack", args.MultiTenantStack);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterIsolationSetting>(
            "Set-VMNetworkAdapterIsolation",
            parameters
        );
        return result;
    }

    public class Set_VMNetworkAdapterRdmaArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public object? Confirm { get; set; }
        public PSCredential[]? Credential { get; set; }
        public required object? ManagementOS { get; set; }
        public string? Name { get; set; }
        public object? Passthru { get; set; }
        public uint? RdmaWeight { get; set; }
        public required VirtualMachine? VM { get; set; }
        public required string? VMName { get; set; }
        public required VMNetworkAdapterBase? VMNetworkAdapter { get; set; }
        public object? WhatIf { get; set; }
    }

    /** <summary>
     *
     * Set-VMNetworkAdapterRdma [-VMName] <string> [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-Name <string>] [-RdmaWeight <uint>] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * Set-VMNetworkAdapterRdma -ManagementOS [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-Name <string>] [-RdmaWeight <uint>] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * Set-VMNetworkAdapterRdma [-VMNetworkAdapter] <VMNetworkAdapterBase> [-RdmaWeight <uint>] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * Set-VMNetworkAdapterRdma [-VM] <VirtualMachine> [-Name <string>] [-RdmaWeight <uint>] [-Passthru] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VMNetworkAdapterRdmaSetting[] Set_VMNetworkAdapterRdma(
        Set_VMNetworkAdapterRdmaArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RdmaWeight is not null)
            parameters.Add("RdmaWeight", args.RdmaWeight);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterRdmaSetting>(
            "Set-VMNetworkAdapterRdma",
            parameters
        );
        return result;
    }

    public class Set_VMNetworkAdapterRoutingDomainMappingArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies an array of Hyper-V hosts.
        The cmdlet adds the virtual subnets to the routing domain on the Hyper-V hosts that you specify.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the input to this cmdlet.
        You can use this parameter, or you can pipe the input to this cmdlet.
         */
        public required VMNetworkAdapterRoutingDomainSetting? InputObject { get; set; }

        /**
         * Specifies an array of IDs of virtual subnets.
        The cmdlet adds the virtual subnets that you specify to the routing domain.
        The subnets use VLAN or Hyper-V Network Virtualization.
        For more information about isolation IDs, see the **Set-VMNetworkAdapterIsolation** cmdlet.
         */
        public Int32[]? IsolationID { get; set; }

        /**
         * Specifies an array of names of virtual subnets.
        The cmdlet adds the virtual subnets that you specify to the routing domain.
        The subnets use VLAN or Hyper-V Network Virtualization.
         */
        public string[]? IsolationName { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent partition or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies a new name for the routing domain.
         */
        public string? NewRoutingDomainName { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the ID of a routing domain.
        The ID of a routing domain is a system-assigned GUID.
        The cmdlet adds the virtual subnets to the routing domain that you specify.
         */
        public Guid? RoutingDomainID { get; set; }

        /**
         * Specifies the name of a routing domain.
        The cmdlet adds the virtual subnets to the routing domain that you specify.
         */
        public string? RoutingDomainName { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        The cmdlet adds the virtual subnets to the routing domain from the network interfaces that belong to the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines.
        The cmdlet adds the virtual subnets to the routing domain from the network interfaces that belong to the virtual machines that you specify.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies an array of virtual network adapters as a **VMNetworkAdapterBase** object.
        The cmdlet adds the virtual subnets to the routing domain on the adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
        The cmdlet adds the virtual subnets to the routing domain on the adapter that you specify.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmnetworkadapterroutingdomainmapping?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMNetworkAdapterRoutingDomainMapping.md">Get-VMNetworkAdapterRoutingDomainMapping</see>
     *
     * <see href="./Add-VMNetworkAdapterRoutingDomainMapping.md">Add-VMNetworkAdapterRoutingDomainMapping</see>
     *
     * <see href="./Remove-VMNetworkAdapterRoutingDomainMapping.md">Remove-VMNetworkAdapterRoutingDomainMapping</see>
     * Sets virtual subnets on a routing domain.
     * </summary>
     * <remarks>
     * The **Set-VMNetworkAdapterRoutingDomainMapping** cmdlet sets virtual subnets on a routing domain.
     * </remarks>
     */
    public VMNetworkAdapterRoutingDomainSetting[] Set_VMNetworkAdapterRoutingDomainMapping(
        Set_VMNetworkAdapterRoutingDomainMappingArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.InputObject is not null)
            parameters.Add("InputObject", args.InputObject);
        if (args.IsolationID is not null)
            parameters.Add("IsolationID", args.IsolationID);
        if (args.IsolationName is not null)
            parameters.Add("IsolationName", args.IsolationName);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.NewRoutingDomainName is not null)
            parameters.Add("NewRoutingDomainName", args.NewRoutingDomainName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RoutingDomainID is not null)
            parameters.Add("RoutingDomainID", args.RoutingDomainID);
        if (args.RoutingDomainName is not null)
            parameters.Add("RoutingDomainName", args.RoutingDomainName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterRoutingDomainSetting>(
            "Set-VMNetworkAdapterRoutingDomainMapping",
            parameters
        );
        return result;
    }

    public class Set_VMNetworkAdapterTeamMappingArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that the cmdlet operates on the parent or host operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the physical net adapter.
         */
        public required string? PhysicalNetAdapterName { get; set; }

        /**
         * Specifies the name of a switch.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies a virtual machine.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Specifies the name of a virtual machine.
         */
        public required string? VMName { get; set; }

        /**
         * Specifies a virtual machine network adapter.
         */
        public required VMNetworkAdapterBase? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of a virtual network adapter.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmnetworkadapterteammapping?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMNetworkAdapterTeamMapping.md">Get-VMNetworkAdapterTeamMapping</see>
     *
     * <see href="./Remove-VMNetworkAdapterTeamMapping.md">Remove-VMNetworkAdapterTeamMapping</see>
     *
     * </summary>
     * <remarks>
     * The **Set-VMNetworkAdapterTeamMapping** cmdlet
     * </remarks>
     */
    public VMNetworkAdapterTeamMappingSetting[] Set_VMNetworkAdapterTeamMapping(
        Set_VMNetworkAdapterTeamMappingArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.PhysicalNetAdapterName is not null)
            parameters.Add("PhysicalNetAdapterName", args.PhysicalNetAdapterName);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterTeamMappingSetting>(
            "Set-VMNetworkAdapterTeamMapping",
            parameters
        );
        return result;
    }

    public class Set_VMNetworkAdapterVlanArguments
    {
        /**
         * Specifies **Access** mode for the virtual machine network adapter. This parameter configures an untagged virtual port with the VLANId (port based VLAN), so it must be specified together with **VlanId**.
         */
        public SwitchParameter? Access { get; set; }

        /**
         * Specifies a list of virtual LANs allowed on a virtual machine network adapter.
        This parameter must be specified in conjunction with the switch parameter **Trunk**.
         */
        public string? AllowedVlanIdList { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies **Community** mode for the virtual machine network adapter to be configured.
        This parameter must be specified in conjunction with parameters **PrimaryVlanId** and **SecondaryVlanId**.
         */
        public SwitchParameter? Community { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual LAN settings on a virtual machine network adapter are to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies **Isolated** mode for the virtual machine network adapter to be configured.
        This parameter must be specified in conjunction with parameters **PrimaryVlanId** and **SecondaryVlanId**.
         */
        public SwitchParameter? Isolated { get; set; }

        /**
         * Specifies the management (e.g.
        parent or host) operating system.
         */
        public required SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies the native virtual LAN identifier for a virtual machine network adapter.
        This parameter must be specified in conjunction with the switch parameter **Trunk**.
         */
        public int? NativeVlanId { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VMNetworkAdapterVlanSetting** object is to be passed through to the pipeline representing the virtual machine network adapter virtual LAN settings to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the primary virtual LAN identifier for a virtual network adapter in **Community**, **Isolated**, or **Promiscuous** mode.
        
         * This parameter must be specified in conjunction with parameter **SecondaryVlanId** if the virtual machine network adapter is in **Community** or **Isolated** mode.
        It must be used in conjunction with parameter **SecondaryVlanIdList** if the virtual machine network adapter is in **Promiscuous** mode.
         */
        public int? PrimaryVlanId { get; set; }

        /**
         * Specifies **Promiscuous** mode for the virtual machine network adapter.
        
         * This parameter must be specified in conjunction with parameters **PrimaryVlanId** and **SecondaryVlanIdList**.
         */
        public SwitchParameter? Promiscuous { get; set; }

        /**
         * Specifies the secondary virtual LAN identifier for a virtual network adapter in **Community** or **Isolated** mode.
        
         * This parameter must be specified in conjunction with parameter **PrimaryVlanId**, along with switch parameter **Community** or **Isolated**.
         */
        public int? SecondaryVlanId { get; set; }

        /**
         * Specifies a list of private virtual LAN secondary virtual LANs on a virtual machine network adapter.This parameter must be specified in conjunction with parameter **PrimaryVlanId** and switch parameter **Promiscuous**.
         */
        public string? SecondaryVlanIdList { get; set; }

        /**
         * Specifies **Trunk** mode for the virtual machine network adapter. This parameter configures a tagged virtual port that passes all allowed VLANId tags to the VM adapter. Traffic with the NativeVLANId is passed untagged to the VM adapter.
        This parameter must be used in conjunction with parameters **AllowedVlanIdList** and **NativeVlanId**.
         */
        public SwitchParameter? Trunk { get; set; }

        /**
         * Specifies **Untagged** mode for the virtual machine network adapter.
         */
        public SwitchParameter? Untagged { get; set; }

        /**
         * Specifies the virtual LAN identifier of a virtual machine network adapter.
        This parameter must be specified in conjunction with switch parameter **Access**.
         */
        public int? VlanId { get; set; }

        /**
         * Specifies the virtual machine.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine network adapter.
         */
        public required VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual machine network adapter.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmnetworkadaptervlan?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="/windows-server/virtualization/hyper-v-virtual-switch/configure-and-view-vlan-settings-on-hyper-v-virtual-switch-ports">Configure and View VLAN Settings on Hyper-V Virtual Switch Ports</see>
     * Configures the virtual LAN settings for the traffic through a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Set-VMNetworkAdapterVlan** cmdlet configures virtual LAN settings for the traffic through a virtual network adapter. Access, Trunk, Private VLAN (isolated, community, or promiscuous), and untagged are mutually exclusive.
     * </remarks>
     */
    public void Set_VMNetworkAdapterVlan(Set_VMNetworkAdapterVlanArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.Access is not null)
            parameters.Add("Access", args.Access);
        if (args.AllowedVlanIdList is not null)
            parameters.Add("AllowedVlanIdList", args.AllowedVlanIdList);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.Community is not null)
            parameters.Add("Community", args.Community);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Isolated is not null)
            parameters.Add("Isolated", args.Isolated);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.NativeVlanId is not null)
            parameters.Add("NativeVlanId", args.NativeVlanId);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.PrimaryVlanId is not null)
            parameters.Add("PrimaryVlanId", args.PrimaryVlanId);
        if (args.Promiscuous is not null)
            parameters.Add("Promiscuous", args.Promiscuous);
        if (args.SecondaryVlanId is not null)
            parameters.Add("SecondaryVlanId", args.SecondaryVlanId);
        if (args.SecondaryVlanIdList is not null)
            parameters.Add("SecondaryVlanIdList", args.SecondaryVlanIdList);
        if (args.Trunk is not null)
            parameters.Add("Trunk", args.Trunk);
        if (args.Untagged is not null)
            parameters.Add("Untagged", args.Untagged);
        if (args.VlanId is not null)
            parameters.Add("VlanId", args.VlanId);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMNetworkAdapterVlan", parameters);
    }

    public class Set_VMPartitionableGpuArguments
    {
        public required CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public PSCredential[]? Credential { get; set; }
        public string? Name { get; set; }
        public ushort? PartitionCount { get; set; }
        public required VMPartitionableGpu[]? PartitionableGpu { get; set; }
        public object? Passthru { get; set; }
    }

    /** <summary>
     *
     * Set-VMPartitionableGpu [[-ComputerName] <string[]>] [[-Credential] <pscredential[]>] [-Passthru] [-PartitionCount <ushort>] [<CommonParameters>]
     *
     * Set-VMPartitionableGpu [-CimSession] <CimSession[]> [-Passthru] [-PartitionCount <ushort>] [<CommonParameters>]
     *
     * Set-VMPartitionableGpu [-PartitionableGpu] <VMPartitionableGpu[]> [-Passthru] [-PartitionCount <ushort>] [<CommonParameters>]
     *
     * Set-VMPartitionableGpu [-Passthru] [-Name <string>] [-PartitionCount <ushort>] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VMPartitionableGpu[] Set_VMPartitionableGpu(Set_VMPartitionableGpuArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.PartitionCount is not null)
            parameters.Add("PartitionCount", args.PartitionCount);
        if (args.PartitionableGpu is not null)
            parameters.Add("PartitionableGpu", args.PartitionableGpu);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMPartitionableGpu>(
            "Set-VMPartitionableGpu",
            parameters
        );
        return result;
    }

    public class Set_VMProcessorArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies whether the virtual processor's features are to be limited for compatibility when migrating the virtual machine to another host.
         */
        public Boolean? CompatibilityForMigrationEnabled { get; set; }

        /**
         * Specifies whether the virtual processor's features are to be limited for compatibility with older operating systems.
         */
        public Boolean? CompatibilityForOlderOperatingSystemsEnabled { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which processors are to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies the number of virtual processors for the virtual machine.
         */
        public Int64? Count { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies whether to enable host resource protection on the virtual machine. When enabled, the host will enforce limits on some aspects of the virtual machine's activity, preventing excessive consumption of host compute resources. VM activities controlled by this setting include the VMbus pipe messages associated with a subset of the VM's virtual devices, and intercepts generated by the VM. The virtual devices affected include the video, keyboard, mouse, and dynamic memory VDEVs.
         */
        public Boolean? EnableHostResourceProtection { get; set; }

        /**
         * Specifies whether the hypervisor should expose the presence of virtualization extensions to the virtual machine, which enables support for nested virtualization.
         */
        public Boolean? ExposeVirtualizationExtensions { get; set; }

        /**
         * Specifies the number of virtual SMT threads exposed to the virtual machine. Setting this value to 0 indicates the virtual machine will inherit the host's number of threads per core. This setting may not exceed the host's number of threads per core.
        
         * Note: Windows Server 2016 does not support setting HwThreadCountPerCore to 0. For more details, see [Configuring VM SMT settings using PowerShell](/windows-server/virtualization/hyper-v/manage/about-hyper-v-scheduler-type-selection#configuring-vm-smt-settings-using-powershell).
         */
        public Int64? HwThreadCountPerCore { get; set; }

        /**
         * Specifies the maximum percentage of resources available to the virtual machine processor to be configured.
        Allowed values range from 0 to 100.
         */
        public Int64? Maximum { get; set; }

        /**
         * Specifies the maximum number of processors per NUMA node to be configured for the virtual machine.
         */
        public int? MaximumCountPerNumaNode { get; set; }

        /**
         * Specifies the maximum number of sockets per NUMA node to be configured for the virtual machine.
         */
        public int? MaximumCountPerNumaSocket { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.Processor** is to be passed through to the pipeline representing the processor to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the hardware to be Exposed for Performance Monitoring. For more information about requirements, visit [Enable Intel Performance Monitoring Hardware in a Hyper-V virtual machine](/windows-server/virtualization/hyper-v/manage/performance-monitoring-hardware).
         */
        public string? Perfmon { get; set; }

        /**
         * Specifies the priority for allocating the physical computer's processing power to this virtual machine relative to others.
        Allowed values range from 1 to 10000.
         */
        public int? RelativeWeight { get; set; }

        /**
         * Specifies the percentage of processor resources to be reserved for this virtual machine.
        Allowed values range from 0 to 100.
         */
        public Int64? Reserve { get; set; }

        /**
         * Specifies the name of the processor resource pool to be used.
         */
        public string? ResourcePoolName { get; set; }

        /**
         * Specifies the virtual machine on which the processor is to be configured.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine on which the processor is to be configured.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies that the virtual machine's settings for virtual processors are to be configured.
         */
        public required VMProcessor[]? VMProcessor { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmprocessor?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures settings for the virtual processors of a virtual machine. Settings are applied uniformly to all virtual processors belonging to the virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMProcessor** cmdlet configures the virtual processors of a virtual machine.
     * </remarks>
     */
    public void Set_VMProcessor(Set_VMProcessorArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.CompatibilityForMigrationEnabled is not null)
            parameters.Add(
                "CompatibilityForMigrationEnabled",
                args.CompatibilityForMigrationEnabled
            );
        if (args.CompatibilityForOlderOperatingSystemsEnabled is not null)
            parameters.Add(
                "CompatibilityForOlderOperatingSystemsEnabled",
                args.CompatibilityForOlderOperatingSystemsEnabled
            );
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Count is not null)
            parameters.Add("Count", args.Count);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.EnableHostResourceProtection is not null)
            parameters.Add("EnableHostResourceProtection", args.EnableHostResourceProtection);
        if (args.ExposeVirtualizationExtensions is not null)
            parameters.Add("ExposeVirtualizationExtensions", args.ExposeVirtualizationExtensions);
        if (args.HwThreadCountPerCore is not null)
            parameters.Add("HwThreadCountPerCore", args.HwThreadCountPerCore);
        if (args.Maximum is not null)
            parameters.Add("Maximum", args.Maximum);
        if (args.MaximumCountPerNumaNode is not null)
            parameters.Add("MaximumCountPerNumaNode", args.MaximumCountPerNumaNode);
        if (args.MaximumCountPerNumaSocket is not null)
            parameters.Add("MaximumCountPerNumaSocket", args.MaximumCountPerNumaSocket);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Perfmon is not null)
            parameters.Add("Perfmon", args.Perfmon);
        if (args.RelativeWeight is not null)
            parameters.Add("RelativeWeight", args.RelativeWeight);
        if (args.Reserve is not null)
            parameters.Add("Reserve", args.Reserve);
        if (args.ResourcePoolName is not null)
            parameters.Add("ResourcePoolName", args.ResourcePoolName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMProcessor is not null)
            parameters.Add("VMProcessor", args.VMProcessor);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMProcessor", parameters);
    }

    public class Set_VMRemoteFx3dVideoAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the RemoteFX 3D video adapter is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the maximum resolution supported by this adapter.
         */
        public string? MaximumResolution { get; set; }

        /**
         * Specifies the maximum number of monitors supported by this adapter.
         */
        public Byte? MonitorCount { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.RemoteFxVideoAdapter** object is to be passed through to the pipeline representing the adapter to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine on which the adapter is to be configured.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine on which the adapter is to be configured.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the adapter to be configured.
         */
        public required VMRemoteFx3DVideoAdapter[]? VMRemoteFx3dVideoAdapter { get; set; }

        /**
         * Specifies the size, in bytes, of VRAM supported that this adapter supports.
         */
        public UInt64? VRAMSizeBytes { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmremotefx3dvideoadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures the RemoteFX 3D video adapter of a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMRemoteFx3dVideoAdapter** cmdlet configures the RemoteFX 3D video adapter of a virtual machine.
     * </remarks>
     */
    public void Set_VMRemoteFx3dVideoAdapter(Set_VMRemoteFx3dVideoAdapterArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.MaximumResolution is not null)
            parameters.Add("MaximumResolution", args.MaximumResolution);
        if (args.MonitorCount is not null)
            parameters.Add("MonitorCount", args.MonitorCount);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMRemoteFx3dVideoAdapter is not null)
            parameters.Add("VMRemoteFx3dVideoAdapter", args.VMRemoteFx3dVideoAdapter);
        if (args.VRAMSizeBytes is not null)
            parameters.Add("VRAMSizeBytes", args.VRAMSizeBytes);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMRemoteFx3dVideoAdapter", parameters);
    }

    public class Set_VMReplicationArguments
    {
        /**
         * When you use the AsReplica parameter to specify a virtual machine as a Replica virtual machine, this parameter determines which primary servers can send replication to the Replica virtual machine.
        Replication is accepted only from the server specified in the chosen authentication entry, or any other authentication entry that has the same trust group.
         */
        public string? AllowedPrimaryServer { get; set; }

        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Specifies that the virtual machine is a replica virtual machine, enabling it to be used as the source for the initial replication of the primary virtual machine.
         */
        public SwitchParameter? AsReplica { get; set; }

        /**
         * Specifies the authentication type to use for virtual machine replication, either Kerberos or Certificate.
        The specified Replica server must support the chosen authentication type.
        Run the **Get-VMReplicationServer** cmdlet to verify the authentication configured for the specified Replica server, or contact the administrator of the specified Replica server.
         */
        public ReplicationAuthenticationType? AuthenticationType { get; set; }

        /**
         * Enables replicating virtual machines that require resynchronization to be resynchronized automatically.
        (For example, a virtual machine requires resynchronization if the primary server shuts down abruptly).
        Resynchronization requires significant storage and processing resources.
        We recommended scheduling resynchronization during off-peak hours to reduce the impact to the host and other virtual machines running on the host.
        Use the AutoResynchronizeIntervalStart and AutoResynchronizeIntervalEnd parameters to specify an off-peak time to start the automatic resynchronization.
         */
        public Boolean? AutoResynchronizeEnabled { get; set; }

        /**
         * Specifies the end of the time period in which you want resynchronization to start automatically.
         */
        public TimeSpan? AutoResynchronizeIntervalEnd { get; set; }

        /**
         * Specifies the start of the time period in which you want resynchronization to start automatically.
         */
        public TimeSpan? AutoResynchronizeIntervalStart { get; set; }

        /**
         * Specifies whether to bypass a proxy server while replicating data to the Replica server.
         */
        public Boolean? BypassProxyServer { get; set; }

        /**
         * Specifies the certificate to use for mutual authentication of the replication data.
        This parameter is required only when "Certificate" is specified as the type of authentication.
        Specify the thumbprint of a valid computer certificate from the Personal store.
        
         * The certificate must have all of the following properties to be valid:
        
         * - It must not be expired.
        - It must include both client and server authentication extensions for extended key usage (EKU), and an associated private key.
        - It must terminate at a valid root certificate.
        - The requirement for the subject common name (CN) differs depending on whether the virtual machine belongs to a cluster. For virtual machines that do not belong to a cluster, the subject common name (CN) must be equal to, or subject alternative name (DNS Name) should contain, the FQDN of the host. For virtual machines that belong to a cluster, the subject common name (CN) must be equal to, or subject alternative name (DNS Name) must contain, the and fully-qualified domain name (FQDN) of the Hyper-V Replica Broker.
        
         * To display a list of certificates in the computer's My store and the thumbprint of each certificate, type the following:
        
         * `PS C:\\\> cd cert:\LocalMachine\My`
        
         * `PS C:\\\> dir | format-list`
        
         * For more information about certificate stores, see [http://technet.microsoft.com//library/cc757138.aspx](https://technet.microsoft.com//library/cc757138.aspx).
         */
        public string? CertificateThumbprint { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies whether replication data sent over the network is to be compressed.
         */
        public Boolean? CompressionEnabled { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which replication is to be enabled.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies whether to replicate volume shadow copy service (VSS) snapshots.
         */
        public SwitchParameter? DisableVSSSnapshotReplication { get; set; }

        /**
         * Determines whether all virtual hard disks selected for replication are replicated to the same point in time.
        This is useful if the virtual machine runs an application that saves data across virtual hard disks (for example, one virtual hard disk dedicated for application data, and another virtual hard disk dedicated for application log files).
         */
        public Boolean? EnableWriteOrderPreservationAcrossDisks { get; set; }

        /**
         * Specifies the time to start the initial replication, when scheduling initial replication to occur later.
        You can specify a time up to 7 days later.
        When this parameter is not specified, initial replication occurs immediately.
         */
        public DateTime? InitialReplicationStartTime { get; set; }

        /**
         * Specifies that a **VMReplication** object is to be passed through to the pipeline representing the replication configuration to be set.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies whether to store additional recovery points on the Replica virtual machine.
        Storing more than the most recent recovery point of the primary virtual machine allows you to recover to an earlier point in time.
        However, storing additional recovery points requires more storage and processing resources.
        You can configure as many as 24 recovery points to be stored.
         */
        public int? RecoveryHistory { get; set; }

        /**
         * Specifies the name of the Replica server to which this virtual machine will be replicated.
         */
        public string? ReplicaServerName { get; set; }

        /**
         * Specifies the port on the Replica server to use for replication traffic.
        Make sure you specify a port that is configured on the Replica server to support the same authentication type you specify using the AuthenticationType parameter in this cmdlet.
        Run the **Get-VMReplicationServer** cmdlet on the Replica server to check the configuration of the port, or contact the administrator of the specified Replica server.
         */
        public int? ReplicaServerPort { get; set; }

        /**
         * Specifies the fully qualified path names of all the virtual hard disks to include for replication.
        Be sure to include virtual hard disks that are critical to the ability of the virtual machine to start, such as the guest operating system disk.
        Excluding a critical disk from this list could prevent the replica virtual machine from starting properly.
         */
        public string[]? ReplicatedDiskPaths { get; set; }

        /**
         * Specifies all virtual hard disks to include for replication.
        This parameter can include all the VHDs attached to the virtual machine or a subset.
        Be sure to include virtual hard disks that are critical to the ability of the virtual machine to start, such as the guest operating system disk.
        Excluding a critical disk from this list could prevent the replica virtual machine from starting properly.
         */
        public HardDiskDrive[]? ReplicatedDisks { get; set; }

        /**
         * Specifies whether to replicate host-only key value pairs (KVP) for this virtual machine.
         */
        public Boolean? ReplicateHostKvpItems { get; set; }

        /**
         * Specifies the frequency, in seconds, at which Hyper-V replicates changes to the Replica server.
         */
        public int? ReplicationFrequencySec { get; set; }

        /**
         * Reverses the replication of the virtual machine, switching it from a primary virtual machine to a Replica virtual machine, or from a Replica virtual machine to a primary virtual machine.
         */
        public SwitchParameter? Reverse { get; set; }

        /**
         * Specifies that a restored copy of the virtual machine on the Replica server is to be used as the source of the initial replication.
         */
        public SwitchParameter? UseBackup { get; set; }

        /**
         * Specifies the virtual machine for which the replication configuration is to be set.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine for which the replication configuration is to be set.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies a virtual machine replication object for which the configuration is to be set.
         */
        public required VMReplication[]? VMReplication { get; set; }

        /**
         * Specifies the frequency, in hours, at which Volume Shadow Copy Service (VSS) performs a snapshot backup of the virtual machines.
        Specify this parameter only if application-consistent replication is enabled for the virtual is and the value you set for the **RecoveryHistory** parameter is not zero.
        The cmdlet sets a value of zero for this parameter if application-consistent replication is disabled.
        Do not specify this parameter if you are extending replication from the Replica virtual machine.
         */
        public int? VSSSnapshotFrequencyHour { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Modifies the replication settings of a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMReplication** cmdlet modifies the replication settings of a virtual machine.
     * </remarks>
     */
    public void Set_VMReplication(Set_VMReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowedPrimaryServer is not null)
            parameters.Add("AllowedPrimaryServer", args.AllowedPrimaryServer);
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.AsReplica is not null)
            parameters.Add("AsReplica", args.AsReplica);
        if (args.AuthenticationType is not null)
            parameters.Add("AuthenticationType", args.AuthenticationType);
        if (args.AutoResynchronizeEnabled is not null)
            parameters.Add("AutoResynchronizeEnabled", args.AutoResynchronizeEnabled);
        if (args.AutoResynchronizeIntervalEnd is not null)
            parameters.Add("AutoResynchronizeIntervalEnd", args.AutoResynchronizeIntervalEnd);
        if (args.AutoResynchronizeIntervalStart is not null)
            parameters.Add("AutoResynchronizeIntervalStart", args.AutoResynchronizeIntervalStart);
        if (args.BypassProxyServer is not null)
            parameters.Add("BypassProxyServer", args.BypassProxyServer);
        if (args.CertificateThumbprint is not null)
            parameters.Add("CertificateThumbprint", args.CertificateThumbprint);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.CompressionEnabled is not null)
            parameters.Add("CompressionEnabled", args.CompressionEnabled);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DisableVSSSnapshotReplication is not null)
            parameters.Add("DisableVSSSnapshotReplication", args.DisableVSSSnapshotReplication);
        if (args.EnableWriteOrderPreservationAcrossDisks is not null)
            parameters.Add(
                "EnableWriteOrderPreservationAcrossDisks",
                args.EnableWriteOrderPreservationAcrossDisks
            );
        if (args.InitialReplicationStartTime is not null)
            parameters.Add("InitialReplicationStartTime", args.InitialReplicationStartTime);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.RecoveryHistory is not null)
            parameters.Add("RecoveryHistory", args.RecoveryHistory);
        if (args.ReplicaServerName is not null)
            parameters.Add("ReplicaServerName", args.ReplicaServerName);
        if (args.ReplicaServerPort is not null)
            parameters.Add("ReplicaServerPort", args.ReplicaServerPort);
        if (args.ReplicatedDiskPaths is not null)
            parameters.Add("ReplicatedDiskPaths", args.ReplicatedDiskPaths);
        if (args.ReplicatedDisks is not null)
            parameters.Add("ReplicatedDisks", args.ReplicatedDisks);
        if (args.ReplicateHostKvpItems is not null)
            parameters.Add("ReplicateHostKvpItems", args.ReplicateHostKvpItems);
        if (args.ReplicationFrequencySec is not null)
            parameters.Add("ReplicationFrequencySec", args.ReplicationFrequencySec);
        if (args.Reverse is not null)
            parameters.Add("Reverse", args.Reverse);
        if (args.UseBackup is not null)
            parameters.Add("UseBackup", args.UseBackup);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMReplication is not null)
            parameters.Add("VMReplication", args.VMReplication);
        if (args.VSSSnapshotFrequencyHour is not null)
            parameters.Add("VSSSnapshotFrequencyHour", args.VSSSnapshotFrequencyHour);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMReplication", parameters);
    }

    public class Set_VMReplicationAuthorizationEntryArguments
    {
        /**
         * Specifies the allowed primary server of the authorization entry to be modified.
         */
        public required string? AllowedPrimaryServer { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the authorization entry is to be set.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the replication authorization entry to be set.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the location to store the Replica virtual hard disk files from the allowed server when a new Replica virtual machine is created.
        Modifying this location does not affect any existing virtual hard disk files on the Replica server.
         */
        public string? ReplicaStorageLocation { get; set; }

        /**
         * Identifies a group of primary servers within which a given primary virtual machine can move so replications of the primary virtual machine are accepted by the Replica server only from primary servers that belong to the trust group.
        You can use any string to create a new trust group.
        Ensure all primary servers within a specific trust group use the same string as the value you specify for this parameter.
        
         * Use of a trust group can help you keep virtual machines isolated by maintaining control over which primary servers are trusted to provide replication, while also allowing the virtual machines to move from one primary server to another (such as through live migration or failover from a cluster node).
         */
        public string? TrustGroup { get; set; }

        /**
         * Specifies the authorization entry to be set.
         */
        public required VMReplicationAuthorizationEntry[]? VMReplicationAuthorizationEntry { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmreplicationauthorizationentry?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Modifies an authorization entry on a Replica server.
     * </summary>
     * <remarks>
     * The **Set-VMReplicationAuthorizationEntry** cmdlet modifies an authorization entry on Replica server.
     * </remarks>
     */
    public void Set_VMReplicationAuthorizationEntry(
        Set_VMReplicationAuthorizationEntryArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowedPrimaryServer is not null)
            parameters.Add("AllowedPrimaryServer", args.AllowedPrimaryServer);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ReplicaStorageLocation is not null)
            parameters.Add("ReplicaStorageLocation", args.ReplicaStorageLocation);
        if (args.TrustGroup is not null)
            parameters.Add("TrustGroup", args.TrustGroup);
        if (args.VMReplicationAuthorizationEntry is not null)
            parameters.Add("VMReplicationAuthorizationEntry", args.VMReplicationAuthorizationEntry);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMReplicationAuthorizationEntry", parameters);
    }

    public class Set_VMReplicationServerArguments
    {
        /**
         * Specifies which authentication types the Replica server will use.
        Allowed values are Kerberos, Certificate, or CertificateAndKerberos.
         */
        public RecoveryAuthenticationType? AllowedAuthenticationType { get; set; }

        /**
         * Specifies the port on which the Replica server will receive replication data using certificate-based authentication.
        This parameter can be set only when the value of the AllowedAuthType parameter is Certificate or CertificateAndKerberos.
         */
        public int? CertificateAuthenticationPort { get; set; }

        /**
         * When using Hyper-V Replica with failover clustering and certificate-based authorization, you can use this parameter to specify a different port for each node of the cluster to receive replication.
        We recommend that you specify a unique port for each node of the cluster, and one unique port for the Hyper-V Replica Broker.
        This parameter can be set only when the Replica server is configured with an authentication type of Certificate or CertificateAndKerberos.
         */
        public Hashtable? CertificateAuthenticationPortMapping { get; set; }

        /**
         * Specifies the certificate to use for mutual authentication of the replication data.
        This parameter is required only when Certificate is specified as the type of authentication.
        Specify the thumbprint of a valid computer certificate from the Personal store.
        
         * The certificate must have all of the following properties to be valid:
        
         * - It must not be expired.
        - It must include both client and server authentication extensions for extended key usage (EKU), and an associated private key.
        - It must terminate at a valid root certificate.
        - It must meet the requirements for the subject common name (CN):
          - For servers that are not clustered, the subject common name (CN) must be equal to, or subject alternative name (DNS Name) should contain, the FQDN of the host.
          - For servers that are clustered, each node must have two certificates - one in which the subject common name (CN) or subject alternative name (DNS Name) is the name of the node, and the other in which subject common name (CN) or subject alternative name (DNS Name) is FQDN of the Hyper-V Replica Broker.
        
         * To display a list of certificates in the computer's My store and the thumbprint of each certificate, run the following commands:
        
         * `PS C:\\\> cd cert:\LocalMachine\My`
        
         * `PS C:\\\> dir | format-list`
        
         * For more information about certificate stores, see [Certificate stores](/previous-versions/windows/it-pro/windows-server-2003/cc757138(v=ws.10)).
         */
        public string? CertificateThumbprint { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](/powershell/module/cimcmdlets/new-cimsession) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Configures Replica server settings for one or more Hyper-V hosts.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the default location to store the virtual hard disk files when a Replica virtual machine is created.
        You must specify this parameter when ReplicationAllowedFromAnyServer is True.
         */
        public string? DefaultStorageLocation { get; set; }

        /**
         * Specifies whether the command runs without requiring confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies the port that the HTTP listener uses on the Replica server host.
         */
        public int? KerberosAuthenticationPort { get; set; }

        /**
         * When using Hyper-V Replica with failover clustering and Kerberos authorization, you can use this parameter to specify a different port for each node of the cluster to receive replication.
        We recommend that you specify a unique port for each node of the cluster, and one unique port for the Hyper-V Replica Broker.
        This parameter can be set only when the Replica server is configured with an authentication type of either Kerberos or CertificateAndKerberos.
         */
        public Hashtable? KerberosAuthenticationPortMapping { get; set; }

        /**
         * Specifies how often (the monitoring interval) replication statistics are computed.
        Valid values are: 1 hour, 2 hours, 3 hours, 4 hours, 6 hours, 8 hours, 12 hours, 24 hours, 2 days, 3 days, 4 days, 5 days, 6 days, 7 days.
        Specify in the format days:hours:minutes:seconds, such as 01:00:00 for 1 hour, or 1.00:00:00 for 1 day.
         */
        public TimeSpan? MonitoringInterval { get; set; }

        /**
         * Specifies when the monitoring interval starts.
         */
        public TimeSpan? MonitoringStartTime { get; set; }

        /**
         * Specifies that a **VMReplicationServer** object is to be passed through to the pipeline representing the replication settings of the Replica server.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies whether to accept replication requests from any server.
        When specified as **true**, DefaultStorageLocation must also be specified.
        The default storage location and DEFAULT trust group tag are used for virtual machine replicas.
         */
        public Boolean? ReplicationAllowedFromAnyServer { get; set; }

        /**
         * Specifies whether the host is enabled as a Replica server.
         */
        public Boolean? ReplicationEnabled { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmreplicationserver?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a host as a Replica server.
     * </summary>
     * <remarks>
     * The **Set-VMReplicationServer** cmdlet configures a host as a Replica server and enables you to specify the types of authentication and ports to use for incoming replication traffic.
    
    To restrict the replication traffic that the Replica server will accept by allowing it only from specific servers, use the **New-VMReplicationAuthorizationEntry** cmdlet.
     * </remarks>
     */
    public void Set_VMReplicationServer(Set_VMReplicationServerArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowedAuthenticationType is not null)
            parameters.Add("AllowedAuthenticationType", args.AllowedAuthenticationType);
        if (args.CertificateAuthenticationPort is not null)
            parameters.Add("CertificateAuthenticationPort", args.CertificateAuthenticationPort);
        if (args.CertificateAuthenticationPortMapping is not null)
            parameters.Add(
                "CertificateAuthenticationPortMapping",
                args.CertificateAuthenticationPortMapping
            );
        if (args.CertificateThumbprint is not null)
            parameters.Add("CertificateThumbprint", args.CertificateThumbprint);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DefaultStorageLocation is not null)
            parameters.Add("DefaultStorageLocation", args.DefaultStorageLocation);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.KerberosAuthenticationPort is not null)
            parameters.Add("KerberosAuthenticationPort", args.KerberosAuthenticationPort);
        if (args.KerberosAuthenticationPortMapping is not null)
            parameters.Add(
                "KerberosAuthenticationPortMapping",
                args.KerberosAuthenticationPortMapping
            );
        if (args.MonitoringInterval is not null)
            parameters.Add("MonitoringInterval", args.MonitoringInterval);
        if (args.MonitoringStartTime is not null)
            parameters.Add("MonitoringStartTime", args.MonitoringStartTime);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ReplicationAllowedFromAnyServer is not null)
            parameters.Add("ReplicationAllowedFromAnyServer", args.ReplicationAllowedFromAnyServer);
        if (args.ReplicationEnabled is not null)
            parameters.Add("ReplicationEnabled", args.ReplicationEnabled);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMReplicationServer", parameters);
    }

    public class Set_VMResourcePoolArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a resource pool's parent is to be set.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the resource pool whose parent resource pool is to be set.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the name of the resource pool to be set as a parent.
         */
        public required string[]? ParentName { get; set; }

        /**
         * Specifies that a **VMResourcePool** object is to be passed through to the pipeline representing the resource pool whose parent is to be set.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the type of the resource pool whose parent is to be set.
         */
        public required VMResourcePoolType? ResourcePoolType { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmresourcepool?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Sets the parent resource pool for a selected resource pool.
     * </summary>
     * <remarks>
     * The **Set-VMResourcePool** cmdlet sets a parent resource pool for a selected resource pool. (To remove a parent from a resource pool, set the primordial pool of the resource pool's type as its parent.)
     * </remarks>
     */
    public void Set_VMResourcePool(Set_VMResourcePoolArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.ParentName is not null)
            parameters.Add("ParentName", args.ParentName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ResourcePoolType is not null)
            parameters.Add("ResourcePoolType", args.ResourcePoolType);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMResourcePool", parameters);
    }

    public class Set_VMSanArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual storage area network (SAN) is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the host bus adapter (HBA) to associate with the virtual storage area network (SAN).
        You can use the **Get-InitiatorPort** cmdlet to get this object.
         */
        public CimInstance[]? HostBusAdapter { get; set; }

        /**
         * Specifies the name of the virtual storage area network (SAN) to be configured.
         */
        public required string? Name { get; set; }

        /**
         * Specifies the note to be associated with the virtual storage area network (SAN).
         */
        public string? Note { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the configured virtual storage area network (SAN).
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }

        /**
         * The World Wide Node name of the Fibre Channel host bus adapter to be associated with this virtual storage area network (SAN).
         */
        public required string[]? WorldWideNodeName { get; set; }

        /**
         * The World Wide Port name of the Fibre Channel host bus adapter to be associated with this virtual storage area network (SAN).
         */
        public required string[]? WorldWidePortName { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmsan?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a virtual storage area network (SAN) on one or more Hyper-V hosts.
     * </summary>
     * <remarks>
     * The **Set-VMSan** cmdlet configures a virtual storage area network (SAN) on one or more Hyper-V hosts.
     * </remarks>
     */
    public void Set_VMSan(Set_VMSanArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.HostBusAdapter is not null)
            parameters.Add("HostBusAdapter", args.HostBusAdapter);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Note is not null)
            parameters.Add("Note", args.Note);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        if (args.WorldWideNodeName is not null)
            parameters.Add("WorldWideNodeName", args.WorldWideNodeName);
        if (args.WorldWidePortName is not null)
            parameters.Add("WorldWidePortName", args.WorldWidePortName);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMSan", parameters);
    }

    public class Set_VMSecurityArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts to run the cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies a user account that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Indicates that this cmdlet enables encryption of virtual machine state and migration traffic.
         */
        public Boolean? EncryptStateAndVmMigrationTraffic { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies whether to opt the virtual machine out of virtualization-based security.
        Specify a value of $True to opt out of virtualization-based security.
        If the guest operating system supports virtualization-based security, a value of $False allows it.
        The default value is $False.
        
         * To change this setting, the virtual machine must be off.
         */
        public Boolean? VirtualizationBasedSecurityOptOut { get; set; }

        /**
         * Specifies an array of virtual machines.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of virtual machine names.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmsecurity?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMSecurity.md">Get-VMSecurity</see>
     * Configures security settings for a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMSecurity** cmdlet configures security settings for a virtual machine.
     * </remarks>
     */
    public void Set_VMSecurity(Set_VMSecurityArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.EncryptStateAndVmMigrationTraffic is not null)
            parameters.Add(
                "EncryptStateAndVmMigrationTraffic",
                args.EncryptStateAndVmMigrationTraffic
            );
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VirtualizationBasedSecurityOptOut is not null)
            parameters.Add(
                "VirtualizationBasedSecurityOptOut",
                args.VirtualizationBasedSecurityOptOut
            );
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMSecurity", parameters);
    }

    public class Set_VMSecurityPolicyArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts to on which to configure security policy.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that has permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Configures the virtual machine as shielded.
         */
        public Boolean? Shielded { get; set; }

        /**
         * Specifies an array of virtual machine objects.
        This cmdlet configures the security policy for these objects.
        To obtain a virtual machine object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of virtual machine names.
        This cmdlet configures the security policy for these virtual machines.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmsecuritypolicy?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures the security policy for a virtual machine.
     * </summary>
     * <remarks>
     * The **Set-VMSecurityPolicy** cmdlet configures the security policy for a virtual machine.
     * </remarks>
     */
    public void Set_VMSecurityPolicy(Set_VMSecurityPolicyArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Shielded is not null)
            parameters.Add("Shielded", args.Shielded);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMSecurityPolicy", parameters);
    }

    public class Set_VMStorageSettingsArguments
    {
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public object? Confirm { get; set; }
        public PSCredential[]? Credential { get; set; }
        public bool? DisableInterruptBatching { get; set; }
        public object? Passthru { get; set; }
        public ThreadCount? ThreadCountPerChannel { get; set; }
        public required VirtualMachine[]? VM { get; set; }
        public required string[]? VMName { get; set; }
        public ushort? VirtualProcessorsPerChannel { get; set; }
        public object? WhatIf { get; set; }
    }

    /** <summary>
     *
     * Set-VMStorageSettings [-VMName] <string[]> [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-Passthru] [-DisableInterruptBatching <bool>] [-ThreadCountPerChannel <ThreadCount>] [-VirtualProcessorsPerChannel <ushort>] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * Set-VMStorageSettings [-VM] <VirtualMachine[]> [-Passthru] [-DisableInterruptBatching <bool>] [-ThreadCountPerChannel <ThreadCount>] [-VirtualProcessorsPerChannel <ushort>] [-WhatIf] [-Confirm] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VirtualMachine[] Set_VMStorageSettings(Set_VMStorageSettingsArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DisableInterruptBatching is not null)
            parameters.Add("DisableInterruptBatching", args.DisableInterruptBatching);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ThreadCountPerChannel is not null)
            parameters.Add("ThreadCountPerChannel", args.ThreadCountPerChannel);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VirtualProcessorsPerChannel is not null)
            parameters.Add("VirtualProcessorsPerChannel", args.VirtualProcessorsPerChannel);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Set-VMStorageSettings", parameters);
        return result;
    }

    public class Set_VMSwitchArguments
    {
        /**
         * Specifies whether the management operating system can use the physical network adapter that is bound to the virtual switch. Setting **AllowManagementOS** to `$true` creates management operating system virtual network adapters (VMNetworkAdapters) in the parent partition and connects it to the virtual switch. Setting **AllowManagementOS** to `$false` removes any VMNetworkAdapters connected to the virtual switch.
         */
        public Boolean? AllowManagementOS { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual switch is to be configured.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the minimum bandwidth, in bits per second, that is allocated to a special category called "default flow." Any traffic sent by a virtual network adapter that is connected to this virtual switch and does not have minimum bandwidth allocated is filtered into this category.
        Specify a value for this parameter only if the minimum bandwidth mode on this virtual switch is absolute (See the **New-VMSwitch** cmdlet).
        By default, the virtual switch allocates 10% of the total bandwidth, which depends on the physical network adapter it binds to, to this category.
        For example, if a virtual switch binds to a 1 GbE network adapter, this special category can use at least 100 Mbps.
        If the value is not a multiple of 8, the value is rounded down to the nearest number that is a multiple of 8.
        For example, a value input as 1234567 is converted to 1234560.
         */
        public Int64? DefaultFlowMinimumBandwidthAbsolute { get; set; }

        /**
         * Specifies the minimum bandwidth, in relative weight, that is allocated to a special category called "default flow".
        Any traffic sent by a virtual network adapter that is connected to this virtual switch and doesn't have minimum bandwidth allocated is filtered into this category.
        Specify a value for this parameter only if the minimum bandwidth mode on this virtual switch is weight (See the **New-VMSwitch** cmdlet).
        By default, this special category has a weight of 1.
         */
        public Int64? DefaultFlowMinimumBandwidthWeight { get; set; }

        /**
         *
         */
        public Boolean? DefaultQueueVmmqEnabled { get; set; }

        /**
         *
         */
        public UInt32? DefaultQueueVmmqQueuePairs { get; set; }

        /**
         *
         */
        public Boolean? DefaultQueueVrssEnabled { get; set; }

        /**
         * Specifies an ordered list of network extensions used to reorder the bindings on the virtual switch.
         */
        public VMSwitchExtension[]? Extensions { get; set; }

        /**
         * Specifies the name of the virtual switch to be configured.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies the interface description of the physical network adapter to which an external virtual switch should be bound.
        If you specify this parameter to convert a virtual switch, the external virtual switch is configured to allow the management operating system to share access to the physical network adapter.
        To override this behavior, include AllowManagementOs $false in the command
         */
        public required string? NetAdapterInterfaceDescription { get; set; }

        /**
         * Specifies the name of the physical network adapter to which an external virtual switch should be bound.
        If you specify this parameter to convert a virtual switch, the external virtual switch is configured to allow the management operating system to share access to the physical network adapter.
        To override this behavior, include AllowManagementOs $false in the command
         */
        public required string? NetAdapterName { get; set; }

        /**
         * Specifies notes to be associated with the virtual switch.
         */
        public string? Notes { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.EthernetSwitch** object is to be passed through to the pipeline representing the virtual switch to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Converts a virtual switch from one type to another.
        Allowed values are **Internal** or **Private**.
        You can convert an internal or private virtual switch to an external virtual switch, by including either the **NetAdapterInterfaceDescription** or **NetAdapterName** parameter in the command.
        If you do this, the external virtual switch is configured to allow the management operating system to share access to the physical network adapter.
        To override this behavior, include AllowManagementOs $false in the command.
         */
        public VMSwitchType? SwitchType { get; set; }

        /**
         * Specifies the virtual switch to be configured.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmswitch?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a virtual switch.
     * </summary>
     * <remarks>
     * The **Set-VMSwitch** cmdlet configures a virtual switch.
     * </remarks>
     */
    public void Set_VMSwitch(Set_VMSwitchArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AllowManagementOS is not null)
            parameters.Add("AllowManagementOS", args.AllowManagementOS);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DefaultFlowMinimumBandwidthAbsolute is not null)
            parameters.Add(
                "DefaultFlowMinimumBandwidthAbsolute",
                args.DefaultFlowMinimumBandwidthAbsolute
            );
        if (args.DefaultFlowMinimumBandwidthWeight is not null)
            parameters.Add(
                "DefaultFlowMinimumBandwidthWeight",
                args.DefaultFlowMinimumBandwidthWeight
            );
        if (args.DefaultQueueVmmqEnabled is not null)
            parameters.Add("DefaultQueueVmmqEnabled", args.DefaultQueueVmmqEnabled);
        if (args.DefaultQueueVmmqQueuePairs is not null)
            parameters.Add("DefaultQueueVmmqQueuePairs", args.DefaultQueueVmmqQueuePairs);
        if (args.DefaultQueueVrssEnabled is not null)
            parameters.Add("DefaultQueueVrssEnabled", args.DefaultQueueVrssEnabled);
        if (args.Extensions is not null)
            parameters.Add("Extensions", args.Extensions);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NetAdapterInterfaceDescription is not null)
            parameters.Add("NetAdapterInterfaceDescription", args.NetAdapterInterfaceDescription);
        if (args.NetAdapterName is not null)
            parameters.Add("NetAdapterName", args.NetAdapterName);
        if (args.Notes is not null)
            parameters.Add("Notes", args.Notes);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchType is not null)
            parameters.Add("SwitchType", args.SwitchType);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMSwitch", parameters);
    }

    public class Set_VMSwitchExtensionPortFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which this cmdlet operates.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the virtual switch port connected to the external network adapter.
         */
        public SwitchParameter? ExternalPort { get; set; }

        /**
         * Specifies the management (e.g.
        parent, or host) operating system.
         */
        public SwitchParameter? ManagementOS { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VMSwitchExtensionPortFeature** object is to be passed through to the pipeline representing the feature to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual switch.
         */
        public string? SwitchName { get; set; }

        /**
         * Specifies the virtual machine on which the feature is to be configured.
         */
        public VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine on which the feature is to be configured.
         */
        public string[]? VMName { get; set; }

        /**
         * Specifies the virtual network adapter.
         */
        public VMNetworkAdapterBase[]? VMNetworkAdapter { get; set; }

        /**
         * Specifies the name of the virtual network adapter.
         */
        public string? VMNetworkAdapterName { get; set; }

        /**
         * Specifies the feature to be configured.
         */
        public required VMSwitchExtensionPortFeature[]? VMSwitchExtensionFeature { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmswitchextensionportfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a feature on a virtual network adapter.
     * </summary>
     * <remarks>
     * The **Set-VMSwitchExtensionPortFeature** cmdlet configures a feature on a virtual network adapter. The feature must have been configured previously on the virtual network adapter.
     * </remarks>
     */
    public void Set_VMSwitchExtensionPortFeature(Set_VMSwitchExtensionPortFeatureArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ExternalPort is not null)
            parameters.Add("ExternalPort", args.ExternalPort);
        if (args.ManagementOS is not null)
            parameters.Add("ManagementOS", args.ManagementOS);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.VMNetworkAdapterName is not null)
            parameters.Add("VMNetworkAdapterName", args.VMNetworkAdapterName);
        if (args.VMSwitchExtensionFeature is not null)
            parameters.Add("VMSwitchExtensionFeature", args.VMSwitchExtensionFeature);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMSwitchExtensionPortFeature", parameters);
    }

    public class Set_VMSwitchExtensionSwitchFeatureArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which this cmdlet operates.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VMSwitchExtensionSwitchFeature** is to be passed through to the pipeline representing the feature to be configured.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the name of the virtual switch.
         */
        public string[]? SwitchName { get; set; }

        /**
         * Specifies the virtual switch.
         */
        public VMSwitch[]? VMSwitch { get; set; }

        /**
         * Specifies the feature to be configured.
         */
        public required VMSwitchExtensionSwitchFeature[]? VMSwitchExtensionFeature { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmswitchextensionswitchfeature?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Configures a feature on a virtual switch.
     * </summary>
     * <remarks>
     * The **Set-VMSwitchExtensionSwitchFeature** cmdlet configures a feature on a virtual switch. The feature must have already been configured on the virtual switch.
     * </remarks>
     */
    public void Set_VMSwitchExtensionSwitchFeature(Set_VMSwitchExtensionSwitchFeatureArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.SwitchName is not null)
            parameters.Add("SwitchName", args.SwitchName);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.VMSwitchExtensionFeature is not null)
            parameters.Add("VMSwitchExtensionFeature", args.VMSwitchExtensionFeature);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Set-VMSwitchExtensionSwitchFeature", parameters);
    }

    public class Set_VMSwitchTeamArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the load balancing algorithm that this switch team uses.
        The acceptable values for this parameter are: Dynamic and HyperVPort.
        The default value is Dynamic.
         */
        public VMSwitchLoadBalancingAlgorithm? LoadBalancingAlgorithm { get; set; }

        /**
         * Specifies an array of names of virtual switches that this cmdlet configures for teaming.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies an array of interface descriptions of the virtual network adapters that this cmdlet includes in the switch team.
        This value replaces the existing members.
         */
        public string[]? NetAdapterInterfaceDescription { get; set; }

        /**
         * Specifies an array of names of the virtual network adapters that this cmdlet includes in the switch team.
        This value replaces the existing members.
         */
        public string[]? NetAdapterName { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VMSwitch** object that it configures.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the teaming mode.
        Currently, the only option is SwitchIndependent.
         */
        public VMSwitchTeamingMode? TeamingMode { get; set; }

        /**
         * Specifies an array of virtual switches that this cmdlet configures for teaming.
        To obtain a **VMSwitch** object, use the **Get-VMSwitch** cmdlet.
         */
        public required VMSwitch[]? VMSwitch { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmswitchteam?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMSwitchTeam.md">Get-VMSwitchTeam</see>
     *
     * <see href="./Get-VMSwitch.md">Get-VMSwitch</see>
     * Configures a virtual switch team.
     * </summary>
     * <remarks>
     * The **Set-VMSwitchTeam** cmdlet configures a virtual switch team.
     * </remarks>
     * <returns>This cmdlet returns a **VMSwitch** object, if you specify the **Passthru** parameter.</returns>
     */
    public VMSwitch[] Set_VMSwitchTeam(Set_VMSwitchTeamArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.LoadBalancingAlgorithm is not null)
            parameters.Add("LoadBalancingAlgorithm", args.LoadBalancingAlgorithm);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NetAdapterInterfaceDescription is not null)
            parameters.Add("NetAdapterInterfaceDescription", args.NetAdapterInterfaceDescription);
        if (args.NetAdapterName is not null)
            parameters.Add("NetAdapterName", args.NetAdapterName);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.TeamingMode is not null)
            parameters.Add("TeamingMode", args.TeamingMode);
        if (args.VMSwitch is not null)
            parameters.Add("VMSwitch", args.VMSwitch);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMSwitch>("Set-VMSwitchTeam", parameters);
        return result;
    }

    public class Set_VMVideoArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the horizontal resolution for the virtual machine display.
         */
        public UInt16? HorizontalResolution { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.PowerShell.VMVideo** object that it modifies.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the resolution type for the virtual machine display.
        The acceptable values for this parameter are:
        
         * - Maximum.
        The input HorizontalResolution * VerticalResolution is the maximum supported resolution.
        All standard resolutions smaller than HorizontalResolution * VerticalResolution are also supported.
        - Single.
        The input HorizontalResolution * VerticalResolution is the only supported resolution.
        - Default.
        The supported resolutions are those in the list of standard resolutions.
        Input HorizontalResolution * VerticalResolution is ignored.
         */
        public ResolutionType? ResolutionType { get; set; }

        /**
         * Specifies the vertical resolution for the virtual machine display.
         */
        public UInt16? VerticalResolution { get; set; }

        /**
         * Specifies an array of virtual machines for which this cmdlet configures video settings.
        To obtain a **VirtualMachine** object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies an array of names of virtual machines for which this cmdlet configures video settings.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies an array of virtual machine video settings that this cmdlet configures.
        To obtain a **VMVideo** object, use the **Get-VMVideo** cmdlet.
         */
        public required VMVideo[]? VMVideo { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/set-vmvideo?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VMVideo.md">Get-VMVideo</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     * Configures video settings for virtual machines.
     * </summary>
     * <remarks>
     * The **Set-VMVideo** cmdlet configures the video settings for virtual machines.
     * </remarks>
     * <returns>This cmdlet returns a **VirtualMachine** object, if you specify the **Passthru** parameter.</returns>
     */
    public VMVideo[] Set_VMVideo(Set_VMVideoArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.HorizontalResolution is not null)
            parameters.Add("HorizontalResolution", args.HorizontalResolution);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ResolutionType is not null)
            parameters.Add("ResolutionType", args.ResolutionType);
        if (args.VerticalResolution is not null)
            parameters.Add("VerticalResolution", args.VerticalResolution);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMVideo is not null)
            parameters.Add("VMVideo", args.VMVideo);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMVideo>("Set-VMVideo", parameters);
        return result;
    }

    public class Start_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual machine is to be started.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual machine to be started.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VirtualMachine** object is to be passed through to the pipeline representing the virtual machine to be started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine to be started.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/start-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Starts a virtual machine.
     * </summary>
     * <remarks>
     * The **Start-VM** cmdlet starts a virtual machine.
     * </remarks>
     */
    public void Start_VM(Start_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Start-VM", parameters);
    }

    public class Start_VMFailoverArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Creates a test virtual machine using the chosen recovery point.
        You can use a test virtual machine to validate a Replica virtual machine.
        To stop a test failover, use the **Stop-VMFailover** cmdlet.
         */
        public required SwitchParameter? AsTest { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which failover is to be started.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a virtual machine object is to be passed through to the pipeline representing the virtual machine on which failover is to be started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Starts the planned failover on the primary virtual machine and replicates any pending changes.
        To complete the planned failover, use the **Set-VMReplication** and **Start-VM** cmdlets as shown in Example 4.
        
         * Note: The primary virtual machine must be shut down to prepare it for failover.
         */
        public SwitchParameter? Prepare { get; set; }

        /**
         * Specifies the virtual machine for which failover is to be started.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine for which failover is to be started.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the recovery snapshot to use during a failover.
        (This parameter is not required for a planned failover.)
         */
        public required VMSnapshot? VMRecoverySnapshot { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/start-vmfailover?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Starts failover on a virtual machine.
     * </summary>
     * <remarks>
     * The **Start-VMFailover** cmdlet can be used for the following tasks:
    
    - Fail over a Replica virtual machine to a chosen recovery point. - Start a planned failover on a primary virtual machine. - Create a test virtual machine on a Replica virtual machine.
     * </remarks>
     */
    public void Start_VMFailover(Start_VMFailoverArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.AsTest is not null)
            parameters.Add("AsTest", args.AsTest);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Prepare is not null)
            parameters.Add("Prepare", args.Prepare);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMRecoverySnapshot is not null)
            parameters.Add("VMRecoverySnapshot", args.VMRecoverySnapshot);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Start-VMFailover", parameters);
    }

    public class Start_VMInitialReplicationArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which replication of a virtual machine is to be started.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the path to use when copying the files for initial replication; assumes use of external media as the method for initial replication.
        External media is typically a removable drive that is shipped to the location of the Replica server.
        When the external media arrives at the Replica site, use the **Import-InitialVMReplication** cmdlet on the Replica virtual machine to copy the files.
         */
        public string? DestinationPath { get; set; }

        /**
         * Specifies the time to start the initial replication, when scheduling initial replication to occur later.
        You can specify a time up to 7 days later.
        When this parameter is not specified, initial replication occurs immediately.
         */
        public DateTime? InitialReplicationStartTime { get; set; }

        /**
         * Specifies that a virtual machine object is to be passed through to the pipeline representing the virtual machine on which replication is to be started.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Indicates that you want to use a copy of this virtual machine on the Replica server as the basis for the initial replication.
        Specify this option only if it was specified when replication was enabled on the primary virtual machine.
         */
        public SwitchParameter? UseBackup { get; set; }

        /**
         * Specifies the virtual machine on which replication is to be started.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine on which replication is to be started.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies an object that represents the replication to be started.
        You can get this object from the **Get-VMReplication** cmdlet.
         */
        public required VMReplication[]? VMReplication { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/start-vminitialreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Starts replication of a virtual machine.
     * </summary>
     * <remarks>
     * The **Start-VMInitialReplication** cmdlet starts replication of a virtual machine using the method you select. You also can schedule replication to start up to 7 days later.
     * </remarks>
     */
    public void Start_VMInitialReplication(Start_VMInitialReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.DestinationPath is not null)
            parameters.Add("DestinationPath", args.DestinationPath);
        if (args.InitialReplicationStartTime is not null)
            parameters.Add("InitialReplicationStartTime", args.InitialReplicationStartTime);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.UseBackup is not null)
            parameters.Add("UseBackup", args.UseBackup);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMReplication is not null)
            parameters.Add("VMReplication", args.VMReplication);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Start-VMInitialReplication", parameters);
    }

    public class Start_VMTraceArguments
    {
        /**
         * Specifies the level of tracing.
        The acceptable values for this parameter are:
        
         * - Off
        - Error
        - Warning
        - Info
        - Verbose
         */
        public required TraceLevel? Level { get; set; }

        /**
         * Specifies the path of the file where this cmdlet stores the trace information.
         */
        public string? Path { get; set; }

        /**
         * Specifies that tracing uses verbose objects.
         */
        public SwitchParameter? TraceVerboseObjects { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/start-vmtrace?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Stop-VMTrace.md">Stop-VMTrace</see>
     * Starts tracing to a file.
     * </summary>
     * <remarks>
     * The **Start-VMTrace** cmdlet starts tracing to a file. You can use this information for advanced debugging.
     * </remarks>
     */
    public System.Object[] Start_VMTrace(Start_VMTraceArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.Level is not null)
            parameters.Add("Level", args.Level);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.TraceVerboseObjects is not null)
            parameters.Add("TraceVerboseObjects", args.TraceVerboseObjects);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<System.Object>("Start-VMTrace", parameters);
        return result;
    }

    public class Stop_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual machine is to be shut down.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that the shutdown of the virtual machine is to be forced.
        If the virtual machine has applications with unsaved data, the virtual machine has five minutes to save data and shut down.
        If the virtual machine is locked, it is shut down immediately.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies the name of the virtual machine to be shut down.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VirtualMachine** object is to be passed through to the pipeline representing the virtual machine to be shut down.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies that the virtual machine is to be saved.
         */
        public SwitchParameter? Save { get; set; }

        /**
         * Specifies that the virtual machine is to be turned off.
         */
        public SwitchParameter? TurnOff { get; set; }

        /**
         * Specifies the virtual machine to be shut down.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/stop-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Shuts down, turns off, or saves a virtual machine.
     * </summary>
     * <remarks>
     * The **Stop-VM** cmdlet shuts down, turns off, or saves a virtual machine.
     * </remarks>
     */
    public void Stop_VM(Stop_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Save is not null)
            parameters.Add("Save", args.Save);
        if (args.TurnOff is not null)
            parameters.Add("TurnOff", args.TurnOff);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Stop-VM", parameters);
    }

    public class Stop_VMFailoverArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more hosts on which to cancel the failover of a virtual machine.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual machine whose initial replication is to be stopped.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine whose failover you want to cancel.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose you want to cancel.
         */
        public required string[]? VMName { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/stop-vmfailover?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Stops failover of a virtual machine.
     * </summary>
     * <remarks>
     * The **Stop-VMFailover** cmdlet stops failover of a virtual machine. If the virtual machine is running, this cmdlet turns the virtual machine off and cancels failover. For a test failover, this cmdlet stops the test failover and deletes the test virtual machine. For a planned failover that has been started on a primary virtual machine, this cmdlet cancels that action and restarts replication, which allows you to start the primary virtual machine.
     * </remarks>
     */
    public void Stop_VMFailover(Stop_VMFailoverArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Stop-VMFailover", parameters);
    }

    public class Stop_VMInitialReplicationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which an ongoing initial replication is to be stopped.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual machine whose initial replication is to be stopped.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine whose initial replication is to be stopped.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose initial replication is to be stopped.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine replication to be stopped.
         */
        public required VMReplication[]? VMReplication { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/stop-vminitialreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Stops an ongoing initial replication.
     * </summary>
     * <remarks>
     * The **Stop-VMInitialReplication** cmdlet stops an ongoing initial replication that uses either a virtual machine restored from backup or the network. It does not stop an initial replication that uses external media. For an initial replication that uses external media, you can use this cmdlet to stop the export, which returns the virtual machine to a pending state. After an export is finished, the initial replication cannot be stopped.
     * </remarks>
     */
    public void Stop_VMInitialReplication(Stop_VMInitialReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMReplication is not null)
            parameters.Add("VMReplication", args.VMReplication);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Stop-VMInitialReplication", parameters);
    }

    public class Stop_VMReplicationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the ongoing virtual machine resynchronization is to be stopped.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that an object is to be passed through to the pipeline representing the virtual machine on which the ongoing virtual machine resynchronization is to be stopped.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the replication relationship type of the virtual machine.
        Specify whether the replication relationship is a simple primary to replica or is an extended replication chain.
        The cmdlet cancels the ongoing resynchronization of the virtual machines that have the replication type that you specify.
         */
        public VMReplicationRelationshipType? ReplicationRelationshipType { get; set; }

        /**
         * Specifies the virtual machine whose resynchronization is to be stopped.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose resynchronization is to be stopped.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the resynchronization to be stopped.
         */
        public required VMReplication[]? VMReplication { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/stop-vmreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Cancels an ongoing virtual machine resynchronization.
     * </summary>
     * <remarks>
     * The **Stop-VMReplication** cmdlet cancels an ongoing virtual machine resynchronization.
     * </remarks>
     */
    public void Stop_VMReplication(Stop_VMReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ReplicationRelationshipType is not null)
            parameters.Add("ReplicationRelationshipType", args.ReplicationRelationshipType);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMReplication is not null)
            parameters.Add("VMReplication", args.VMReplication);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Stop-VMReplication", parameters);
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/stop-vmtrace?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Start-VMTrace.md">Start-VMTrace</see>
     * Stops tracing to file.
     * </summary>
     * <remarks>
     * The **Stop-VMTrace** cmdlet stops tracing to a file.
     * </remarks>
     */
    public System.Object[] Stop_VMTrace()
    {
        var parameters = new Dictionary<string, object>();
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<System.Object>("Stop-VMTrace", parameters);
        return result;
    }

    public class Suspend_VMArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which a virtual machine is to be suspended.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the virtual machine to be suspended.
         */
        public required string[]? Name { get; set; }

        /**
         * Specifies that a **Microsoft.HyperV.PowerShell.VirtualMachine** object is to be passed through to the pipeline representing the virtual machine to be suspended.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the virtual machine to be suspended.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/suspend-vm?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Suspends, or pauses, a virtual machine.
     * </summary>
     * <remarks>
     * The **Suspend-VM** cmdlet suspends a virtual machine. To return a suspended virtual machine to a running state, use the **Resume-VM** cmdlet.
     * </remarks>
     */
    public void Suspend_VM(Suspend_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Suspend-VM", parameters);
    }

    public class Suspend_VMReplicationArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which replication of a virtual machine is to be suspended.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies that a **VMReplication** object is to be passed through to the pipeline representing the replication to be suspended.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies the replication relationship type of the virtual machine.
        Specify whether the replication relationship is a simple primary to replica or is an extended replication chain.
        The cmdlet suspends replication of the virtual machines that have the replication type that you specify.
         */
        public VMReplicationRelationshipType? ReplicationRelationshipType { get; set; }

        /**
         * Specifies the virtual machine whose replication is to be suspended.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Specifies the name of the virtual machine whose replication is to be suspended.
         */
        public required string[]? VMName { get; set; }

        /**
         * Specifies the virtual machine replication to be suspended.
         */
        public required VMReplication[]? VMReplication { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/suspend-vmreplication?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Suspends replication of a virtual machine.
     * </summary>
     * <remarks>
     * The **Suspend-VMReplication** cmdlet suspends, or pauses, replication of a virtual machine. To resume replication, use the **Resume-VMReplication** cmdlet to resume replication. When replication is resumed, all changes made since replication was suspended will be replicated.
     * </remarks>
     */
    public void Suspend_VMReplication(Suspend_VMReplicationArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.ReplicationRelationshipType is not null)
            parameters.Add("ReplicationRelationshipType", args.ReplicationRelationshipType);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMReplication is not null)
            parameters.Add("VMReplication", args.VMReplication);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Suspend-VMReplication", parameters);
    }

    public class Test_VHDArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which the virtual hard disk is to be tested.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the path to the virtual hard disk file of the virtual hard disk to be tested.
        If a filename or relative path is specified, the new virtual hard disk path is calculated relative to the current working directory.
         */
        public required string[]? Path { get; set; }

        /**
         * Indicates that the cmdlet tests for SCSI persistent reservation support semantics.
        Specify this parameter to test whether a virtual hard disk or path supports shared virtual disks.
         */
        public required SwitchParameter? SupportPersistentReservations { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/test-vhd?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Tests a virtual hard disk for any problems that would make it unusable.
     * </summary>
     * <remarks>
     * The **Test-VHD** cmdlet tests a virtual hard disk for any problems that would make it unusable.
     * </remarks>
     */
    public System.Boolean[] Test_VHD(Test_VHDArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Path is not null)
            parameters.Add("Path", args.Path);
        if (args.SupportPersistentReservations is not null)
            parameters.Add("SupportPersistentReservations", args.SupportPersistentReservations);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<System.Boolean>("Test-VHD", parameters);
        return result;
    }

    public class Test_VMNetworkAdapterArguments
    {
        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts on which this cmdlet operates.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the ID of a virtual subnet.
         */
        public int? IsolationId { get; set; }

        /**
         * Specifies the name of the virtual machine.
         */
        public string? Name { get; set; }

        /**
         * Specified the MAC address for the next hop VM required for non-Hyper-V Network Virtualization configurations.
         */
        public string? NextHopMacAddress { get; set; }

        /**
         * Returns an object representing the item with which you are working.
        By default, this cmdlet does not generate any output.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         *
         */
        public int? PayloadSize { get; set; }

        /**
         * Indicates that the cmdlet targets the receiver virtual machine.
         */
        public SwitchParameter? Receiver { get; set; }

        /**
         * Specifies the IP address of the receiver virtual machine.
         */
        public required string? ReceiverIPAddress { get; set; }

        /**
         * Indicates that the cmdlet targets the sender virtual machine.
         */
        public SwitchParameter? Sender { get; set; }

        /**
         * Specifies the IP address of the sender virtual machine.
         */
        public required string? SenderIPAddress { get; set; }

        /**
         * Specifies the sequence number to use to generate ICMP Ping packets.
        The default value is 100.
         */
        public required int? SequenceNumber { get; set; }

        /**
         * Specifies a virtual machine.
        The cmdlet tests connectivity for adapters that belong to the virtual machines that you specify.
         */
        public required VirtualMachine? VM { get; set; }

        /**
         * Specifies the name of a virtual machine.
         */
        public required string? VMName { get; set; }

        /**
         * Specifies a virtual machine network adapter as a **VMNetworkAdapterBase** object.
        The cmdlet tests connectivity for the adapters that you specify.
        To obtain a network adapter, use the **Get-VMNetworkAdapter** cmdlet.
         */
        public required VMNetworkAdapter? VMNetworkAdapter { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/test-vmnetworkadapter?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Add-VMNetworkAdapter.md">Add-VMNetworkAdapter</see>
     *
     * <see href="./Connect-VMNetworkAdapter.md">Connect-VMNetworkAdapter</see>
     *
     * <see href="./Disconnect-VMNetworkAdapter.md">Disconnect-VMNetworkAdapter</see>
     *
     * <see href="./Get-VMNetworkAdapter.md">Get-VMNetworkAdapter</see>
     *
     * <see href="./Remove-VMNetworkAdapter.md">Remove-VMNetworkAdapter</see>
     *
     * <see href="./Rename-VMNetworkAdapter.md">Rename-VMNetworkAdapter</see>
     *
     * <see href="./Set-VMNetworkAdapter.md">Set-VMNetworkAdapter</see>
     * Tests connectivity between virtual machines.
     * </summary>
     * <remarks>
     * The **Test-VMNetworkAdapter** cmdlet tests connectivity between virtual machines by using Internet Control Message Protocol (ICMP) Ping packets. Ping verifies IP-level connectivity to another TCP/IP computer by sending ICMP Echo Request messages.
     * </remarks>
     */
    public VMNetworkAdapterConnectionTestResult[] Test_VMNetworkAdapter(
        Test_VMNetworkAdapterArguments args
    )
    {
        var parameters = new Dictionary<string, object>();
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.IsolationId is not null)
            parameters.Add("IsolationId", args.IsolationId);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.NextHopMacAddress is not null)
            parameters.Add("NextHopMacAddress", args.NextHopMacAddress);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.PayloadSize is not null)
            parameters.Add("PayloadSize", args.PayloadSize);
        if (args.Receiver is not null)
            parameters.Add("Receiver", args.Receiver);
        if (args.ReceiverIPAddress is not null)
            parameters.Add("ReceiverIPAddress", args.ReceiverIPAddress);
        if (args.Sender is not null)
            parameters.Add("Sender", args.Sender);
        if (args.SenderIPAddress is not null)
            parameters.Add("SenderIPAddress", args.SenderIPAddress);
        if (args.SequenceNumber is not null)
            parameters.Add("SequenceNumber", args.SequenceNumber);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.VMName is not null)
            parameters.Add("VMName", args.VMName);
        if (args.VMNetworkAdapter is not null)
            parameters.Add("VMNetworkAdapter", args.VMNetworkAdapter);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VMNetworkAdapterConnectionTestResult>(
            "Test-VMNetworkAdapter",
            parameters
        );
        return result;
    }

    public class Test_VMReplicationConnectionArguments
    {
        /**
         * Specifies the authentication type to use to test the connection, either "Kerberos" or "Certificate".
        The specified Replica server must support the chosen authentication type.
        Run the **Get-VMReplicationServer** cmdlet to verify the authentication configured for the specified Replica server, or contact the administrator of the specified Replica server.
         */
        public required ReplicationAuthenticationType? AuthenticationType { get; set; }

        /**
         * Specifies whether to bypass a proxy server when testing the connectivity.
         */
        public Boolean? BypassProxyServer { get; set; }

        /**
         * Specifies the certificate to use for mutual authentication of the replication data.
        This parameter is required only when "Certificate" is the specified as the type of authentication.
        Specify the thumbprint of a valid computer certificate from the Personal store.
        
         * The certificate must have all of the following properties to be valid:
        
         * It must not be expired.
        
         * It must include both client and server authentication extensions for extended key usage (EKU), and an associated private key.
        
         * It must terminate at a valid root certificate.
        
         * The requirement for the subject common name (CN) differs depending on whether the virtual machine belongs to a cluster.
        For virtual machines that do not belong to a cluster, the subject common name (CN) must be equal to, or subject alternative name (DNS Name) should contain, the FQDN of the host.
        For virtual machines that belong to a cluster, the subject common name (CN) must be equal to, or subject alternative name (DNS Name) must contain, the FQDN of the Hyper-V Replica Broker.
        
         * To display a list certificates in the computer's My store and the thumbprint of each certificate, type the following:
        
         * `PS C:\\\> cd cert:\LocalMachine\My`
        
         * `PS C:\\\> dir | format-list`
        
         * For more information about certificate stores, see [http://technet.microsoft.com//library/cc757138.aspx](https://technet.microsoft.com//library/cc757138.aspx).
         */
        public string? CertificateThumbprint { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that have the virtual machines for which you want to test the connection for replication.
        NetBIOS names, IP addresses, and fully qualified domain names (FQDN) are allowed.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Specifies the name of the Replica server to test for connectivity with the virtual machine to be replicated.
         */
        public required string? ReplicaServerName { get; set; }

        /**
         * Specifies the port on the Replica server to use to test connectivity.
        Make sure you specify a port that is configured on the Replica server to support the same authentication type you specify using the AuthenticationType parameter in this cmdlet.
        Run the **Get-VMReplicationServer** cmdlet on the Replica server to check the configuration of the port, or contact the administrator of the specified Replica server.
         */
        public required int? ReplicaServerPort { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/test-vmreplicationconnection?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     * Tests the connection between a primary server and a Replica server.
     * </summary>
     * <remarks>
     * The **Test-VMReplicationConnection** cmdlet tests the connection between a primary server and a Replica server to determine whether replication can be enabled for virtual machines on the primary server to the specified Replica server.
     * </remarks>
     */
    public void Test_VMReplicationConnection(Test_VMReplicationConnectionArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AuthenticationType is not null)
            parameters.Add("AuthenticationType", args.AuthenticationType);
        if (args.BypassProxyServer is not null)
            parameters.Add("BypassProxyServer", args.BypassProxyServer);
        if (args.CertificateThumbprint is not null)
            parameters.Add("CertificateThumbprint", args.CertificateThumbprint);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.ReplicaServerName is not null)
            parameters.Add("ReplicaServerName", args.ReplicaServerName);
        if (args.ReplicaServerPort is not null)
            parameters.Add("ReplicaServerPort", args.ReplicaServerPort);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction("Test-VMReplicationConnection", parameters);
    }

    public class Update_VMVersionArguments
    {
        /**
         * Runs the cmdlet as a background job.
         */
        public SwitchParameter? AsJob { get; set; }

        /**
         * Runs the cmdlet in a remote session or on a remote computer.
        Enter a computer name or a session object, such as the output of a [New-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227967) or [Get-CimSession](https://go.microsoft.com/fwlink/p/?LinkId=227966) cmdlet.
        The default is the current session on the local computer.
         */
        public CimSession[]? CimSession { get; set; }

        /**
         * Specifies one or more Hyper-V hosts that run this cmdlet.
        NetBIOS names, IP addresses, and fully qualified domain names are allowable.
        The default is the local computer.
        Use localhost or a dot (.) to specify the local computer explicitly.
         */
        public string[]? ComputerName { get; set; }

        /**
         * Prompts you for confirmation before running the cmdlet.
         */
        public SwitchParameter? Confirm { get; set; }

        /**
         * Specifies one or more user accounts that have permission to perform this action.
        The default is the current user.
         */
        public PSCredential[]? Credential { get; set; }

        /**
         * Forces the command to run without asking for user confirmation.
         */
        public SwitchParameter? Force { get; set; }

        /**
         * Specifies an array of names of the virtual machines that this cmdlet updates.
         */
        public required string[]? Name { get; set; }

        /**
         * Indicates that this cmdlet returns the **Microsoft.HyperV.VirtualMachine** object that it modifies.
         */
        public SwitchParameter? Passthru { get; set; }

        /**
         * Specifies an array of virtual machines that this cmdlet updates.
        To obtain a **VirtualMachine** object, use the **Get-VM** cmdlet.
         */
        public required VirtualMachine[]? VM { get; set; }

        /**
         * Shows what would happen if the cmdlet runs.
        The cmdlet is not run.
         */
        public SwitchParameter? WhatIf { get; set; }
    }

    /** <summary>
     * <see href="https://learn.microsoft.com/powershell/module/hyper-v/update-vmversion?view=windowsserver2025-ps&amp;wt.mc_id=ps-gethelp">Online Version</see>
     *
     * <see href="./Get-VM.md">Get-VM</see>
     * Updates the version of virtual machines.
     * </summary>
     * <remarks>
     * The **Update-VMVersion** cmdlet updates virtual machines to the current version.
     * </remarks>
     * <returns>This cmdlet returns a **VirtualMachine** object, if you specify the **Passthru** parameter.</returns>
     */
    public VirtualMachine[] Update_VMVersion(Update_VMVersionArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Confirm is not null)
            parameters.Add("Confirm", args.Confirm);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Force is not null)
            parameters.Add("Force", args.Force);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        if (args.WhatIf is not null)
            parameters.Add("WhatIf", args.WhatIf);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Update-VMVersion", parameters);
        return result;
    }

    public class Wait_VMArguments
    {
        public object? AsJob { get; set; }
        public CimSession[]? CimSession { get; set; }
        public string[]? ComputerName { get; set; }
        public PSCredential[]? Credential { get; set; }
        public ushort? Delay { get; set; }
        public WaitVMTypes? For { get; set; }
        public required string[]? Name { get; set; }
        public object? Passthru { get; set; }
        public int? Timeout { get; set; }
        public required VirtualMachine[]? VM { get; set; }
    }

    /** <summary>
     *
     * Wait-VM [-Name] <string[]> [-CimSession <CimSession[]>] [-ComputerName <string[]>] [-Credential <pscredential[]>] [-AsJob] [-Passthru] [-For <WaitVMTypes>] [-Delay <ushort>] [-Timeout <int>] [<CommonParameters>]
     *
     * Wait-VM [-VM] <VirtualMachine[]> [-AsJob] [-Passthru] [-For <WaitVMTypes>] [-Delay <ushort>] [-Timeout <int>] [<CommonParameters>]
     *
     * </summary>
     * <remarks>
     * No description available.
     * </remarks>
     */
    public VirtualMachine[] Wait_VM(Wait_VMArguments args)
    {
        var parameters = new Dictionary<string, object>();
        if (args.AsJob is not null)
            parameters.Add("AsJob", args.AsJob);
        if (args.CimSession is not null)
            parameters.Add("CimSession", args.CimSession);
        if (args.ComputerName is not null)
            parameters.Add("ComputerName", args.ComputerName);
        if (args.Credential is not null)
            parameters.Add("Credential", args.Credential);
        if (args.Delay is not null)
            parameters.Add("Delay", args.Delay);
        if (args.For is not null)
            parameters.Add("For", args.For);
        if (args.Name is not null)
            parameters.Add("Name", args.Name);
        if (args.Passthru is not null)
            parameters.Add("Passthru", args.Passthru);
        if (args.Timeout is not null)
            parameters.Add("Timeout", args.Timeout);
        if (args.VM is not null)
            parameters.Add("VM", args.VM);
        using var instance = new HyperVInstance();
        var result = instance.InvokeFunction<VirtualMachine>("Wait-VM", parameters);
        return result;
    }
}
